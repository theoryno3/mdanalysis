

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.core.AtomGroup &mdash; MDAnalysis 0.10.0-dev documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.10.0-dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.10.0-dev documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.10.0-dev documentation" href="../../../index.html" />
    <link rel="up" title="MDAnalysis" href="../../MDAnalysis.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">MDAnalysis 0.10.0-dev documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../MDAnalysis.html" accesskey="U">MDAnalysis</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for MDAnalysis.core.AtomGroup</h1><div class="highlight"><pre>
<span class="c"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8</span>
<span class="c">#</span>
<span class="c"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver Beckstein</span>
<span class="c"># and contributors (see AUTHORS for the full list)</span>
<span class="c">#</span>
<span class="c"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c">#</span>
<span class="c"># Please cite your use of MDAnalysis in published work:</span>
<span class="c">#</span>
<span class="c"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c">#</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Fundamental building blocks --- :mod:`MDAnalysis.core.AtomGroup`</span>
<span class="sd">================================================================</span>

<span class="sd">The most important data structure in MDAnalysis is the</span>
<span class="sd">:class:`AtomGroup`, which contains :class:`Atom` instances.</span>

<span class="sd">A :class:`Universe` is the user-visible entry point and collects all</span>
<span class="sd">information needed to analyze a structure or a whole trajectory.</span>

<span class="sd">Segments and residues are a way to refer to a collection of atoms. By</span>
<span class="sd">convention, a :class:`Residue` is a single amino acid, or a water</span>
<span class="sd">molecule, ion, or ligand. A :class:`Segment` is a collection of</span>
<span class="sd">residues such as a whole protein or a chain in a protein or all the</span>
<span class="sd">water in the system.</span>

<span class="sd">Class Hierarchy</span>
<span class="sd">---------------</span>

<span class="sd">A :class:`Universe` contains Segments, which contain Residues, which</span>
<span class="sd">contain Atoms; all containers are derived from :class:`AtomGroup`, and</span>
<span class="sd">thus one can always analyze them as a collection of atoms, independent</span>
<span class="sd">of the hierarchical level.</span>

<span class="sd">Each :class:`Atom` can only belong to a single :class:`Residue`, and a</span>
<span class="sd">:class:`Residue` belongs to one specific :class:`Segment`. This</span>
<span class="sd">hierarchy can be described as ::</span>

<span class="sd">    Segment &gt; Residue &gt; Atom</span>

<span class="sd">Depending on the use case, it can be more convenient to access data</span>
<span class="sd">on, for instance, the basis of residues than atoms, or to write out</span>
<span class="sd">individual chains (segments) of a protein. MDAnalysis simply provides</span>
<span class="sd">access to these groupings and keeps track of where an atom</span>
<span class="sd">belongs. Each object provides three attributes (:attr:`~AtomGroup.atoms`,</span>
<span class="sd">:attr:`~AtomGroup.residues` or :attr:`~Atom.residue`, :attr:`~AtomGroup.segments` or</span>
<span class="sd">:attr:`~Atom.segment`) that give access to the tiers in the hierarchy</span>
<span class="sd">that the object belongs to.</span>


<span class="sd">Manipulating atoms, residues, and segments</span>
<span class="sd">------------------------------------------</span>

<span class="sd">When working with MDAnalysis it is useful to remember that the fundamental</span>
<span class="sd">object is the :class:`Atom`. Each particle in the topology is represented by</span>
<span class="sd">exactly one :class:`Atom` instance. One :class:`Atom`, however, can be a member</span>
<span class="sd">of multiple :class:`AtomGroup` collections, for instance from different</span>
<span class="sd">selections even though they all refer to the *same* :class:`Atom` object. Thus,</span>
<span class="sd">changing a property of a specific and :class:`Atom` in one :class:`AtomGroup`</span>
<span class="sd">changes it &quot;everywhere&quot;.</span>

<span class="sd">The same is mostly true for :class:`Residue` instances although they are</span>
<span class="sd">derived from :class:`Atom` instances: all :class:`Atom` objects with the same</span>
<span class="sd">:attr:`Atom.resid` are bundled into a single :class:`Residue` with</span>
<span class="sd">:class:`Residue.id` = *resid*. This means that just changing, say, the residue</span>
<span class="sd">name with a command such as ::</span>

<span class="sd">  &gt;&gt;&gt; r = u.selectAtoms(&quot;resid 99&quot;).residues[0]</span>
<span class="sd">  &gt;&gt;&gt; print(r)</span>
<span class="sd">  &lt;Residue &#39;ALA&#39;, 99&gt;</span>
<span class="sd">  &gt;&gt;&gt; r.name = &quot;UNK&quot;</span>
<span class="sd">  &gt;&gt;&gt; print(r)</span>
<span class="sd">  &lt;Residue &#39;UNK&#39;, 99&gt;</span>
<span class="sd">  &gt;&gt;&gt; rnew = u.selectAtoms(&quot;resid 99&quot;).residues[0]</span>
<span class="sd">  &gt;&gt;&gt; print(rnew)</span>
<span class="sd">  &lt;Residue &#39;UNK&#39;, 99&gt;</span>

<span class="sd">will typically work as expected. When working with collections such as</span>
<span class="sd">:class:`AtomGroup` or :class:`ResidueGroup` it is generally better to use</span>
<span class="sd">provided setter methods such as :meth:`AtomGroup.set_resname` or</span>
<span class="sd">:meth:`ResidueGroup.set_resname`.</span>

<span class="sd">There are two cases when it is very important to use the setters:</span>

<span class="sd">* changing *resid*: :meth:`AtomGroup.set_resid` and :meth:`ResidueGroup.set_resid`</span>
<span class="sd">* changing *segid*: :meth:`AtomGroup.set_segid` and :meth:`ResidueGroup.set_segid`</span>

<span class="sd">Because residues are determined by the :attr:`Atom.resid` and segments by</span>
<span class="sd">:attr:`Atom.segid`, the above methods take extra care to rebuild the list of</span>
<span class="sd">segments and residues.</span>

<span class="sd">.. Note::</span>

<span class="sd">   :meth:`AtomGroup.set_resid`, :meth:`ResidueGroup.set_resid`,</span>
<span class="sd">   :meth:`AtomGroup.set_segid`, :meth:`ResidueGroup.set_segid` can change the</span>
<span class="sd">   topology: they can split or merge residues or segments.</span>

<span class="sd">Splitting/merging of residues is probably not very useful because no chemical</span>
<span class="sd">rearrangements are carried out. Manipulating segments might be more useful in</span>
<span class="sd">order to add additional structure to a :class:`Universe` and provide instant</span>
<span class="sd">segment selectors for interactive work::</span>

<span class="sd">  u.selectAtoms(&quot;protein&quot;).set_segid(&quot;protein&quot;)</span>
<span class="sd">  u.selectAtoms(&quot;resname POPE or resname POPC&quot;).set_segid(&quot;lipids&quot;)</span>
<span class="sd">  u.selectAtoms(&quot;resname SOL&quot;).set_segid(&quot;water&quot;)</span>
<span class="sd">  u.selectAtoms(&quot;resname NA or resname CL&quot;).set_segid(&quot;ions&quot;)</span>

<span class="sd">  u.protein.numberOfResidues()</span>
<span class="sd">  water_oxygens = u.water.OW</span>

<span class="sd">The setter methods have the additional advantage that they can assign</span>
<span class="sd">lists. For instance, many MD codes number residues consecutively starting from</span>
<span class="sd">1. However, the original structure might be missing a few atoms at the</span>
<span class="sd">N-terminus. Let&#39;s say that the first residue is really residue 10. In order to</span>
<span class="sd">store the canonical residue IDs (&quot;resnum&quot;) one could the use ::</span>

<span class="sd">  import numpy as np</span>
<span class="sd">  protein = u.selectAtoms(&quot;protein&quot;).residues</span>
<span class="sd">  protein.set_resnum(np.array(protein.resnums()) + 9)</span>

<span class="sd">.. TODO: correct this example when resnums has become a property that returns a np array</span>
<span class="sd">..  protein = u.selectAtoms(&quot;protein&quot;).residues</span>
<span class="sd">..  protein.set_resnum(protein.resnums + 9)</span>

<span class="sd">One can then use ``protein.select(&quot;resnum 42&quot;)`` to select the residue that has</span>
<span class="sd">the canonical residue id 42 (instead of ``resid 33``).</span>

<span class="sd">One can also read the resids directly from  an original PDB file::</span>

<span class="sd">  orig = MDAnalysis.Universe(&quot;2jln.pdb&quot;)</span>
<span class="sd">  protein.set_resnum(orig.selectAtoms(&quot;protein&quot;).resids())</span>


<span class="sd">Working with Topologies</span>
<span class="sd">-----------------------</span>

<span class="sd">If the topology file given to the Universe had bonding information then this</span>
<span class="sd">will have been loaded into the Universe as :attr:`Universe.bonds`</span>
<span class="sd">:attr:`Universe.angles` :attr:`Universe.torsions` and :attr:`Universe.impropers`.</span>


<span class="sd">If your topology file does not have this information, it is still possible</span>
<span class="sd">to construct it based on the positions of the atoms and assumed vdw radii</span>
<span class="sd">for these atoms.  See :meth:`MDAnalysis.AtomGroup.guess_bonds` and</span>
<span class="sd">:func:`MDAnalysis.topology.core.guess_bonds` for details.</span>

<span class="sd">This Topology information is stored in :class:`MDAnalysis.topology.core.TopologyGroup`</span>
<span class="sd">objects.  These are designed to be analogous to the AtomGroup container for Atoms.</span>

<span class="sd">For examples working with a box of ethanol::</span>

<span class="sd">    &gt;&gt;&gt; import MDAnalysis as mda</span>
<span class="sd">    &gt;&gt;&gt; u = mda.Universe(&#39;ethanol.gro&#39;, guess_bonds=True)</span>
<span class="sd">    &gt;&gt;&gt; u.bonds</span>
<span class="sd">    &lt;TopologyGroup containing 11784 Bonds&gt;</span>
<span class="sd">    &gt;&gt;&gt; u.bonds.types()  # view available types</span>
<span class="sd">    [(&#39;O&#39;, &#39;H&#39;), (&#39;C&#39;, &#39;O&#39;), (&#39;C&#39;, &#39;H&#39;), (&#39;C&#39;, &#39;C&#39;)]</span>
<span class="sd">    &gt;&gt;&gt; u.bonds.selectBonds((&#39;C&#39;, &#39;O&#39;))  # return all C-O bonds from the group</span>
<span class="sd">    &lt;TopologyGroup containing 1473 Bonds&gt;</span>

<span class="sd">Bonds are categorised based on the types of atoms.  This is done in a way</span>
<span class="sd">so that type (a, b, c) is equivalent to (c, b, a) ie. bonds are reversible.</span>
<span class="sd">For example::</span>

<span class="sd">    &gt;&gt;&gt; u.angles.types()</span>
<span class="sd">    [(&#39;C&#39;, &#39;C&#39;, &#39;H&#39;),</span>
<span class="sd">     (&#39;H&#39;, &#39;C&#39;, &#39;H&#39;),</span>
<span class="sd">     (&#39;C&#39;, &#39;O&#39;, &#39;H&#39;),</span>
<span class="sd">     (&#39;C&#39;, &#39;C&#39;, &#39;O&#39;),</span>
<span class="sd">     (&#39;H&#39;, &#39;C&#39;, &#39;O&#39;)]</span>

<span class="sd">There is only C-C-H bonds and no H-C-C bonds.  Selection however is</span>
<span class="sd">aware that sometimes types are reversed::</span>

<span class="sd">    u.angles.selectBonds((&#39;H&#39;, &#39;C&#39;, &#39;C&#39;))  # note reversal of type</span>
<span class="sd">    &gt;&gt;&gt; &lt;TopologyGroup containing 7365 Angles&gt;</span>

<span class="sd">TopologyGroups can be combined and indexed::</span>

<span class="sd">    &gt;&gt;&gt; tg = u.angles.selectBonds((&#39;C&#39;, &#39;C&#39;, &#39;O&#39;)) + u.angles.selectBonds((&#39;C&#39;, &#39;O&#39;, &#39;H&#39;))</span>
<span class="sd">    &gt;&gt;&gt; tg.types()</span>
<span class="sd">    [(&#39;C&#39;, &#39;O&#39;, &#39;H&#39;), (&#39;C&#39;, &#39;C&#39;, &#39;O&#39;)]</span>
<span class="sd">    &gt;&gt;&gt; tg[:100]</span>
<span class="sd">    &lt;TopologyGroup containing 100 Angles&gt;</span>

<span class="sd">Finally, TopologyGroups are linked to some fast Cython calculation methods to</span>
<span class="sd">determine bond lengths and angle sizes::</span>

<span class="sd">    &gt;&gt;&gt; tg.angles()</span>
<span class="sd">    array([ 1.88042373,  1.95928987,  1.74770012, ...,  1.79306789,</span>
<span class="sd">            1.95522678,  1.88881045])</span>


<span class="sd">Combining objects: system building</span>
<span class="sd">----------------------------------</span>

<span class="sd">It is often convenient to combined multiple groups of atoms into a single</span>
<span class="sd">object. If they are contained in a single :class:`Universe` then the methods</span>
<span class="sd">described above (especially manipulating the segments) might be</span>
<span class="sd">useful. However, if the atoms reside in different universes, the :func:`Merge`</span>
<span class="sd">function can be used.</span>

<span class="sd">Merging</span>
<span class="sd">~~~~~~~</span>

<span class="sd">In the following example for :func:`Merge`, protein, ligand, and solvent were</span>
<span class="sd">externally prepared in three different PDB files. They are loaded into separate</span>
<span class="sd">:class:`Universe` objects (where they could be further manipulated,</span>
<span class="sd">e.g. renumbered, relabeled, rotated, ...) The :func:`Merge` command is used to</span>
<span class="sd">combine all of them together::</span>

<span class="sd">    import MDAnalysis</span>
<span class="sd">    u1 = MDAnalysis.Universe(&quot;protein.pdb&quot;)</span>
<span class="sd">    u2 = MDAnalysis.Universe(&quot;ligand.pdb&quot;)</span>
<span class="sd">    u3 = MDAnalysis.Universe(&quot;solvent.pdb&quot;)</span>
<span class="sd">    u = MDAnalysis.Merge(u1.selectAtoms(&quot;protein&quot;), u2.atoms, u3.atoms)</span>
<span class="sd">    u.atoms.write(&quot;system.pdb&quot;)</span>

<span class="sd">The complete system is then written out to a new PDB file.</span>

<span class="sd">Replicating</span>
<span class="sd">~~~~~~~~~~~</span>

<span class="sd">It is also possible to replicate a molecule to build a system with</span>
<span class="sd">multiple copies of the same molecule. In the example, we replicate an</span>
<span class="sd">AdK molecule and then translate and rotate the second copy::</span>

<span class="sd">    import MDAnalysis; from MDAnalysis.tests.datafiles import *</span>
<span class="sd">    u = MDAnalysis.Universe(PSF, DCD)</span>
<span class="sd">    p = u.selectAtoms(&quot;protein&quot;)</span>
<span class="sd">    m = MDAnalysis.Merge(p,p)</span>

<span class="sd">    # now renumber resids and segids for each copy</span>

<span class="sd">    # first copy of the protein (need to use atom indices because currently that&#39;s the only reliable property in the</span>
<span class="sd">    merged universe)</span>
<span class="sd">    p1 = m.selectAtoms(&quot;bynum 1:3341&quot;)</span>
<span class="sd">    # second copy</span>
<span class="sd">    p2 = m.selectAtoms(&quot;bynum 3342:6682&quot;)</span>

<span class="sd">    p1.set_segid(&quot;A&quot;)</span>
<span class="sd">    p2.set_segid(&quot;B&quot;)</span>
<span class="sd">    p2.residues.set_resid(p2.residues.resids() + p1.residues.resids()[-1])  # increment resids for p2 with the last</span>
<span class="sd">    resid from p1</span>

<span class="sd">    # you must regenerate the selections after modifying them (see notes in the docs!)</span>
<span class="sd">    # because the changed resids are not reflected in the selection (due to how residues are referenced internally)</span>
<span class="sd">    p1 = m.selectAtoms(&quot;segid A&quot;)       # or as before:  m.selectAtoms(&quot;bynum 1:3341&quot;)</span>
<span class="sd">    p2 = m.selectAtoms(&quot;segid B&quot;)</span>

<span class="sd">    # rotate and translate</span>
<span class="sd">    p2.rotateby(180, [0,0,1])</span>
<span class="sd">    p2.translate([50,0,0])</span>

<span class="sd">Note that we have to manually set the residue numbers (resids) and</span>
<span class="sd">segment identifies because :func:`Merge` simply concatenates the</span>
<span class="sd">existing atoms and only ensures that all data structures are contained</span>
<span class="sd">in the new merged universe.</span>


<span class="sd">Classes and functions</span>
<span class="sd">---------------------</span>

<span class="sd">.. autoclass:: Universe</span>
<span class="sd">   :members:</span>
<span class="sd">.. autofunction:: Merge</span>
<span class="sd">.. autoclass:: AtomGroup</span>
<span class="sd">   :members:</span>

<span class="sd">   .. attribute:: _atoms</span>

<span class="sd">      immutable list of references to the atoms :class:`Atom` in the</span>
<span class="sd">      group</span>

<span class="sd">   .. automethod:: _rebuild_caches</span>

<span class="sd">   .. automethod:: _clear_caches</span>

<span class="sd">   .. automethod:: _fill_cache</span>

<span class="sd">.. autoclass:: Atom</span>
<span class="sd">   :members:</span>

<span class="sd">   .. attribute::     number</span>

<span class="sd">      atom number</span>

<span class="sd">   .. attribute::     segid</span>

<span class="sd">      name of the segment</span>

<span class="sd">   .. attribute::     resid</span>

<span class="sd">      residue number</span>

<span class="sd">   .. attribute::     resnum</span>

<span class="sd">      canonical residue number as, for instance, used in the original</span>
<span class="sd">      PDB file</span>

<span class="sd">      .. versionadded:: 0.7.4</span>

<span class="sd">   .. attribute::        resname</span>

<span class="sd">      residue name</span>

<span class="sd">   .. attribute::        residue</span>

<span class="sd">      :class:`Residue` object containing the atoms</span>

<span class="sd">   .. attribute::     id</span>

<span class="sd">      atom number inside the residue</span>

<span class="sd">   .. attribute::       name</span>

<span class="sd">      string, short name</span>

<span class="sd">   .. attribute::        type</span>

<span class="sd">      string or number (from force field), describing the atom type;</span>
<span class="sd">      stored as a string.</span>

<span class="sd">      .. versionchanged:: 0.7.6</span>
<span class="sd">         The :attr:`Atom.type` attribute is always stored as a string.</span>

<span class="sd">   .. attribute::        mass</span>

<span class="sd">      float, in `atomic mass units`_ (u)</span>

<span class="sd">   .. attribute::        charge</span>

<span class="sd">      float, in `electron charges`_ (*e*)</span>

<span class="sd">   .. attribute::        radius</span>

<span class="sd">      Born-radius for electrostatic calculations. (Only if read from a</span>
<span class="sd">      PQR file with the</span>
<span class="sd">      :class:`~MDAnalysis.coordinates.PQR.PQRReader`.)</span>

<span class="sd">   .. attribute::        altLoc</span>

<span class="sd">      Alternate location indicator (as used in `ATOM_` records in PDB</span>
<span class="sd">      files)</span>

<span class="sd">      .. versionadded:: 0.9.0</span>

<span class="sd">   .. attribute:: bonds</span>

<span class="sd">      List of :class:`~MDAnalysis.topogology.core.Bond` instances that</span>
<span class="sd">      contains all the bonds that this atom participates in.</span>

<span class="sd">      .. versionadded:: 0.8.1</span>

<span class="sd">   .. attribute:: angles</span>

<span class="sd">      List of :class:`~MDAnalysis.topogology.core.Angle` instances</span>
<span class="sd">      that contains all the angles that this atom participates in.</span>

<span class="sd">      .. versionadded:: 0.8.1</span>

<span class="sd">   .. attribute:: torsions</span>

<span class="sd">      List of :class:`~MDAnalysis.topogology.core.Torsion` instances</span>
<span class="sd">      that contains all the dihedral torsions that this atom</span>
<span class="sd">      participates in.</span>

<span class="sd">      .. versionadded:: 0.8.1</span>

<span class="sd">.. autoclass:: Residue</span>
<span class="sd">   :members:</span>
<span class="sd">.. autoclass:: ResidueGroup</span>
<span class="sd">   :members:</span>
<span class="sd">.. autoclass:: Segment</span>
<span class="sd">   :members:</span>
<span class="sd">.. autoclass:: SegmentGroup</span>
<span class="sd">   :members:</span>

<span class="sd">.. autofunction:: asUniverse</span>
<span class="sd">.. autoexception:: SelectionError</span>
<span class="sd">   :no-members:</span>
<span class="sd">.. autoexception:: SelectionWarning</span>
<span class="sd">   :no-members:</span>
<span class="sd">.. autoexception:: NoDataError</span>
<span class="sd">   :no-members:</span>

<span class="sd">.. _atomic mass units: http://physics.nist.gov/cgi-bin/cuu/Value?u</span>
<span class="sd">.. _electron charges: http://physics.nist.gov/cgi-bin/cuu/Value?e</span>
<span class="sd">.. _ATOM: http://www.wwpdb.org/documentation/format23/sect9.html#ATOM</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="c"># Global imports</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">eig</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os.path</span>

<span class="c"># Local imports</span>
<span class="kn">import</span> <span class="nn">MDAnalysis</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">SelectionError</span><span class="p">,</span> <span class="n">NoDataError</span><span class="p">,</span> <span class="n">SelectionWarning</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="n">cached</span>
<span class="kn">from</span> <span class="nn">.transformations</span> <span class="kn">import</span> <span class="n">rotation_matrix</span><span class="p">,</span> <span class="n">vecangle</span><span class="p">,</span> <span class="n">rotaxis</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s">&quot;MDAnalysis.core.AtomGroup&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="Atom"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Atom">[docs]</a><span class="k">class</span> <span class="nc">Atom</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class representing a single atom.</span>

<span class="sd">    :class:`Atom` is the basic building block of all larger data</span>
<span class="sd">    structures in MDAnalysis, in particular of the</span>
<span class="sd">    :class:`AtomGroup`.</span>

<span class="sd">    An :class:`Atom` is typically generated by a :ref:`topology reader</span>
<span class="sd">    &lt;Supported topology formats&gt;` from :mod:`MDAnalysis.topology`.</span>

<span class="sd">    For performance reasons, only a predefined number of attributes</span>
<span class="sd">    are included (and thus it is not possible to add attributes &quot;on</span>
<span class="sd">    the fly&quot;; they have to be included in the class definition).</span>

<span class="sd">    .. versionchanged 0.9.0</span>
<span class="sd">       Added fragment managed property.</span>
<span class="sd">       Changed bonds angles torsions impropers to be a managed property</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="s">&quot;id&quot;</span><span class="p">,</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;type&quot;</span><span class="p">,</span> <span class="s">&quot;resname&quot;</span><span class="p">,</span> <span class="s">&quot;resid&quot;</span><span class="p">,</span> <span class="s">&quot;segid&quot;</span><span class="p">,</span>
        <span class="s">&quot;mass&quot;</span><span class="p">,</span> <span class="s">&quot;charge&quot;</span><span class="p">,</span> <span class="s">&quot;residue&quot;</span><span class="p">,</span> <span class="s">&quot;segment&quot;</span><span class="p">,</span>
        <span class="s">&quot;__universe&quot;</span><span class="p">,</span>
        <span class="s">&quot;radius&quot;</span><span class="p">,</span> <span class="s">&quot;bfactor&quot;</span><span class="p">,</span> <span class="s">&quot;resnum&quot;</span><span class="p">,</span> <span class="s">&quot;serial&quot;</span><span class="p">,</span> <span class="s">&quot;altLoc&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">resname</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">segid</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span>
                 <span class="n">residue</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">segment</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bfactor</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">resnum</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">serial</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">altLoc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">universe</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">altLoc</span> <span class="o">=</span> <span class="n">altLoc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span>  <span class="c"># always a string (needed for selections)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resname</span> <span class="o">=</span> <span class="n">resname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resid</span> <span class="o">=</span> <span class="n">resid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resnum</span> <span class="o">=</span> <span class="n">resnum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">residue</span> <span class="o">=</span> <span class="n">residue</span>  <span class="c"># typically patched in later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segid</span> <span class="o">=</span> <span class="n">segid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segment</span> <span class="o">=</span> <span class="n">segment</span>  <span class="c"># typically patched in later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mass</span> <span class="o">=</span> <span class="n">mass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charge</span> <span class="o">=</span> <span class="n">charge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bfactor</span> <span class="o">=</span> <span class="n">bfactor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">serial</span> <span class="o">=</span> <span class="n">serial</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__universe</span> <span class="o">=</span> <span class="n">universe</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s">&quot;&lt;Atom {idx}: {name} of type {t} of resname {rname}, &quot;</span>
                <span class="s">&quot;resid {rid} and segid {sid}{altloc}&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">idx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                    <span class="n">rname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="n">rid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="n">sid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">segid</span><span class="p">,</span>
                    <span class="n">altloc</span><span class="o">=</span><span class="s">&quot;&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">altLoc</span>
                    <span class="k">else</span> <span class="s">&quot; and altloc {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">altLoc</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__cmp__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">cmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">number</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Atom</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AtomGroup</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Can only concatenate Atoms (not &quot;{0}&quot;)&#39;</span>
                            <span class="s">&#39; to AtomGroup&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">AtomGroup</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AtomGroup</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">_atoms</span><span class="p">)</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="Atom.pos"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Atom.pos">[docs]</a>    <span class="k">def</span> <span class="nf">pos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;coordinates of the atom</span>

<span class="sd">        Get the current cartesian coordinates of the atom (read-only).</span>

<span class="sd">        .. deprecated:: 0.8</span>
<span class="sd">           use :attr:`position`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;coordinates of the atom</span>

<span class="sd">        Get the current cartesian coordinates of the atom.</span>

<span class="sd">        :Returns: a (3,) shape numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">]</span>  <span class="c"># internal numbering starts at 0</span>

    <span class="nd">@position.setter</span>
<div class="viewcode-block" id="Atom.position"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Atom.position">[docs]</a>    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the current cartesian coordinates of the atom.</span>
<span class="sd">        @param coords: a 1x3 numpy array of {x,y,z} coordinates, or optionally</span>
<span class="sd">            a single scalar if you should want to set all coordinates to the same value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">_pos</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">coords</span>  <span class="c"># internal numbering starts at 0</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">velocity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Current velocity of the atom.</span>

<span class="sd">        :Returns: a (3,) shape numpy array</span>

<span class="sd">        A :exc:`~MDAnalysis.NoDataError` is raised if the trajectory</span>
<span class="sd">        does not contain velocities.</span>

<span class="sd">        .. versionadded:: 0.7.5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># TODO: Remove error checking here (and all similar below)</span>
        <span class="c"># and add to Timestep</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">_velocities</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">],</span>
                               <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s">&quot;Timestep does not contain velocities&quot;</span><span class="p">)</span>

    <span class="nd">@velocity.setter</span>
<div class="viewcode-block" id="Atom.velocity"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Atom.velocity">[docs]</a>    <span class="k">def</span> <span class="nf">velocity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the current velocity of the atom.</span>

<span class="sd">        A :exc:`~MDAnalysis.NoDataError` is raised if the trajectory</span>
<span class="sd">        does not contain velocities.</span>

<span class="sd">        .. versionadded:: 0.9.2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">_velocities</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s">&quot;Timestep does not contain velocities&quot;</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">force</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Current force of the atom.</span>

<span class="sd">        :Returns: a (3,) shape numpy array</span>

<span class="sd">        A :exc:`~MDAnalysis.NoDataError` is raised if the trajectory</span>
<span class="sd">        does not contain velocities.</span>

<span class="sd">        .. versionadded:: 0.9.2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">_forces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s">&quot;Timestep does not contain forces&quot;</span><span class="p">)</span>

    <span class="nd">@force.setter</span>
<div class="viewcode-block" id="Atom.force"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Atom.force">[docs]</a>    <span class="k">def</span> <span class="nf">force</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the current force of the atom.</span>

<span class="sd">        .. versionadded:: 0.9.2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">_forces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s">&quot;Timestep does not contain forces&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Atom.centroid"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Atom.centroid">[docs]</a>    <span class="k">def</span> <span class="nf">centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The centroid of an atom is its position, :attr:`Atom.pos`.&quot;&quot;&quot;</span>
        <span class="c"># centroid exists for compatibility with AtomGroup</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;a pointer back to the Universe&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__universe</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__universe</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s">&quot;Atom {0} is not assigned to a Universe&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">))</span>

    <span class="nd">@universe.setter</span>
<div class="viewcode-block" id="Atom.universe"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Atom.universe">[docs]</a>    <span class="k">def</span> <span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">universe</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__universe</span> <span class="o">=</span> <span class="n">universe</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Atom.bonded_atoms"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Atom.bonded_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">bonded_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An AtomGroup of the Atoms that this Atom is bonded to.</span>

<span class="sd">        .. versionadded:: 0.9</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AtomGroup</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">partner</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">])</span>

    <span class="c"># The following look up a dictionary stored in the Universe.</span>
    <span class="c"># These dictionaries are lazily built</span></div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Atom.fragment"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Atom.fragment">[docs]</a>    <span class="k">def</span> <span class="nf">fragment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The fragment that this Atom is part of</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_fragmentDict</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Atom.bonds"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Atom.bonds">[docs]</a>    <span class="k">def</span> <span class="nf">bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A list of the bonds that this Atom is in</span>

<span class="sd">        .. versionchanged:: 0.9.0</span>
<span class="sd">           Changed to managed property</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..topology.core</span> <span class="kn">import</span> <span class="n">TopologyGroup</span>

        <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_bondDict</span><span class="p">[</span><span class="bp">self</span><span class="p">])</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Atom.angles"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Atom.angles">[docs]</a>    <span class="k">def</span> <span class="nf">angles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A list of the angles that this Atom is in</span>

<span class="sd">        .. versionchanged:: 0.9.0</span>
<span class="sd">           Changed to managed property</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..topology.core</span> <span class="kn">import</span> <span class="n">TopologyGroup</span>

        <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_angleDict</span><span class="p">[</span><span class="bp">self</span><span class="p">])</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Atom.torsions"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Atom.torsions">[docs]</a>    <span class="k">def</span> <span class="nf">torsions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A list of the torsions/dihedrals that this Atom is in</span>

<span class="sd">        .. versionchanged:: 0.9.0</span>
<span class="sd">           Changed to managed property</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..topology.core</span> <span class="kn">import</span> <span class="n">TopologyGroup</span>

        <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_torsionDict</span><span class="p">[</span><span class="bp">self</span><span class="p">])</span>
</div>
    <span class="n">dihedrals</span> <span class="o">=</span> <span class="n">torsions</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="Atom.impropers"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Atom.impropers">[docs]</a>    <span class="k">def</span> <span class="nf">impropers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A list of the improper torsions that this Atom is in</span>

<span class="sd">        .. versionchanged:: 0.9.0</span>
<span class="sd">           Changed to managed property</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..topology.core</span> <span class="kn">import</span> <span class="n">TopologyGroup</span>

        <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_improperDict</span><span class="p">[</span><span class="bp">self</span><span class="p">])</span>

</div></div>
<div class="viewcode-block" id="AtomGroup"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup">[docs]</a><span class="k">class</span> <span class="nc">AtomGroup</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A group of atoms.</span>

<span class="sd">      ag = universe.selectAtoms(atom-list)</span>

<span class="sd">    The AtomGroup contains a list of atoms; typically, a AtomGroup is generated</span>
<span class="sd">    from a selection. It is build from any list-like collection of</span>
<span class="sd">    :class:`Atom` instances. It is also possible to create an empty AtomGroup</span>
<span class="sd">    from an empty list.</span>

<span class="sd">    An AtomGroup can be indexed and sliced like a list::</span>

<span class="sd">       ag[0], ag[-1]</span>

<span class="sd">    will return the first and the last :class:`Atom` in the group</span>
<span class="sd">    whereas the slice ::</span>

<span class="sd">       ag[0:6:2]</span>

<span class="sd">    returns every second element, corresponding to indices 0, 2, and 4.</span>

<span class="sd">    It also supports &quot;advanced slicing&quot; when the argument is a</span>
<span class="sd">    :class:`numpy.ndarray` or a :class:`list`::</span>

<span class="sd">       aslice = [0, 3, -1, 10, 3]</span>
<span class="sd">       ag[aslice]</span>

<span class="sd">    will return a new :class:`AtomGroup` containing (ag[0], ag[3], ag[-1],</span>
<span class="sd">    ag[10], ag[3]).</span>

<span class="sd">    .. Note::</span>

<span class="sd">       AtomGroups originating from a selection are sorted and</span>
<span class="sd">       duplicate elements are removed. This is not true for AtomGroups</span>
<span class="sd">       produced by slicing. Thus slicing can be used when the order of</span>
<span class="sd">       atoms is crucial (for instance, in order to define angles or</span>
<span class="sd">       dihedrals).</span>

<span class="sd">    Atoms can also be accessed in a Pythonic fashion by using the atom name as</span>
<span class="sd">    an attribute. For instance, ::</span>

<span class="sd">       ag.CA</span>

<span class="sd">    will provide a :class:`AtomGroup` of all CA atoms in the</span>
<span class="sd">    group. These *instant selector* attributes are auto-generated for</span>
<span class="sd">    each atom name encountered in the group.</span>

<span class="sd">    .. Note::</span>

<span class="sd">       The name-attribute instant selector access to atoms is mainly</span>
<span class="sd">       meant for quick interactive work. Thus it either returns a</span>
<span class="sd">       single :class:`Atom` if there is only one matching atom, *or* a</span>
<span class="sd">       new :class:`AtomGroup` for multiple matches.  This makes it</span>
<span class="sd">       difficult to use the feature consistently in scripts but it is</span>
<span class="sd">       much better for interactive work.</span>

<span class="sd">    .. rubric:: References for analysis methods</span>

<span class="sd">    .. [Dima2004] Dima, R. I., &amp; Thirumalai, D. (2004). Asymmetry in the</span>
<span class="sd">                  shapes of folded and denatured states of proteins. *J</span>
<span class="sd">                  Phys Chem B*, 108(21),</span>
<span class="sd">                  6564-6570. doi:`10.1021/jp037128y`_</span>

<span class="sd">    .. _10.1021/jp037128y: http://dx.doi.org/10.1021/jp037128y</span>


<span class="sd">    .. versionchanged:: 0.7.6</span>
<span class="sd">       An empty AtomGroup can be created and no longer raises a</span>
<span class="sd">       :exc:`NoDataError`.</span>
<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       The size at which cache is used for atom lookup is now stored as variable</span>
<span class="sd">       _atomcache_size within the class.</span>
<span class="sd">       Added fragments manged property. Is a lazily built, cached entry, similar to residues.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># for generalized __getitem__ __iter__ and __len__</span>
    <span class="c"># (override _containername for ResidueGroup and SegmentGroup)</span>
    <span class="n">_containername</span> <span class="o">=</span> <span class="s">&quot;_atoms&quot;</span>
    <span class="n">_atomcache_size</span> <span class="o">=</span> <span class="mi">10000</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># __atoms property is effectively readonly</span>
            <span class="c"># check that atoms is indexable:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__atoms</span> <span class="o">=</span> <span class="n">atoms</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__atoms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
            <span class="c"># sanity check</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Atom</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;atoms must be a Atom or a list of Atoms.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># empty AtomGroup</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__atoms</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># managed timestep object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ts</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># caches:</span>
        <span class="c"># - built on the fly when they are needed</span>
        <span class="c"># - delete entry to invalidate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c"># for generalized __getitem__ (override _containername for ResidueGroup and SegmentGroup)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_container</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_containername</span><span class="p">)</span>
        <span class="c"># Define the Class that gets returned by getitem</span>
        <span class="c"># Override this where return Class differs from Self (ie slicing Residue)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span>

<div class="viewcode-block" id="AtomGroup._rebuild_caches"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup._rebuild_caches">[docs]</a>    <span class="k">def</span> <span class="nf">_rebuild_caches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rebuild all AtomGroup caches.</span>

<span class="sd">        A number of lists and attributes are cached. These caches are lazily</span>
<span class="sd">        built the first time they are needed. When editing the topology it</span>
<span class="sd">        might happen that not all caches were synced properly (even though that</span>
<span class="sd">        this is supposed to happen eventually). In this case the user can</span>
<span class="sd">        manually force a complete cache rebuild.</span>

<span class="sd">        Currently the following caches are used:</span>

<span class="sd">        * atoms (for &quot;in&quot; lookup); cache is only built for large systems with</span>
<span class="sd">          &gt; 10,000 atoms</span>
<span class="sd">        * indices (:meth:`AtomGroup.indices`)</span>
<span class="sd">        * masses (:meth:`AtomGroup.masses`)</span>
<span class="sd">        * residues (:attr:`AtomGroup.residues`)</span>
<span class="sd">        * segments (:attr:`AtomGroup.segments`)</span>
<span class="sd">        * bonds (:attr:`AtomGroup.bonds`)</span>
<span class="sd">        * angles (:attr:`AtomGroup.angles`)</span>
<span class="sd">        * torsions (:attr:`AtomGroup.torsions`)</span>
<span class="sd">        * improper torsions (:attr:`AtomGroup.impropers`)</span>

<span class="sd">        .. SeeAlso:: :meth:`_clear_caches`</span>

<span class="sd">        .. versionadded:: 0.7.5</span>
<span class="sd">        .. versionchanged:: 0.9.0</span>
<span class="sd">           Added bonds/angles/torsions/impropers to rebuild.</span>
<span class="sd">           Reworked how things are rebuilt to avoid code duplication.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># If the number of atoms is very large, create a dictionary cache for lookup</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atomcache_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;atoms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(((</span><span class="n">x</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__atoms</span><span class="p">))</span>

        <span class="c"># Delete preexisting cache if exists</span>
        <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> \
                <span class="p">[</span>
                    <span class="s">&#39;indices&#39;</span><span class="p">,</span> <span class="s">&#39;residues&#39;</span><span class="p">,</span> <span class="s">&#39;segments&#39;</span><span class="p">,</span> <span class="s">&#39;masses&#39;</span><span class="p">,</span>
                    <span class="s">&#39;bonds&#39;</span><span class="p">,</span> <span class="s">&#39;angles&#39;</span><span class="p">,</span> <span class="s">&#39;torsions&#39;</span><span class="p">,</span> <span class="s">&#39;impropers&#39;</span>
                <span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">att</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="c"># Call each in turn to force them to build into cache</span>
        <span class="c"># indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;indices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span>
        <span class="c"># residue instances</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;residues&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">residues</span>
        <span class="c"># segment instances</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;segments&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span>
        <span class="c"># masses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;masses&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">()</span>
        <span class="c"># bonds angles torsions impropers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;bonds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;angles&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;torsions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">torsions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;impropers&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">impropers</span>
</div>
<div class="viewcode-block" id="AtomGroup._clear_caches"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup._clear_caches">[docs]</a>    <span class="k">def</span> <span class="nf">_clear_caches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear cache for all *args*.</span>

<span class="sd">        If no args are provided, all caches are cleared.</span>

<span class="sd">        .. SeeAlso:: :meth:`_rebuild_caches`</span>

<span class="sd">        .. versionadded:: 0.8</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>
</div>
<div class="viewcode-block" id="AtomGroup._fill_cache"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup._fill_cache">[docs]</a>    <span class="k">def</span> <span class="nf">_fill_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Populate _cache[name] with value.</span>

<span class="sd">        .. versionadded:: 0.8</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c"># AtomGroup.atoms is guaranteed to be a AtomGroup, too; keeps a consistent API</span>
    <span class="c"># between AtomGroup, Residue, ResidueGroup, Segment; access the list as</span>
    <span class="c"># _atoms (although atoms supports all list-like operations, too).</span></div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AtomGroup.atoms"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.atoms">[docs]</a>    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:class:`AtomGroup` of all atoms in this group.</span>

<span class="sd">        If this is a :class:`AtomGroup` then it returns itself. Otherwise, it</span>
<span class="sd">        will return a new :class:`AtomGroup` based on all :class:`Atom`</span>
<span class="sd">        instances contained.</span>

<span class="sd">        Apply `:func:`list` to :attr:`atoms` or use :attr:`_atoms` if you</span>
<span class="sd">        really only need a list of individual :class:`Atom` instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Cannot just return self because fails with inheritance from AtomGroup</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">AtomGroup</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">AtomGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__atoms</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AtomGroup._atoms"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup._atoms">[docs]</a>    <span class="k">def</span> <span class="nf">_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;a immutable list of references to the atoms in the group&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__atoms</span>

    <span class="c"># Universe pointer is important for Selections to work on groups</span></div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AtomGroup.universe"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.universe">[docs]</a>    <span class="k">def</span> <span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The universe to which the atoms belong (read-only).&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">universe</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of atoms in the group&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_container</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_container</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return element (index) or group (slicing).</span>

<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           :class:`ResidueGroup` and :class:`SegmentGroup`:</span>
<span class="sd">           return groups themselves and allow advanced slicing</span>
<span class="sd">        .. versionchanged:: 0.9.0</span>
<span class="sd">           This method now used by all subclasses.  These subclasses override</span>
<span class="sd">           :attr:`_cls` to define the returned class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">container</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_container</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cls</span>

        <span class="c"># consistent with the way list indexing/slicing behaves:</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">))</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">container</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="nb">slice</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">container</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="c"># advanced slicing, requires array or list</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">([</span><span class="n">container</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">item</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_named_atom</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Cannot slice with type: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_named_atom</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">SelectionError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;&#39;{0}&#39; object has no attribute &#39;{1}&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_named_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get all atoms with name *name* in the current AtomGroup.</span>

<span class="sd">        For more than one atom it returns a list of :class:`Atom`</span>
<span class="sd">        instance. A single :class:`Atom` is returned just as such. If</span>
<span class="sd">        no atoms are found, a :exc:`SelectionError` is raised.</span>

<span class="sd">        .. versionadded:: 0.9.2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># There can be more than one atom with the same name</span>
        <span class="n">atomlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span> <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atomlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span><span class="s">&quot;No atoms with name &#39;{0}&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">atomlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">atomlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># XXX: keep this, makes more sense for names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AtomGroup</span><span class="p">(</span><span class="n">atomlist</span><span class="p">)</span>  <span class="c"># XXX: but inconsistent (see residues and Issue 47)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c"># If the number of atoms is very large, create a dictionary cache for lookup</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atomcache_size</span> <span class="ow">and</span> <span class="ow">not</span> <span class="s">&#39;atoms&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;atoms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(((</span><span class="n">x</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__atoms</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;atoms&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Atom</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AtomGroup</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Can only concatenate AtomGroup (not &quot;{0}&quot;) to&#39;</span>
                            <span class="s">&#39; AtomGroup&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AtomGroup</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">AtomGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">_atoms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AtomGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">+</span> <span class="p">[</span><span class="n">other</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&lt;AtomGroup with {natoms} atoms&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">natoms</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<div class="viewcode-block" id="AtomGroup.numberOfAtoms"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.numberOfAtoms">[docs]</a>    <span class="k">def</span> <span class="nf">numberOfAtoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total number of atoms in the group&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.numberOfResidues"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.numberOfResidues">[docs]</a>    <span class="k">def</span> <span class="nf">numberOfResidues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total number of residues in the group&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.numberOfSegments"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.numberOfSegments">[docs]</a>    <span class="k">def</span> <span class="nf">numberOfSegments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total number of segments in the group&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span>
</div>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;indices&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="AtomGroup.indices"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.indices">[docs]</a>    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Array of all :attr:`Atom.number` in the group.</span>

<span class="sd">        These indices are 0-based and can be used to directly index</span>
<span class="sd">        :attr:`Universe.atoms` or the coordinate array</span>
<span class="sd">        :attr:`MDAnalysis.coordinates.base.Timestep._pos`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">number</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="AtomGroup.names"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.names">[docs]</a>    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of atom names.</span>

<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Returns a :class:`numpy.ndarray`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="AtomGroup.types"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.types">[docs]</a>    <span class="k">def</span> <span class="nf">types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an array of atom types.</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">])</span>
</div>
    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;fragments&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="AtomGroup.fragments"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.fragments">[docs]</a>    <span class="k">def</span> <span class="nf">fragments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read-only list of fragments.</span>

<span class="sd">        Contains all fragments that any Atom in this AtomGroup is part of, the contents of</span>
<span class="sd">        the fragments may extend beyond the contents of this AtomGroup.</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">fragment</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">))</span>
</div>
    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;residues&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="AtomGroup.residues"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.residues">[docs]</a>    <span class="k">def</span> <span class="nf">residues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read-only list of :class:`Residue` objects.</span>

<span class="sd">        A :class:`ResidueGroup` of all residues that contain atoms in</span>
<span class="sd">        this group.</span>

<span class="sd">        .. versionchanged:: 0.9.0</span>
<span class="sd">           Now returns strictly a ResidueGroup of the unique Residues that Atoms in this group</span>
<span class="sd">           belong to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">seen_residues</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">current_residue</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">residue</span> <span class="o">!=</span> <span class="n">current_residue</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">atom</span><span class="o">.</span><span class="n">residue</span> <span class="ow">in</span> <span class="n">seen_residues</span><span class="p">:</span>
                <span class="n">residues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="p">)</span>
                <span class="n">seen_residues</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="p">)</span>
            <span class="n">current_residue</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">residue</span>
        <span class="k">return</span> <span class="n">ResidueGroup</span><span class="p">(</span><span class="n">residues</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.resids"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.resids">[docs]</a>    <span class="k">def</span> <span class="nf">resids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of residue numbers.</span>

<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Returns a :class:`numpy.ndarray`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="AtomGroup.resnames"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.resnames">[docs]</a>    <span class="k">def</span> <span class="nf">resnames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of residue names.</span>

<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Returns a :class:`numpy.ndarray`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="AtomGroup.resnums"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.resnums">[docs]</a>    <span class="k">def</span> <span class="nf">resnums</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of canonical residue numbers.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Returns a :class:`numpy.ndarray`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">resnum</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="AtomGroup.sequence"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.sequence">[docs]</a>    <span class="k">def</span> <span class="nf">sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the amino acid sequence.</span>

<span class="sd">        The format of the sequence is selected with the keyword *format*:</span>

<span class="sd">        ============== ============================================</span>
<span class="sd">        *format*       description</span>
<span class="sd">        ============== ============================================</span>
<span class="sd">        &#39;SeqRecord&#39;    :class:`Bio.SeqRecord.SeqRecord` (default)</span>
<span class="sd">        &#39;Seq&#39;          :class:`Bio.Seq.Seq`</span>
<span class="sd">        &#39;string&#39;       string</span>
<span class="sd">        ============== ============================================</span>

<span class="sd">        The sequence is returned by default (keyword ``format = &#39;SeqRecord&#39;``)</span>
<span class="sd">        as a :class:`Bio.SeqRecord.SeqRecord` instance, which can then be</span>
<span class="sd">        further processed. In this case, all keyword arguments (such as the</span>
<span class="sd">        *id* string or the *name* or the *description*) are directly passed to</span>
<span class="sd">        :class:`Bio.SeqRecord.SeqRecord`.</span>

<span class="sd">        If the keyword *format* is set to ``&#39;Seq&#39;``, all *kwargs* are ignored and</span>
<span class="sd">        a :class:`Bio.Seq.Seq` instance is returned. The difference to the</span>
<span class="sd">        record is that the record also contains metadata and can be directly</span>
<span class="sd">        used as an input for other functions in :mod:`Bio`.</span>

<span class="sd">        If the keyword *format* is set to ``&#39;string&#39;``, all *kwargs* are ignored</span>
<span class="sd">        and a Python string is returned.</span>

<span class="sd">        .. rubric:: Example: Write FASTA file</span>

<span class="sd">        Use :func:`Bio.SeqIO.write`, which takes sequence records::</span>

<span class="sd">           import Bio.SeqIO</span>

<span class="sd">           # get the sequence record of a protein component of a Universe</span>
<span class="sd">           protein = u.selectAtoms(&quot;protein&quot;)</span>
<span class="sd">           record = protein.sequence(id=&quot;myseq1&quot;, name=&quot;myprotein&quot;)</span>

<span class="sd">           Bio.SeqIO.write(record, &quot;single.fasta&quot;, &quot;fasta&quot;)</span>

<span class="sd">        A FASTA file with multiple entries can be written with ::</span>

<span class="sd">           Bio.SeqIO.write([record1, record2, ...], &quot;multi.fasta&quot;, &quot;fasta&quot;)</span>

<span class="sd">        :Keywords:</span>
<span class="sd">            *format*</span>
<span class="sd">                - ``&quot;string&quot;``: return sequence as a string of 1-letter codes</span>
<span class="sd">                - ``&quot;Seq&quot;``: return a :class:`Bio.Seq.Seq` instance</span>
<span class="sd">                - ``&quot;SeqRecord&quot;``: return a :class:`Bio.SeqRecord.SeqRecord`</span>
<span class="sd">                  instance</span>
<span class="sd">                Default is ``&quot;SeqRecord&quot;``</span>
<span class="sd">             *id*</span>
<span class="sd">                Sequence ID for SeqRecord (should be different for different</span>
<span class="sd">                sequences)</span>
<span class="sd">             *name*</span>
<span class="sd">                Name of the protein.</span>
<span class="sd">             *description*</span>
<span class="sd">                Short description of the sequence.</span>
<span class="sd">             *kwargs*</span>
<span class="sd">                Any other keyword arguments that are understood by</span>
<span class="sd">                :class:`Bio.SeqRecord.SeqRecord`.</span>

<span class="sd">        :Raises: :exc:`ValueError` if a residue name cannot be converted to a</span>
<span class="sd">                 1-letter IUPAC protein amino acid code; make sure to only</span>
<span class="sd">                 select protein residues. Raises :exc:`TypeError` if an unknown</span>
<span class="sd">                 *format* is selected.</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">Bio.Seq</span>
        <span class="kn">import</span> <span class="nn">Bio.SeqRecord</span>
        <span class="kn">import</span> <span class="nn">Bio.Alphabet</span>
        <span class="n">formats</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;string&#39;</span><span class="p">,</span> <span class="s">&#39;Seq&#39;</span><span class="p">,</span> <span class="s">&#39;SeqRecord&#39;</span><span class="p">)</span>

        <span class="n">format</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;format&quot;</span><span class="p">,</span> <span class="s">&quot;SeqRecord&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">formats</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Unknown format=&#39;{0}&#39;: must be one of: {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">format</span><span class="p">,</span> <span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">formats</span><span class="p">)))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sequence</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">util</span><span class="o">.</span><span class="n">convert_aa_code</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">resnames</span><span class="p">()])</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;AtomGroup contains a residue name &#39;{0}&#39; that &quot;</span>
                             <span class="s">&quot;does not have a IUPAC protein 1-letter &quot;</span>
                             <span class="s">&quot;character&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">message</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">format</span> <span class="o">==</span> <span class="s">&quot;string&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sequence</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">Bio</span><span class="o">.</span><span class="n">Seq</span><span class="o">.</span><span class="n">Seq</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="n">Bio</span><span class="o">.</span><span class="n">Alphabet</span><span class="o">.</span><span class="n">IUPAC</span><span class="o">.</span><span class="n">protein</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">format</span> <span class="o">==</span> <span class="s">&quot;Seq&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">seq</span>
        <span class="k">return</span> <span class="n">Bio</span><span class="o">.</span><span class="n">SeqRecord</span><span class="o">.</span><span class="n">SeqRecord</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;segments&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="AtomGroup.segments"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.segments">[docs]</a>    <span class="k">def</span> <span class="nf">segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read-only list of :class:`Segment` objects.</span>

<span class="sd">        A :class:`SegmentGroup` of all segments that contain atoms in this group.</span>

<span class="sd">        .. versionchanged:: 0.9.0</span>
<span class="sd">           Now strictly returns a :class:`SegmentGroup` of a set of</span>
<span class="sd">           the :class:`Segment` instances from this :class:`AtomGroup`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">seen_segments</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">current_segment</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">segment</span> <span class="o">!=</span> <span class="n">current_segment</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">atom</span><span class="o">.</span><span class="n">segment</span> <span class="ow">in</span> <span class="n">seen_segments</span><span class="p">:</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">segment</span><span class="p">)</span>
                <span class="n">seen_segments</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">segment</span><span class="p">)</span>
            <span class="n">current_segment</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">segment</span>
        <span class="k">return</span> <span class="n">SegmentGroup</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.segids"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.segids">[docs]</a>    <span class="k">def</span> <span class="nf">segids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of segment ids (=segment names).</span>

<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Returns a :class:`numpy.ndarray`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="AtomGroup.guess_bonds"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.guess_bonds">[docs]</a>    <span class="k">def</span> <span class="nf">guess_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vdwradii</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Guess all the bonds that exist within this AtomGroup and add to Universe.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *vdwradii*</span>
<span class="sd">            Pass a dict relating atom types to vdwradii.</span>

<span class="sd">        .. SeeAlso::</span>
<span class="sd">           :func:`MDAnalysis.topology.core.guess_bonds`</span>

<span class="sd">        .. versionadded:: 0.10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..topology.core</span> <span class="kn">import</span> <span class="p">(</span><span class="n">guess_bonds</span><span class="p">,</span> <span class="n">Bond</span><span class="p">,</span>
                                     <span class="n">guess_angles</span><span class="p">,</span> <span class="n">Angle</span><span class="p">,</span>
                                     <span class="n">guess_torsions</span><span class="p">,</span> <span class="n">Torsion</span><span class="p">,</span>
                                     <span class="n">TopologyGroup</span><span class="p">)</span>

        <span class="n">b</span> <span class="o">=</span> <span class="n">guess_bonds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">vdwradii</span><span class="o">=</span><span class="n">vdwradii</span><span class="p">)</span>

        <span class="c"># eliminate bonds that already exist</span>
        <span class="c"># have to compare indices not bond objects as same bond which is True and False</span>
        <span class="c"># will hash differently.</span>
        <span class="n">existing_bonds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">to_indices</span><span class="p">())</span>
        <span class="n">new_b</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">existing_bonds</span><span class="p">)</span>
        <span class="n">bgroup</span> <span class="o">=</span> <span class="n">TopologyGroup</span><span class="o">.</span><span class="n">from_indices</span><span class="p">(</span><span class="n">new_b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span>
                                            <span class="n">bondclass</span><span class="o">=</span><span class="n">Bond</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">bonds</span> <span class="o">+=</span> <span class="n">bgroup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_caches</span><span class="p">(</span><span class="s">&#39;bonds&#39;</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">guess_angles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span>
        <span class="n">existing_angles</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">angles</span><span class="o">.</span><span class="n">to_indices</span><span class="p">())</span>
        <span class="n">new_a</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">existing_angles</span><span class="p">)</span>
        <span class="n">agroup</span> <span class="o">=</span> <span class="n">TopologyGroup</span><span class="o">.</span><span class="n">from_indices</span><span class="p">(</span><span class="n">new_a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span>
                                            <span class="n">bondclass</span><span class="o">=</span><span class="n">Angle</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">angles</span> <span class="o">+=</span> <span class="n">agroup</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_caches</span><span class="p">(</span><span class="s">&#39;angles&#39;</span><span class="p">)</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">guess_torsions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">existing_t</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">torsions</span><span class="o">.</span><span class="n">to_indices</span><span class="p">())</span>
        <span class="n">new_t</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">existing_t</span><span class="p">)</span>
        <span class="n">tgroup</span> <span class="o">=</span> <span class="n">TopologyGroup</span><span class="o">.</span><span class="n">from_indices</span><span class="p">(</span><span class="n">new_t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span>
                                          <span class="n">bondclass</span><span class="o">=</span><span class="n">Torsion</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">torsions</span> <span class="o">+=</span> <span class="n">tgroup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_caches</span><span class="p">(</span><span class="s">&#39;torsions&#39;</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;bonds&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="AtomGroup.bonds"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.bonds">[docs]</a>    <span class="k">def</span> <span class="nf">bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;All the bonds in this AtomGroup</span>

<span class="sd">        Note that these bonds might extend out of the AtomGroup, to select</span>
<span class="sd">        only bonds which are entirely contained by the AtomGroup use</span>
<span class="sd">        u.bonds.atomgroup_intersection(ag, strict=True)</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        .. versionchanged:: 0.10.0</span>
<span class="sd">           Now always returns a (possibly empty) TopologyGroup</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..topology.core</span> <span class="kn">import</span> <span class="n">TopologyGroup</span>

        <span class="n">mybonds</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">bonds</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="n">mybonds</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;angles&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="AtomGroup.angles"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.angles">[docs]</a>    <span class="k">def</span> <span class="nf">angles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;All the angles in this AtomGroup</span>

<span class="sd">        Note that these angles might extend out of the AtomGroup, to select</span>
<span class="sd">        only angles which are entirely contained by the AtomGroup use</span>
<span class="sd">        u.angles.atomgroup_intersection(ag, strict=True)</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        .. versionchanged:: 0.10.0</span>
<span class="sd">           Now always returns a (possibly empty) TopologyGroup</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..topology.core</span> <span class="kn">import</span> <span class="n">TopologyGroup</span>

        <span class="n">mybonds</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">angles</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="n">mybonds</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;torsions&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="AtomGroup.torsions"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.torsions">[docs]</a>    <span class="k">def</span> <span class="nf">torsions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;All the torsions in this AtomGroup</span>

<span class="sd">        Note that these torsions might extend out of the AtomGroup, to select</span>
<span class="sd">        only torsions which are entirely contained by the AtomGroup use</span>
<span class="sd">        u.torsions.atomgroup_intersection(ag, strict=True)</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        .. versionchanged:: 0.10.0</span>
<span class="sd">           Now always returns a (possibly empty) TopologyGroup</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..topology.core</span> <span class="kn">import</span> <span class="n">TopologyGroup</span>

        <span class="n">mybonds</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">torsions</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="n">mybonds</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;impropers&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="AtomGroup.impropers"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.impropers">[docs]</a>    <span class="k">def</span> <span class="nf">impropers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;All the improper torsions in this AtomGroup</span>

<span class="sd">        Note that these improper torsions might extend out of the AtomGroup,</span>
<span class="sd">        to select only torsions which are entirely contained by the AtomGroup use</span>
<span class="sd">        u.impropers.atomgroup_intersection(ag, strict=True)</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        .. versionchanged:: 0.10.0</span>
<span class="sd">           Now always returns a (possibly empty) TopologyGroup</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..topology.core</span> <span class="kn">import</span> <span class="n">TopologyGroup</span>

        <span class="n">mybonds</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">impropers</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="n">mybonds</span><span class="p">)</span>
</div>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;masses&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="AtomGroup.masses"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.masses">[docs]</a>    <span class="k">def</span> <span class="nf">masses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Array of atomic masses (as defined in the topology)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">mass</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="AtomGroup.totalMass"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.totalMass">[docs]</a>    <span class="k">def</span> <span class="nf">totalMass</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total mass of the selection (masses are taken from the topology or guessed).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.charges"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.charges">[docs]</a>    <span class="k">def</span> <span class="nf">charges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Array of partial charges of the atoms (as defined in the topology)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">charge</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="AtomGroup.totalCharge"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.totalCharge">[docs]</a>    <span class="k">def</span> <span class="nf">totalCharge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sum of all partial charges (must be defined in topology).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">charges</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.radii"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.radii">[docs]</a>    <span class="k">def</span> <span class="nf">radii</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Array of atomic radii (as defined in the PQR file)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">radius</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">])</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AtomGroup.bfactors"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.bfactors">[docs]</a>    <span class="k">def</span> <span class="nf">bfactors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Crystallographic B-factors (from PDB) in A**2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">bfactor</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">])</span>
</div>
    <span class="k">def</span> <span class="nf">_set_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groupname</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set attribute *name* to *value* for all elements in *groupname*.</span>

<span class="sd">        *groupname* can be *atoms*, *residues*, *segments. ``getattr(self,</span>
<span class="sd">        groupname)`` should produce one of the groups in the hierarchy.</span>

<span class="sd">        If *value* is a sequence of the same length as the group then each</span>
<span class="sd">        element&#39;s attribute *name* is set to the corresponding value. If</span>
<span class="sd">        *value* is neither of length 1 (or a scalar) nor of the length of the</span>
<span class="sd">        group then a :exc:`ValueError` is raised.</span>

<span class="sd">        A cache entry ``_cache[groupname]`` is deleted if it exists.</span>

<span class="sd">        :Keywords:</span>

<span class="sd">          *conversion*</span>
<span class="sd">               function such as :func:`str` or :func:`int` that converts the</span>
<span class="sd">               argument. ``None`` passes it through unchanged [``None``]</span>

<span class="sd">          *cache*</span>
<span class="sd">               alternative identifier for the cache, instead of *groupname*</span>

<span class="sd">        .. versionadded:: 0.8</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">asiterable</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">group</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groupname</span><span class="p">)</span>
        <span class="n">conversion</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;conversion&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;cache&#39;</span><span class="p">,</span> <span class="n">groupname</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">conversion</span><span class="p">:</span>
            <span class="n">conversion</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conversion</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conversion</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;set_{0}: can only set all atoms to a single value or each atom to a distinct one &quot;</span>
                             <span class="s">&quot;but len(atoms)={1} whereas len(value)={2}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">groupname</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_caches</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>

        <span class="c"># big hammer... if we find the time, use this in a more surgical fashion.</span>
        <span class="c">#self.atoms._rebuild_caches()</span>
        <span class="c">#if self.atoms is not self.universe.atoms:</span>
        <span class="c">#    self.universe.atoms._rebuild_caches()</span>

    <span class="k">def</span> <span class="nf">_set_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set attribute *name* to *value* for all atoms in the :class:`AtomGroup`.</span>

<span class="sd">        If *value* is a sequence of the same length as the :class:`AtomGroup`</span>
<span class="sd">        then each :class:`Atom`&#39;s property *name* is set to the corresponding value. If</span>
<span class="sd">        *value* is neither of length 1 (or a scalar) nor of the length of the</span>
<span class="sd">        :class:`AtomGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_attribute</span><span class="p">(</span><span class="s">&quot;atoms&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c"># override for ResidueGroup, SegmentGroup accordingly</span>
    <span class="nb">set</span> <span class="o">=</span> <span class="n">_set_atoms</span>

<div class="viewcode-block" id="AtomGroup.set_name"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_name">[docs]</a>    <span class="k">def</span> <span class="nf">set_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the atom name to string for *all atoms* in the AtomGroup.</span>

<span class="sd">        If *value* is a sequence of the same length as the :class:`AtomGroup`</span>
<span class="sd">        then each :attr:`Atom.name` is set to the corresponding value. If</span>
<span class="sd">        *value* is neither of length 1 (or a scalar) nor of the length of the</span>
<span class="sd">        :class:`AtomGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conversion</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.set_resid"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_resid">[docs]</a>    <span class="k">def</span> <span class="nf">set_resid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the resid to integer *resid* for **all atoms** in the :class:`AtomGroup`.</span>

<span class="sd">        If *resid* is a sequence of the same length as the :class:`AtomGroup`</span>
<span class="sd">        then each :attr:`Atom.resid` is set to the corresponding value together</span>
<span class="sd">        with the :attr:`Residue.id` of the residue the atom belongs to. If</span>
<span class="sd">        *value* is neither of length 1 (or a scalar) nor of the length of the</span>
<span class="sd">        :class:`AtomGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. Note::</span>

<span class="sd">           Changing resids can change the topology.</span>

<span class="sd">           Assigning the same *resid* to multiple residues will</span>
<span class="sd">           **merge** these residues. Assigning different *resid* to</span>
<span class="sd">           atoms in the same residue will **split** a residue (and</span>
<span class="sd">           potentially merge with another one).</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.7.5</span>
<span class="sd">           Also changes the residues.</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a</span>
<span class="sd">           sequence or iterable and can change the topology via</span>
<span class="sd">           :func:`MDAnalysis.topology.core.build_residues`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">MDAnalysis.topology.core</span> <span class="kn">import</span> <span class="n">build_residues</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;resid&quot;</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">conversion</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c"># Note that this also automagically updates THIS AtomGroup;</span>
        <span class="c"># the side effect of build_residues(self.atoms) is to update all Atoms!!!!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fill_cache</span><span class="p">(</span><span class="s">&#39;residues&#39;</span><span class="p">,</span> <span class="n">build_residues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">))</span>
        <span class="c"># make sure to update the whole universe: the Atoms are shared but ResidueGroups are not</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">_fill_cache</span><span class="p">(</span><span class="s">&#39;residues&#39;</span><span class="p">,</span> <span class="n">build_residues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="AtomGroup.set_resnum"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_resnum">[docs]</a>    <span class="k">def</span> <span class="nf">set_resnum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resnum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the resnum to *resnum* for **all atoms** in the :class:`AtomGroup`.</span>

<span class="sd">        If *resnum* is a sequence of the same length as the :class:`AtomGroup`</span>
<span class="sd">        then each :attr:`Atom.resnum` is set to the corresponding value together</span>
<span class="sd">        with the :attr:`Residue.resnum` of the residue the atom belongs to. If</span>
<span class="sd">        *value* is neither of length 1 (or a scalar) nor of the length of the</span>
<span class="sd">        :class:`AtomGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. Note::</span>

<span class="sd">           Changing *resnum* will not affect the topology: you can have</span>
<span class="sd">           multiple residues with the same *resnum*.</span>

<span class="sd">        .. SeeAlso:: :meth:`set_resid`</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.7.5</span>
<span class="sd">           Also changes the residues.</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">MDAnalysis.topology.core</span> <span class="kn">import</span> <span class="n">build_residues</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;resnum&quot;</span><span class="p">,</span> <span class="n">resnum</span><span class="p">)</span>
        <span class="c"># build_residues() is the easiest (though expensive) way to make sure</span>
        <span class="c"># that all residues get their new resnum. There&#39;s no easy way to parse</span>
        <span class="c"># a per-atom resnum list (with potential duplicates) into a list of</span>
        <span class="c"># corresponding residues.</span>
        <span class="c">#</span>
        <span class="c"># (This comment applies to the analogous methods below as well.)</span>
        <span class="n">build_residues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.set_resname"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_resname">[docs]</a>    <span class="k">def</span> <span class="nf">set_resname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the resname to string *resname* for **all atoms** in the :class:`AtomGroup`.</span>

<span class="sd">        If *resname* is a sequence of the same length as the :class:`AtomGroup`</span>
<span class="sd">        then each :attr:`Atom.resname` is set to the corresponding value together</span>
<span class="sd">        with the :attr:`Residue.name` of the residue the atom belongs to. If</span>
<span class="sd">        *value* is neither of length 1 (or a scalar) nor of the length of the</span>
<span class="sd">        :class:`AtomGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.7.5</span>
<span class="sd">           Also changes the residues.</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">MDAnalysis.topology.core</span> <span class="kn">import</span> <span class="n">build_residues</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;resname&quot;</span><span class="p">,</span> <span class="n">resname</span><span class="p">,</span> <span class="n">conversion</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
        <span class="n">build_residues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.set_segid"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_segid">[docs]</a>    <span class="k">def</span> <span class="nf">set_segid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segid</span><span class="p">,</span> <span class="n">buildsegments</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the segid to *segid* for all atoms in the :class:`AtomGroup`.</span>

<span class="sd">        If *segid* is a sequence of the same length as the :class:`AtomGroup`</span>
<span class="sd">        then each :attr:`Atom.segid` is set to the corresponding value together</span>
<span class="sd">        with the :attr:`Segment.id` of the residue the atom belongs to. If</span>
<span class="sd">        *value* is neither of length 1 (or a scalar) nor of the length of the</span>
<span class="sd">        :class:`AtomGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. Note::</span>

<span class="sd">           :meth:`set_segid` can change the topology.</span>

<span class="sd">           With the default *buildsegments* = ``True`` it can be used to join</span>
<span class="sd">           segments or to break groups into multiple disjoint segments. Note</span>
<span class="sd">           that each :class:`Atom` can only belong to a single</span>
<span class="sd">           :class:`Segment`.</span>

<span class="sd">        For performance reasons, *buildsegments* can be set to ``False``. Then</span>
<span class="sd">        one needs to run :meth:`Universe._build_segments` manually later in</span>
<span class="sd">        order to update the list of :class:`Segment` instances and regenerate</span>
<span class="sd">        the segid instant selectors.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;segid&quot;</span><span class="p">,</span> <span class="n">segid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_caches</span><span class="p">(</span><span class="s">&#39;segments&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">buildsegments</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_build_segments</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># do not even update the local segment</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">_clear_caches</span><span class="p">(</span><span class="s">&#39;segments&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.set_mass"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_mass">[docs]</a>    <span class="k">def</span> <span class="nf">set_mass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mass</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the atom mass to float *mass* for **all atoms** in the AtomGroup.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;mass&quot;</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">conversion</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="s">&quot;masses&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.set_type"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_type">[docs]</a>    <span class="k">def</span> <span class="nf">set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the atom type to *atype* for **all atoms** in the AtomGroup.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;type&quot;</span><span class="p">,</span> <span class="n">atype</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.set_charge"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_charge">[docs]</a>    <span class="k">def</span> <span class="nf">set_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">charge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the partial charge to float *charge* for **all atoms** in the AtomGroup.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;charge&quot;</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">conversion</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.set_radius"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_radius">[docs]</a>    <span class="k">def</span> <span class="nf">set_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the atom radius to float *radius* for **all atoms** in the AtomGroup.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;radius&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">conversion</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.set_bfactor"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_bfactor">[docs]</a>    <span class="k">def</span> <span class="nf">set_bfactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bfactor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the atom bfactor to float *bfactor* for **all atoms** in the AtomGroup.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;bfactor&quot;</span><span class="p">,</span> <span class="n">bfactor</span><span class="p">,</span> <span class="n">conversion</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.centerOfGeometry"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.centerOfGeometry">[docs]</a>    <span class="k">def</span> <span class="nf">centerOfGeometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Center of geometry (also known as centroid) of the selection.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *pbc*</span>
<span class="sd">            ``True``: Move all atoms within the primary unit cell before calculation [``False``]</span>

<span class="sd">        .. Note::</span>
<span class="sd">            The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to ``True`` allows the *pbc*</span>
<span class="sd">            flag to be used by default.</span>

<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pbc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;pbc&#39;</span><span class="p">,</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s">&#39;use_pbc&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">packIntoBox</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">numberOfAtoms</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">numberOfAtoms</span><span class="p">()</span>
</div>
    <span class="n">centroid</span> <span class="o">=</span> <span class="n">centerOfGeometry</span>

<div class="viewcode-block" id="AtomGroup.centerOfMass"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.centerOfMass">[docs]</a>    <span class="k">def</span> <span class="nf">centerOfMass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Center of mass of the selection.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *pbc*</span>
<span class="sd">            ``True``: Move all atoms within the primary unit cell before calculation [``False``]</span>

<span class="sd">        .. Note::</span>
<span class="sd">            The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to ``True`` allows the *pbc*</span>
<span class="sd">            flag to be used by default.</span>

<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pbc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;pbc&#39;</span><span class="p">,</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s">&#39;use_pbc&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">packIntoBox</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">()[:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                             <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">totalMass</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">()[:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">totalMass</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="AtomGroup.radiusOfGyration"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.radiusOfGyration">[docs]</a>    <span class="k">def</span> <span class="nf">radiusOfGyration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Radius of gyration.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *pbc*</span>
<span class="sd">            ``True``: Move all atoms within the primary unit cell before calculation [``False``]</span>

<span class="sd">        .. Note::</span>
<span class="sd">            The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to ``True`` allows the *pbc*</span>
<span class="sd">            flag to be used by default.</span>

<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pbc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;pbc&#39;</span><span class="p">,</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s">&#39;use_pbc&#39;</span><span class="p">])</span>
        <span class="n">masses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="n">recenteredpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packIntoBox</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centerOfMass</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">recenteredpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centerOfMass</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">rog_sq</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">recenteredpos</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">totalMass</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rog_sq</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.shapeParameter"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.shapeParameter">[docs]</a>    <span class="k">def</span> <span class="nf">shapeParameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shape parameter.</span>

<span class="sd">        See [Dima2004]_ for background information.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *pbc*</span>
<span class="sd">            ``True``: Move all atoms within the primary unit cell before calculation [``False``]</span>

<span class="sd">        .. Note::</span>
<span class="sd">            The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to ``True`` allows the *pbc*</span>
<span class="sd">            flag to be used by default.</span>

<span class="sd">        .. versionadded:: 0.7.7</span>
<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pbc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;pbc&#39;</span><span class="p">,</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s">&#39;use_pbc&#39;</span><span class="p">])</span>
        <span class="n">masses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="n">recenteredpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packIntoBox</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centerOfMass</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">recenteredpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centerOfMass</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">tensor</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">recenteredpos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">tensor</span> <span class="o">+=</span> <span class="n">masses</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">recenteredpos</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="p">:],</span>
                                              <span class="n">recenteredpos</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">tensor</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">totalMass</span><span class="p">()</span>
        <span class="n">eig_vals</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="mf">27.0</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">eig_vals</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">))</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">shape</span>
</div>
<div class="viewcode-block" id="AtomGroup.asphericity"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.asphericity">[docs]</a>    <span class="k">def</span> <span class="nf">asphericity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Asphericity.</span>

<span class="sd">        See [Dima2004]_ for background information.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *pbc*</span>
<span class="sd">            ``True``: Move all atoms within primary unit cell before calculation [``False``]</span>

<span class="sd">        .. Note::</span>
<span class="sd">            The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to ``True`` allows the *pbc*</span>
<span class="sd">            flag to be used by default.</span>

<span class="sd">        .. versionadded:: 0.7.7</span>
<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pbc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;pbc&#39;</span><span class="p">,</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s">&#39;use_pbc&#39;</span><span class="p">])</span>
        <span class="n">masses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="n">recenteredpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packIntoBox</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centerOfMass</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">recenteredpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centerOfMass</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">tensor</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">recenteredpos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">tensor</span> <span class="o">+=</span> <span class="n">masses</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">recenteredpos</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="p">:],</span>
                                              <span class="n">recenteredpos</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">tensor</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">totalMass</span><span class="p">()</span>
        <span class="n">eig_vals</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">eig_vals</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">power</span><span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">shape</span>
</div>
<div class="viewcode-block" id="AtomGroup.momentOfInertia"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.momentOfInertia">[docs]</a>    <span class="k">def</span> <span class="nf">momentOfInertia</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tensor of inertia as 3x3 NumPy array.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *pbc*</span>
<span class="sd">            ``True``: Move all atoms within the primary unit cell before calculation [``False``]</span>

<span class="sd">        .. Note::</span>
<span class="sd">            The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to ``True`` allows the *pbc*</span>
<span class="sd">            flag to be used by default.</span>

<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pbc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;pbc&#39;</span><span class="p">,</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s">&#39;use_pbc&#39;</span><span class="p">])</span>
        <span class="c"># Convert to local coordinates</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packIntoBox</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centerOfMass</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centerOfMass</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="n">masses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">()</span>
        <span class="c"># Create the inertia tensor</span>
        <span class="c"># m_i = mass of atom i</span>
        <span class="c"># (x_i, y_i, z_i) = pos of atom i</span>
        <span class="c"># Ixx = sum(m_i*(y_i^2+z_i^2));</span>
        <span class="c"># Iyy = sum(m_i*(x_i^2+z_i^2));</span>
        <span class="c"># Izz = sum(m_i*(x_i^2+y_i^2))</span>
        <span class="c"># Ixy = Iyx = -1*sum(m_i*x_i*y_i)</span>
        <span class="c"># Ixz = Izx = -1*sum(m_i*x_i*z_i)</span>
        <span class="c"># Iyz = Izy = -1*sum(m_i*y_i*z_i)</span>
        <span class="n">tens</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="c"># xx</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="p">(</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c"># xy &amp; yx</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tens</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c"># xz &amp; zx</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tens</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c"># yy</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="p">(</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c"># yz + zy</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tens</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c"># zz</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="p">(</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">tens</span>
</div>
<div class="viewcode-block" id="AtomGroup.bbox"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.bbox">[docs]</a>    <span class="k">def</span> <span class="nf">bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the bounding box of the selection.</span>

<span class="sd">        The lengths A,B,C of the orthorhombic enclosing box are ::</span>

<span class="sd">          L = AtomGroup.bbox()</span>
<span class="sd">          A,B,C = L[1] - L[0]</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *pbc*</span>
<span class="sd">            ``True``: Move all atoms within the primary unit cell before calculation [``False``]</span>

<span class="sd">        .. Note::</span>
<span class="sd">            The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to ``True`` allows the *pbc*</span>
<span class="sd">            flag to be used by default.</span>

<span class="sd">        :Returns: [[xmin, ymin, zmin], [xmax, ymax, zmax]]</span>

<span class="sd">        .. versionadded:: 0.7.2</span>
<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pbc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;pbc&#39;</span><span class="p">,</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s">&#39;use_pbc&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packIntoBox</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)])</span>
</div>
<div class="viewcode-block" id="AtomGroup.bsphere"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.bsphere">[docs]</a>    <span class="k">def</span> <span class="nf">bsphere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the bounding sphere of the selection.</span>

<span class="sd">        The sphere is calculated relative to the centre of geometry.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *pbc*</span>
<span class="sd">            ``True``: Move all atoms within primary unit cell before calculation [``False``]</span>

<span class="sd">        .. Note::</span>
<span class="sd">            The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to ``True`` allows the *pbc*</span>
<span class="sd">            flag to be used by default.</span>

<span class="sd">        :Returns: `(R, [xcen,ycen,zcen])`</span>

<span class="sd">        .. versionadded:: 0.7.3</span>
<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pbc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;pbc&#39;</span><span class="p">,</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s">&#39;use_pbc&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packIntoBox</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centerOfGeometry</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centerOfGeometry</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">centroid</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">R</span><span class="p">,</span> <span class="n">centroid</span>
</div>
<div class="viewcode-block" id="AtomGroup.bond"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.bond">[docs]</a>    <span class="k">def</span> <span class="nf">bond</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the distance between atoms in a 2-atom group.</span>

<span class="sd">        Distance between atoms 0 and 1::</span>

<span class="sd">            0---1</span>

<span class="sd">        .. Note::</span>

<span class="sd">           Only makes sense for a :class:`AtomGroup` with exactly 2</span>
<span class="sd">           :class:`Atom`; anything else will raise a</span>
<span class="sd">           :exc:`ValueError`.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *pbc*</span>
<span class="sd">            ``True``: Account for minimum image convention when calculating [``False``]</span>

<span class="sd">        .. versionadded:: 0.7.3</span>
<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..core</span> <span class="kn">import</span> <span class="n">distances</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;distance computation only makes sense for a group with exactly 2 atoms&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">self_distance_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span> <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="AtomGroup.angle"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.angle">[docs]</a>    <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the angle in degrees between atoms 0, 1, 2.</span>

<span class="sd">        Angle between atoms 0 and 2 with apex at 1::</span>

<span class="sd">              2</span>
<span class="sd">             /</span>
<span class="sd">            /</span>
<span class="sd">           1------0</span>

<span class="sd">        .. Note::</span>

<span class="sd">           Only makes sense for a :class:`AtomGroup` with exactly 3</span>
<span class="sd">           :class:`Atom`; anything else will raise a :exc:`ValueError`.</span>

<span class="sd">        .. versionadded:: 0.7.3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;angle computation only makes sense for a group with exactly 3 atoms&quot;</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span>
                                          <span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">util</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">))))</span>
</div>
<div class="viewcode-block" id="AtomGroup.improper"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.improper">[docs]</a>    <span class="k">def</span> <span class="nf">improper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the improper dihedral between 4 atoms.</span>

<span class="sd">        The improper dihedral is calculated in the same way as the proper</span>
<span class="sd">        :meth:`dihedral`: The angle between the planes formed by atoms (0,1,2)</span>
<span class="sd">        and (1,2,3).</span>

<span class="sd">        .. Note::</span>

<span class="sd">           Only makes sense for a :class:`AtomGroup` with exactly 4</span>
<span class="sd">           :class:`Atom`; anything else will raise a :exc:`ValueError`. The</span>
<span class="sd">           interpretation of the angle as an &quot;improper&quot; solely depends on the</span>
<span class="sd">           selection of atoms and thus the user input!</span>

<span class="sd">        .. versionadded:: 0.7.3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedral</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="AtomGroup.dihedral"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.dihedral">[docs]</a>    <span class="k">def</span> <span class="nf">dihedral</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the dihedral angle in degrees.</span>

<span class="sd">        Dihedral angle around axis connecting atoms 1 and 2 (i.e. the angle</span>
<span class="sd">        between the planes spanned by atoms (0,1,2) and (1,2,3))::</span>

<span class="sd">                  3</span>
<span class="sd">                  |</span>
<span class="sd">            1-----2</span>
<span class="sd">           /</span>
<span class="sd">          0</span>

<span class="sd">        .. Note::</span>

<span class="sd">           Only makes sense for a :class:`AtomGroup` with exactly 4</span>
<span class="sd">           :class:`Atom`; anything else will raise a :exc:`ValueError`.</span>

<span class="sd">        .. versionadded:: 0.7.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;dihedral computation only makes sense for a group with exactly 4 atoms&quot;</span><span class="p">)</span>

        <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[:</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">ab</span> <span class="o">=</span> <span class="n">A</span> <span class="o">-</span> <span class="n">B</span>
        <span class="n">bc</span> <span class="o">=</span> <span class="n">B</span> <span class="o">-</span> <span class="n">C</span>
        <span class="n">cd</span> <span class="o">=</span> <span class="n">C</span> <span class="o">-</span> <span class="n">D</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">dihedral</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">cd</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="AtomGroup.principalAxes"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.principalAxes">[docs]</a>    <span class="k">def</span> <span class="nf">principalAxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the principal axes from the moment of inertia.</span>

<span class="sd">        e1,e2,e3 = AtomGroup.principalAxes()</span>

<span class="sd">        The eigenvectors are sorted by eigenvalue, i.e. the first one</span>
<span class="sd">        corresponds to the highest eigenvalue and is thus the first principal axes.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *pbc*</span>
<span class="sd">            ``True``: Move all atoms within primary unit cell before calculation</span>

<span class="sd">        .. Note::</span>
<span class="sd">            The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to ``True`` allows the *pbc*</span>
<span class="sd">            flag to be used by default.</span>

<span class="sd">        :Returns: numpy.array ``v`` with ``v[0]`` as first, ``v[1]`` as second,</span>
<span class="sd">                  and ``v[2]`` as third eigenvector.</span>

<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pbc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;pbc&#39;</span><span class="p">,</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s">&#39;use_pbc&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="n">eigenval</span><span class="p">,</span> <span class="n">eigenvec</span> <span class="o">=</span> <span class="n">eig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">momentOfInertia</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eigenval</span><span class="p">,</span> <span class="n">eigenvec</span> <span class="o">=</span> <span class="n">eig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">momentOfInertia</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
        <span class="c"># Sort</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">eigenval</span><span class="p">)</span>
        <span class="c"># Return transposed in more logical form. See Issue 33.</span>
        <span class="k">return</span> <span class="n">eigenvec</span><span class="p">[:,</span> <span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
</div>
<div class="viewcode-block" id="AtomGroup.get_positions"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.get_positions">[docs]</a>    <span class="k">def</span> <span class="nf">get_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a NumPy array of the coordinates.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">           *ts*</span>
<span class="sd">               If *ts* is provided then positions are read from that</span>
<span class="sd">               :class:`~MDAnalysis.coordinates.base.Timestep` instead of</span>
<span class="sd">               the one from the current trajectory belonging to this universe.</span>
<span class="sd">               The *ts* is indexed with the indices returned by</span>
<span class="sd">               :meth:`~AtomGroup.indices` and it is the user&#39;s responsibility</span>
<span class="sd">               to provide a time step that has the appropriate dimensions.</span>
<span class="sd">           *copy*</span>
<span class="sd">               ``True``: always make a copy (slow), ``False``: Try to</span>
<span class="sd">               return a array view or reference (faster); note that for</span>
<span class="sd">               passing coordinates to C-code it can be necessary to use</span>
<span class="sd">               a copy [``False``]</span>
<span class="sd">           *dtype*</span>
<span class="sd">               NumPy Data type of the array; the default is usually</span>
<span class="sd">               entirely appropriate. Most C-code actually requires the</span>
<span class="sd">               default  [:class:`numpy.float32`]</span>

<span class="sd">        Coordinates can also be directly obtained from the attribute</span>
<span class="sd">        :attr:`~AtomGroup.positions`.</span>

<span class="sd">        Coordinates can be directly set with :meth:`~AtomGroup.set_positions` or</span>
<span class="sd">        by assigning to :attr:`~AtomGroup.positions`.</span>

<span class="sd">        This method is identical with :meth:`~AtomGroup.coordinates` but named</span>
<span class="sd">        differently for symmetry with with :meth:`~AtomGroup.set_positions`.</span>

<span class="sd">        .. versionadded:: 0.7.6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ts</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()],</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
</div>
    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">get_positions</span>
    <span class="sd">&quot;&quot;&quot;NumPy array of the coordinates.</span>

<span class="sd">    .. SeeAlso:: :attr:`~AtomGroup.positions` and :meth:`~AtomGroup.get_positions`</span>

<span class="sd">    .. deprecated:: 0.7.6</span>
<span class="sd">       In new scripts use :meth:`AtomGroup.get_positions` preferrably.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># coordinates() should NOT be removed as it has been used in many scripts,</span>
    <span class="c"># MDAnalysis itself, and in the paper</span>

<div class="viewcode-block" id="AtomGroup.set_positions"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_positions">[docs]</a>    <span class="k">def</span> <span class="nf">set_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the positions for all atoms in the group.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">           *coords*</span>
<span class="sd">               a Nx3 NumPy :class:`numpy.ndarray` where N is the number of</span>
<span class="sd">               atoms in this atom group.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">           *ts*</span>
<span class="sd">              :class:`~MDAnalysis.coordinates.base.Timestep`, defaults</span>
<span class="sd">              to ``None`` and then the current time step is used.</span>

<span class="sd">        .. Note::</span>

<span class="sd">           If the group contains N atoms and *coord* is a single point (i.e. an</span>
<span class="sd">           array of length 3) then all N atom positions are set to *coord* (due</span>
<span class="sd">           to NumPy&#39;s broadcasting rules), as described for</span>
<span class="sd">           :attr:`~AtomGroup.positions`.</span>

<span class="sd">        See also :meth:`~AtomGroup.get_positions` and attribute access through</span>
<span class="sd">        :attr:`~AtomGroup.positions`.</span>

<span class="sd">        .. versionadded:: 0.7.6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ts</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="s">&#39;has_x&#39;</span><span class="p">):</span>  <span class="c"># TRR handling must be told frame now holds valid coord info.</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">has_x</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">_pos</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">(),</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">coords</span>
</div>
    <span class="n">positions</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_positions</span><span class="p">,</span> <span class="n">set_positions</span><span class="p">,</span>
                         <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">                Coordinates of the atoms in the AtomGroup.</span>

<span class="s">                The positions can be changed by assigning an array of the appropriate</span>
<span class="s">                shape, i.e. either Nx3 to assign individual coordinates or 3, to assign</span>
<span class="s">                the *same* coordinate to all atoms (e.g. ``ag.positions = array([0,0,0])``</span>
<span class="s">                will move all particles to the origin).</span>

<span class="s">                For more control use the :meth:`~AtomGroup.get_positions` and</span>
<span class="s">                :meth:`~AtomGroup.set_positions` methods.</span>

<span class="s">                .. versionadded:: 0.7.6&quot;&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="AtomGroup.get_velocities"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.get_velocities">[docs]</a>    <span class="k">def</span> <span class="nf">get_velocities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;NumPy array of the velocities.</span>

<span class="sd">        Raises a :exc:`NoDataError` if the underlying</span>
<span class="sd">        :class:`~MDAnalysis.coordinates.base.Timestep` does not contain</span>
<span class="sd">        :attr:`~MDAnalysis.coordinates.base.Timestep._velocities`.</span>

<span class="sd">        See also :meth:`AtomGroup.set_velocities` and attribute access through</span>
<span class="sd">        :attr:`AtomGroup.velocities`.</span>

<span class="sd">        .. versionadded:: 0.7.6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ts</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">_velocities</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()],</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s">&quot;Timestep does not contain velocities&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.set_velocities"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_velocities">[docs]</a>    <span class="k">def</span> <span class="nf">set_velocities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assign the velocities *v* to the timestep.</span>

<span class="sd">        Raises a :exc:`NoDataError` if the underlying</span>
<span class="sd">        :class:`~MDAnalysis.coordinates.base.Timestep` does not contain</span>
<span class="sd">        :attr:`~MDAnalysis.coordinates.base.Timestep._velocities`.</span>

<span class="sd">        See also :meth:`AtomGroup.get_velocities` and :attr:`AtomGroup.velocities` for</span>
<span class="sd">        attribute access.</span>

<span class="sd">        .. versionadded:: 0.7.6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ts</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="s">&#39;has_v&#39;</span><span class="p">):</span>  <span class="c"># TRR handling must be told frame now holds valid velocity info.</span>
                <span class="n">ts</span><span class="o">.</span><span class="n">has_v</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">_velocities</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">(),</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s">&quot;Timestep does not contain velocities&quot;</span><span class="p">)</span>
</div>
    <span class="n">velocities</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_velocities</span><span class="p">,</span> <span class="n">set_velocities</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">        NumPy array of the velocities of the atoms in the group.</span>

<span class="s">        If the trajectory does not contain velocity information then a</span>
<span class="s">        :exc:`~MDAnalysis.NoDataError` is raised.</span>

<span class="s">        .. versionadded:: 0.7.5</span>
<span class="s">        .. deprecated:: 0.7.6</span>
<span class="s">           In 0.8 this will become an attribute! You can already use :meth:`get_velocities`</span>
<span class="s">           and :meth:`set_velocities`.</span>
<span class="s">        .. versionchanged:: 0.8</span>
<span class="s">           Became an attribute.</span>
<span class="s">    &quot;&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="AtomGroup.get_forces"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.get_forces">[docs]</a>    <span class="k">def</span> <span class="nf">get_forces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a NumPy array of the atomic forces (if available).</span>
<span class="sd">        Currently only supported for Gromacs .trr trajectories.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">           *ts*</span>
<span class="sd">               If *ts* is provided then positions are read from that</span>
<span class="sd">               :class:`~MDAnalysis.coordinates.base.Timestep` instead of</span>
<span class="sd">               the one from the current trajectory belonging to this universe.</span>
<span class="sd">               The *ts* is indexed with the indices returned by</span>
<span class="sd">               :meth:`~AtomGroup.indices` and it is the user&#39;s responsibility</span>
<span class="sd">               to provide a time step that has the appropriate dimensions.</span>
<span class="sd">           *copy*</span>
<span class="sd">               ``True``: always make a copy (slow), ``False``: Try to</span>
<span class="sd">               return a array view or reference (faster); note that for</span>
<span class="sd">               passing coordinates to C-code it can be necessary to use</span>
<span class="sd">               a copy [``False``]</span>
<span class="sd">           *dtype*</span>
<span class="sd">               NumPy Data type of the array; the default is usually</span>
<span class="sd">               entirely appropriate. Most C-code actually requires the</span>
<span class="sd">               default  [:class:`numpy.float32`]</span>

<span class="sd">        Forces can also be directly obtained from the attribute</span>
<span class="sd">        :attr:`~AtomGroup.forces`.</span>

<span class="sd">        Forces can be directly set with :meth:`~AtomGroup.set_forces` or</span>
<span class="sd">        by assigning to :attr:`~AtomGroup.forces`.</span>

<span class="sd">        .. versionadded:: 0.7.7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ts</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">_forces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()],</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s">&quot;Timestep does not contain forces&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.set_forces"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_forces">[docs]</a>    <span class="k">def</span> <span class="nf">set_forces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forces</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the forces for all atoms in the group.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">           *forces*</span>
<span class="sd">               a Nx3 NumPy :class:`numpy.ndarray` where N is the number of</span>
<span class="sd">               atoms in this atom group.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">           *ts*</span>
<span class="sd">              :class:`~MDAnalysis.coordinates.base.Timestep`, defaults</span>
<span class="sd">              to ``None`` and then the current time step is used.</span>

<span class="sd">        .. Note::</span>

<span class="sd">           If the group contains N atoms and *force* is a single vector (i.e. an</span>
<span class="sd">           array of length 3) then all N atom positions are set to *force* (due</span>
<span class="sd">           to NumPy&#39;s broadcasting rules), as described for</span>
<span class="sd">           :attr:`~AtomGroup.forces`.</span>

<span class="sd">        See also :meth:`~AtomGroup.get_forces` and attribute access through</span>
<span class="sd">        :attr:`~AtomGroup.forces`.</span>

<span class="sd">        .. versionadded:: 0.7.7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ts</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="s">&#39;has_f&#39;</span><span class="p">):</span>  <span class="c"># TRR handling must be told frame now holds valid force info.</span>
                <span class="n">ts</span><span class="o">.</span><span class="n">has_f</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">_forces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">(),</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">forces</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s">&quot;Timestep does not contain forces&quot;</span><span class="p">)</span>
</div>
    <span class="n">forces</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_forces</span><span class="p">,</span> <span class="n">set_forces</span><span class="p">,</span>
                      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">                Forces on the atoms in the AtomGroup.</span>

<span class="s">                The forces can be changed by assigning an array of the appropriate</span>
<span class="s">                shape, i.e. either Nx3 to assign individual force or 3, to assign</span>
<span class="s">                the *same* force to all atoms (e.g. ``ag.forces = array([0,0,0])``</span>
<span class="s">                will set all forces to (0.,0.,0.)).</span>

<span class="s">                For more control use the :meth:`~AtomGroup.get_forces` and</span>
<span class="s">                :meth:`~AtomGroup.set_forces` methods.</span>

<span class="s">                .. versionadded:: 0.7.7&quot;&quot;&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="AtomGroup.transform"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Apply homogenous transformation matrix *M* to the coordinates.</span>

<span class="sd">        The matrix *M* must be a 4x4 matrix, with the rotation in</span>
<span class="sd">        `R = `M[:3,:3]`` and the translation in ``t = M[:3,3]``.</span>

<span class="sd">        The rotation :math:`\mathsf{R}` is applied before the</span>
<span class="sd">        translation :math:`\mathbf{t}`:</span>

<span class="sd">        .. math::</span>

<span class="sd">           \mathbf{x}&#39; = \mathsf{R}\mathbf{x} + \mathbf{t}</span>

<span class="sd">        .. SeeAlso: :mod:`MDAnalysis.core.transformations`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="c"># changes the coordinates (in place)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">_pos</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span>
        <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">t</span>
        <span class="k">return</span> <span class="n">R</span>
</div>
<div class="viewcode-block" id="AtomGroup.translate"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Apply translation vector *t* to the selection&#39;s coordinates.</span>

<span class="sd">          &gt;&gt;&gt; AtomGroup.translate(t)</span>
<span class="sd">          &gt;&gt;&gt; AtomGroup.translate((A, B))</span>

<span class="sd">        The method applies a translation to the AtomGroup from current</span>
<span class="sd">        coordinates :math:`\mathbf{x}` to new coordinates :math:`\mathbf{x}&#39;`:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \mathbf{x}&#39; = \mathbf{x} + \mathbf{t}</span>

<span class="sd">        The translation can also be given as a tuple of two MDAnalysis objects</span>
<span class="sd">        such as two selections `(selA, selB)`, i.e. two :class:`AtomGroup`, or</span>
<span class="sd">        two :class:`Atom`. The translation vector is computed as the</span>
<span class="sd">        difference between the centers of geometry (centroid) of B and A::</span>

<span class="sd">            t = B.centroid() - A.centroid()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sel1</span><span class="p">,</span> <span class="n">sel2</span> <span class="o">=</span> <span class="n">t</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">sel1</span><span class="o">.</span><span class="n">centroid</span><span class="p">(),</span> <span class="n">sel2</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span>
            <span class="n">vector</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="n">vector</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="c"># changes the coordinates (in place)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">_pos</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()]</span> <span class="o">+=</span> <span class="n">vector</span>
        <span class="k">return</span> <span class="n">vector</span>
</div>
<div class="viewcode-block" id="AtomGroup.rotate"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Apply a rotation matrix *R* to the selection&#39;s coordinates.</span>

<span class="sd">        AtomGroup.rotate(R)</span>

<span class="sd">        :math:`\mathsf{R}` is a 3x3 orthogonal matrix that transforms a vector</span>
<span class="sd">        :math:`\mathbf{x} \rightarrow \mathbf{x}&#39;`:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \mathbf{x}&#39; = \mathsf{R}\mathbf{x}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="c"># changes the coordinates (in place)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">_pos</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span>
        <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span>  <span class="c"># R.T acts to the left &amp; is broadcasted N times.</span>
        <span class="k">return</span> <span class="n">R</span>
</div>
<div class="viewcode-block" id="AtomGroup.rotateby"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.rotateby">[docs]</a>    <span class="k">def</span> <span class="nf">rotateby</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Apply a rotation to the selection&#39;s coordinates.</span>

<span class="sd">        AtomGroup.rotateby(angle,axis[,point])</span>

<span class="sd">        The transformation from current coordinates :math:`\mathbf{x}`</span>
<span class="sd">        to new coordinates :math:`\mathbf{x}&#39;` is</span>

<span class="sd">        .. math::</span>

<span class="sd">          \mathbf{x}&#39; = \mathsf{R}\,(\mathbf{x}-\mathbf{p}) + \mathbf{p}</span>

<span class="sd">        where :math:`\mathsf{R}` is the rotation by *angle* around the</span>
<span class="sd">        *axis* going through *point* :math:`\mathbf{p}`.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *angle*</span>
<span class="sd">             rotation angle in degrees</span>
<span class="sd">          *axis*</span>
<span class="sd">             rotation axis vector, a 3-tuple, list, or array, or a 2-tuple of</span>
<span class="sd">             two MDAnalysis objects from which the axis is calculated as the</span>
<span class="sd">             vector from the first to the second center of geometry.</span>
<span class="sd">          *point*</span>
<span class="sd">             point on the rotation axis; by default (``None``) the center of</span>
<span class="sd">             geometry of the selection is chosen, or, if *axis* is a tuple of</span>
<span class="sd">             selections, it defaults to the first point of the axis. *point*</span>
<span class="sd">             can be a 3-tuple, list, or array or a MDAnalysis object (in which</span>
<span class="sd">             case its :meth:`centroid` is used).</span>

<span class="sd">        :Returns: The 4x4 matrix which consists of the rotation matrix ``M[:3,:3]``</span>
<span class="sd">                  and the translation vector ``M[:3,3]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sel1</span><span class="p">,</span> <span class="n">sel2</span> <span class="o">=</span> <span class="n">axis</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">sel1</span><span class="o">.</span><span class="n">centroid</span><span class="p">(),</span> <span class="n">sel2</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">v</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">point</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">point</span> <span class="o">=</span> <span class="n">x1</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">point</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">M</span>
</div>
<div class="viewcode-block" id="AtomGroup.align_principalAxis"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.align_principalAxis">[docs]</a>    <span class="k">def</span> <span class="nf">align_principalAxis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Align principal axis with index *axis* with *vector*.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *axis*</span>
<span class="sd">            Index of the principal axis (0, 1, or 2), as produced by</span>
<span class="sd">            :meth:`~MDAnalysis.core.AtomGroup.AtomGroup.principalAxes`.</span>
<span class="sd">          *vector*</span>
<span class="sd">            A 3D vector such as the z-axis (``[0,0,1]``); can be</span>
<span class="sd">            anything that looks like a list with three entries.</span>

<span class="sd">        To align the long axis of a channel (the first principal axis,</span>
<span class="sd">        i.e. *axis* = 0) with the z-axis::</span>

<span class="sd">          u.atoms.align_principalAxis(0, [0,0,1])</span>
<span class="sd">          u.atoms.write(&quot;aligned.pdb&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">principalAxes</span><span class="p">()[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">vecangle</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">vector</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">rotaxis</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span>
        <span class="c">#print &quot;principal[%d] = %r&quot; % (axis, p)</span>
        <span class="c">#print &quot;axis = %r, angle = %f deg&quot; % (ax, angle)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotateby</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.packIntoBox"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.packIntoBox">[docs]</a>    <span class="k">def</span> <span class="nf">packIntoBox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Shift all atoms in this group to be within the primary unit cell.</span>

<span class="sd">        AtomGroup.packintobox([box, [inplace=True]])</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *box*</span>
<span class="sd">            Unit cell to move atoms inside of.</span>
<span class="sd">          *inplace*</span>
<span class="sd">            ``True``: Change coordinates in place and return</span>
<span class="sd">            ``False``: Only return the coordinates</span>

<span class="sd">        All atoms will be moved so that they lie between 0 and</span>
<span class="sd">        boxlength :math:`L_i` in all dimensions, i.e. the lower left</span>
<span class="sd">        corner of the simulation box is taken to be at (0,0,0):</span>

<span class="sd">        .. math::</span>

<span class="sd">           x_i&#39; = x_i - \left\lfloor\frac{x_i}{L_i}\right\rfloor</span>

<span class="sd">        The default is to take unit cell information from the</span>
<span class="sd">        underlying :class:`~MDAnalysis.coordinates.base.Timestep`</span>
<span class="sd">        instance. The optional argument *box* can be used to provide</span>
<span class="sd">        alternative unit cell information (in the MDAnalysis standard</span>
<span class="sd">        format ``[Lx, Ly, Lz, alpha, beta, gamma]``).</span>

<span class="sd">        Works with either orthogonal or triclinic box types.</span>

<span class="sd">        By default the coordinates are changed in place and returned</span>

<span class="sd">        .. versionadded:: 0.8</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..core</span> <span class="kn">import</span> <span class="n">distances</span>

        <span class="k">if</span> <span class="n">box</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>  <span class="c">#Try and auto detect box dimensions</span>
            <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>  <span class="c"># Can accept any box</span>

        <span class="k">if</span> <span class="n">box</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="c"># for a vector representation, diagonal cannot be zero</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">box</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;One or more box dimensions is zero.&quot;</span>
                                 <span class="s">&quot;  You can specify a boxsize with &#39;box =&#39;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">box</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>  <span class="c">#Check that a box dimension isn&#39;t zero</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;One or more box dimensions is zero.&quot;</span>
                                 <span class="s">&quot;  You can specify a boxsize with &#39;box=&#39;&quot;</span><span class="p">)</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">_pos</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">applyPBC</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">box</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">_pos</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()]</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">applyPBC</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">box</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">_pos</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()]</span>
</div>
<div class="viewcode-block" id="AtomGroup.wrap"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.wrap">[docs]</a>    <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="s">&quot;atoms&quot;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s">&quot;com&quot;</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shift the contents of this AtomGroup back into the unit cell.</span>

<span class="sd">        This is a more powerful version of :meth:`packIntoBox`, allowing</span>
<span class="sd">        groups of atoms to be kept together through the process.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">           *compound*</span>
<span class="sd">               The group which will be kept together through the shifting</span>
<span class="sd">               process. [``atoms``]</span>
<span class="sd">               Possible options:</span>
<span class="sd">                   * ``atoms``</span>
<span class="sd">                   * ``group`` - This AtomGroup</span>
<span class="sd">                   * ``residues``</span>
<span class="sd">                   * ``segments``</span>
<span class="sd">                   * ``fragments``</span>
<span class="sd">           *center*</span>
<span class="sd">               How to define the center of a given group of atoms [``com``]</span>
<span class="sd">           *box*</span>
<span class="sd">               Unit cell information.  If not provided, the values from</span>
<span class="sd">               Timestep will be used.</span>

<span class="sd">        When specifying a *compound*, the translation is calculated based on</span>
<span class="sd">        each compound. The same translation is applied to all atoms</span>
<span class="sd">        within this compound, meaning it will not be broken by the shift.</span>
<span class="sd">        This might however mean that all atoms from the compound are not</span>
<span class="sd">        inside the unit cell, but rather the center of the compound is.</span>
<span class="sd">        Compounds available for use are *atoms*, *residues*,</span>
<span class="sd">        *segments* and *fragments*</span>

<span class="sd">        *center* allows the definition of the center of each group to be</span>
<span class="sd">        specified.  This can be either &#39;com&#39; for center of mass, or &#39;cog&#39;</span>
<span class="sd">        for center of geometry.</span>

<span class="sd">        *box* allows a unit cell to be given for the transformation.  If not</span>
<span class="sd">        specified, an the dimensions information from the current Timestep</span>
<span class="sd">        will be used.</span>

<span class="sd">        .. Note::</span>
<span class="sd">           wrap with all default keywords is identical to :meth:`packIntoBox`</span>

<span class="sd">        .. versionadded:: 0.9.2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..core</span> <span class="kn">import</span> <span class="n">distances</span>

        <span class="k">if</span> <span class="n">compound</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;atoms&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">packIntoBox</span><span class="p">(</span><span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">compound</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;group&#39;</span><span class="p">:</span>
            <span class="n">objects</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">compound</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;residues&#39;</span><span class="p">:</span>
            <span class="n">objects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">residues</span>
        <span class="k">elif</span> <span class="n">compound</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;segments&#39;</span><span class="p">:</span>
            <span class="n">objects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span>
        <span class="k">elif</span> <span class="n">compound</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;fragments&#39;</span><span class="p">:</span>
            <span class="n">objects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Unrecognised compound definition: {0}&quot;</span>
                             <span class="s">&quot;Please use one of &#39;group&#39; &#39;residues&#39; &#39;segments&#39;&quot;</span>
                             <span class="s">&quot;or &#39;fragments&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">compound</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">center</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;com&#39;</span><span class="p">,</span> <span class="s">&#39;centerofmass&#39;</span><span class="p">):</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">centerOfMass</span><span class="p">()</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">center</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;cog&#39;</span><span class="p">,</span> <span class="s">&#39;centroid&#39;</span><span class="p">,</span> <span class="s">&#39;centerofgeometry&#39;</span><span class="p">):</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">centerOfGeometry</span><span class="p">()</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Unrecognised center definition: {0}&quot;</span>
                             <span class="s">&quot;Please use one of &#39;com&#39; or &#39;cog&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">center</span><span class="p">))</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="n">centers</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">box</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>

        <span class="c"># calculate shift per object center</span>
        <span class="n">dests</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">applyPBC</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">)</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="n">dests</span> <span class="o">-</span> <span class="n">centers</span>

        <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">shifts</span><span class="p">):</span>
            <span class="c"># Save some needless shifts</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
                <span class="n">o</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.selectAtoms"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.selectAtoms">[docs]</a>    <span class="k">def</span> <span class="nf">selectAtoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="o">*</span><span class="n">othersel</span><span class="p">,</span> <span class="o">**</span><span class="n">selgroups</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Selection of atoms using the MDAnalysis selection syntax.</span>

<span class="sd">        AtomGroup.selectAtoms(selection[,selection[,...]], [groupname=atomgroup[,groupname=atomgroup[,...]]])</span>

<span class="sd">        .. SeeAlso:: :meth:`Universe.selectAtoms`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">Selection</span>  <span class="c"># can ONLY import in method, otherwise cyclical import!</span>

        <span class="n">atomgrp</span> <span class="o">=</span> <span class="n">Selection</span><span class="o">.</span><span class="n">Parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">sel</span><span class="p">,</span> <span class="n">selgroups</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">othersel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">atomgrp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Generate a selection for each selection string</span>
            <span class="c">#atomselections = [atomgrp]</span>
            <span class="k">for</span> <span class="n">sel</span> <span class="ow">in</span> <span class="n">othersel</span><span class="p">:</span>
                <span class="n">atomgrp</span> <span class="o">=</span> <span class="n">atomgrp</span> <span class="o">+</span> <span class="n">Selection</span><span class="o">.</span><span class="n">Parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">sel</span><span class="p">,</span> <span class="n">selgroups</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="c">#atomselections.append(Selection.Parser.parse(sel).apply(self))</span>
            <span class="c">#return tuple(atomselections)</span>
            <span class="k">return</span> <span class="n">atomgrp</span>
</div>
<div class="viewcode-block" id="AtomGroup.split"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.split">[docs]</a>    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Split atomgroup into a list of atomgroups by *level*.</span>

<span class="sd">        *level* can be &quot;atom&quot;, &quot;residue&quot;, &quot;segment&quot;.</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># CHECK: What happens to duplicate atoms (with advanced slicing)?</span>

        <span class="n">accessors</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;segment&#39;</span><span class="p">:</span> <span class="s">&#39;segid&#39;</span><span class="p">,</span> <span class="s">&#39;segid&#39;</span><span class="p">:</span> <span class="s">&#39;segid&#39;</span><span class="p">,</span>
                     <span class="s">&#39;residue&#39;</span><span class="p">:</span> <span class="s">&#39;resid&#39;</span><span class="p">,</span> <span class="s">&#39;resid&#39;</span><span class="p">:</span> <span class="s">&#39;resid&#39;</span><span class="p">,</span>
                     <span class="p">}</span>

        <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="s">&quot;atom&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">([</span><span class="n">a</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

        <span class="c"># more complicated groupings</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># use own list comprehension to avoid sorting/compression by eg self.resids()</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">accessors</span><span class="p">[</span><span class="n">level</span><span class="p">])</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;level = &#39;{0}&#39; not supported, must be one of {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">level</span><span class="p">,</span> <span class="n">accessors</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="c"># now sort the resids so that it doesn&#39;t matter if the AG contains</span>
        <span class="c"># atoms in random order (i.e. non-sequential resids); groupby needs</span>
        <span class="c"># presorted keys!</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
        <span class="n">sorted_ids</span> <span class="o">=</span> <span class="n">ids</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="c"># group (index, key) and then pull out the index for each group to form AtomGroups</span>
        <span class="c"># by indexing self (using advanced slicing eg g[[1,2,3]]</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="p">[[</span><span class="n">idx_k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx_k</span> <span class="ow">in</span> <span class="n">groupings</span><span class="p">]]</span>  <span class="c"># one AtomGroup for each residue or segment</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">groupings</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">sorted_ids</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">]</span>
        <span class="k">return</span> <span class="n">groups</span>
</div>
<div class="viewcode-block" id="AtomGroup.write"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&quot;PDB&quot;</span><span class="p">,</span>
              <span class="n">filenamefmt</span><span class="o">=</span><span class="s">&quot;</span><span class="si">%(trjname)s</span><span class="s">_</span><span class="si">%(frame)d</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write AtomGroup to a file.</span>

<span class="sd">        AtomGroup.write(filename[,format])</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *filename*</span>
<span class="sd">               ``None``: create TRJNAME_FRAME.FORMAT from filenamefmt [``None``]</span>
<span class="sd">          *format*</span>
<span class="sd">                PDB, CRD, GRO, VMD (tcl), PyMol (pml), Gromacs (ndx) CHARMM (str);</span>
<span class="sd">                case-insensitive and can also be supplied as the filename</span>
<span class="sd">                extension [PDB]</span>
<span class="sd">          *filenamefmt*</span>
<span class="sd">                format string for default filename; use substitution tokens</span>
<span class="sd">                &#39;trjname&#39; and &#39;frame&#39; [&quot;%(trjname)s_%(frame)d&quot;]</span>
<span class="sd">          *bonds*</span>
<span class="sd">                how to handle bond information, especially relevant for PDBs;</span>
<span class="sd">                default is ``&quot;conect&quot;``.</span>

<span class="sd">                * ``&quot;conect&quot;``: write only the CONECT records defined in the original</span>
<span class="sd">                  file</span>

<span class="sd">                * ``&quot;all&quot;``: write out all bonds, both the original defined and those</span>
<span class="sd">                  guessed by MDAnalysis</span>

<span class="sd">                * ``None``: do not write out bonds</span>

<span class="sd">        .. versionchanged:: 0.9.0</span>
<span class="sd">           Merged with write_selection.  This method can now write both</span>
<span class="sd">           selections out.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">MDAnalysis.coordinates</span>
        <span class="kn">import</span> <span class="nn">MDAnalysis.selections</span>

        <span class="n">trj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span>  <span class="c"># unified trajectory API</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">trj</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">frame</span>

        <span class="k">if</span> <span class="n">trj</span><span class="o">.</span><span class="n">numframes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&quot;multiframe&quot;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">trjname</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">trj</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">filenamefmt</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">()</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">filename</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">format</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">keep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># From the following blocks, one must pass.</span>
        <span class="c"># Both can&#39;t pass as the extensions don&#39;t overlap.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">writer</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">pass</span>  <span class="c"># might be selections format</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">SelectionWriter</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">selections</span><span class="o">.</span><span class="n">get_writer</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">format</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">NotImplementedError</span><span class="p">):</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">writer</span> <span class="o">=</span> <span class="n">SelectionWriter</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">coords</span> <span class="ow">or</span> <span class="n">selection</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;No writer found for format: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">coords</span><span class="p">:</span>  <span class="c"># only these writers have a close method</span>
                <span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c"># TODO: This is _almost_ the same code as write() --- should unify!</span></div>
<div class="viewcode-block" id="AtomGroup.write_selection"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.write_selection">[docs]</a>    <span class="k">def</span> <span class="nf">write_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&quot;vmd&quot;</span><span class="p">,</span> <span class="n">filenamefmt</span><span class="o">=</span><span class="s">&quot;</span><span class="si">%(trjname)s</span><span class="s">_</span><span class="si">%(frame)d</span><span class="s">&quot;</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write AtomGroup selection to a file to be used in another programme.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *filename*</span>
<span class="sd">                ``None``: create TRJNAME_FRAME.FORMAT from *filenamefmt*</span>
<span class="sd">          *format*</span>
<span class="sd">                output file format: VMD (tcl), PyMol (pml), Gromacs (ndx), CHARMM (str);</span>
<span class="sd">                can also be supplied as the filename extension. Case insensitive. [vmd]</span>
<span class="sd">          *filenamefmt*</span>
<span class="sd">                format string for default filename; use &#39;%(trjname)s&#39; and &#39;%(frame)s&#39;</span>
<span class="sd">                placeholders; the extension is set according to the *format*</span>
<span class="sd">                [&quot;%(trjname)s_%(frame)d&quot;]</span>
<span class="sd">          *kwargs*</span>
<span class="sd">                additional keywords are passed on to the appropriate</span>
<span class="sd">                :class:`~MDAnalysis.selections.base.SelectionWriter`</span>

<span class="sd">        .. deprecated:: 0.9.0</span>
<span class="sd">           Use :meth:`write`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">MDAnalysis.selections</span>

        <span class="n">SelectionWriter</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">selections</span><span class="o">.</span><span class="n">get_writer</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">format</span><span class="p">)</span>

        <span class="n">trj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span>  <span class="c"># unified trajectory API</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">trj</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">frame</span>

        <span class="c"># get actual extension from the static class attribute</span>
        <span class="n">extension</span> <span class="o">=</span> <span class="n">SelectionWriter</span><span class="o">.</span><span class="n">ext</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">trjname</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">trj</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">filenamefmt</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">()</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">filename</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">extension</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="n">writer</span> <span class="o">=</span> <span class="n">SelectionWriter</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>  <span class="c"># wants a atomgroup</span>

    <span class="c"># properties</span></div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dimensions of the Universe to which the group belongs, at the current time step.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">dimensions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;This AtomGroup does not belong to a Universe with a dimension.&quot;</span><span class="p">)</span>

    <span class="nd">@dimensions.setter</span>
<div class="viewcode-block" id="AtomGroup.dimensions"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.dimensions">[docs]</a>    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pass on to Universe setter</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="n">box</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AtomGroup.ts"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.ts">[docs]</a>    <span class="k">def</span> <span class="nf">ts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Temporary Timestep that contains the selection coordinates.</span>

<span class="sd">        A :class:`~MDAnalysis.coordinates.base.Timestep` instance,</span>
<span class="sd">        which can be passed to a trajectory writer.</span>

<span class="sd">        If :attr:`~AtomGroup.ts` is modified then these modifications</span>
<span class="sd">        will be present until the frame number changes (which</span>
<span class="sd">        typically happens when the underlying trajectory frame</span>
<span class="sd">        changes).</span>

<span class="sd">        It is not possible to assign a new</span>
<span class="sd">        :class:`~MDAnalysis.coordinates.base.Timestep` to the</span>
<span class="sd">        :attr:`AtomGroup.ts` attribute; change attributes of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trj_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>  <span class="c"># original time step</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ts</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ts</span><span class="o">.</span><span class="n">frame</span> <span class="o">!=</span> <span class="n">trj_ts</span><span class="o">.</span><span class="n">frame</span><span class="p">:</span>
            <span class="c"># create a timestep of same type as the underlying trajectory</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ts</span> <span class="o">=</span> <span class="n">trj_ts</span><span class="o">.</span><span class="n">copy_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ts</span>

</div></div>
<div class="viewcode-block" id="Residue"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Residue">[docs]</a><span class="k">class</span> <span class="nc">Residue</span><span class="p">(</span><span class="n">AtomGroup</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A group of atoms corresponding to a residue.</span>

<span class="sd">    Pythonic access to atoms:</span>
<span class="sd">      - Using a atom name as attribute returns the matching atom (a</span>
<span class="sd">        :class:`Atom` instance), i.e. ``r.name``. Example::</span>

<span class="sd">          &gt;&gt;&gt; from MDAnalysis.tests.datafiles import PSF,DCD</span>
<span class="sd">          &gt;&gt;&gt; u = Universe(PSF,DCD)</span>
<span class="sd">          &gt;&gt;&gt; print(u.s4AKE.r1.CA)  # C-alpha of M1</span>
<span class="sd">          &lt; Atom 5: name &#39;CA&#39; of type &#39;22&#39; of resname &#39;MET&#39;, resid 1 and segid &#39;4AKE&#39;&gt;</span>

<span class="sd">      - ``r[&#39;name&#39;]`` or ``r[id]`` - returns the atom corresponding to that name</span>

<span class="sd">    :Data:</span>
<span class="sd">      :attr:`Residue.name`</span>
<span class="sd">        Three letter residue name.</span>
<span class="sd">      :attr:`Residue.id`</span>
<span class="sd">        Numeric (integer) resid, taken from the topology.</span>
<span class="sd">      :attr:`Residue.resnum`</span>
<span class="sd">        Numeric canonical residue id (e.g. as used in the PDB structure).</span>

<span class="sd">    .. Note::</span>

<span class="sd">       Creating a :class:`Residue` modifies the underlying :class:`Atom`</span>
<span class="sd">       instances. Each :class:`Atom` can only belong to a single</span>
<span class="sd">       :class:`Residue`.</span>

<span class="sd">    .. versionchanged:: 0.7.4</span>
<span class="sd">       Added :attr:`Residue.resnum` attribute and *resnum* keyword argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">## FIXME (see below, Issue 70)</span>
    <span class="c">##_cache = {}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">resnum</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Residue</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span>
        <span class="k">if</span> <span class="n">resnum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resnum</span> <span class="o">=</span> <span class="n">resnum</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resnum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span>  <span class="c"># TODO: get resnum from topologies that support it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segment</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
            <span class="n">a</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">a</span><span class="o">.</span><span class="n">resnum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resnum</span>
            <span class="n">a</span><span class="o">.</span><span class="n">residue</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cls</span> <span class="o">=</span> <span class="n">AtomGroup</span>
        <span class="c"># Should I cache the positions of atoms within a residue?</span>
        <span class="c"># FIXME: breaks when termini are used to populate the cache; termini typically</span>
        <span class="c">#        have the SAME residue name but different atoms!!! Issue 70</span>
        <span class="c">##if not Residue._cache.has_key(name):</span>
        <span class="c">##    Residue._cache[name] = dict([(a.name, i) for i, a in enumerate(self._atoms)])</span>

<div class="viewcode-block" id="Residue.phi_selection"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Residue.phi_selection">[docs]</a>    <span class="k">def</span> <span class="nf">phi_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;AtomGroup corresponding to the phi protein backbone dihedral C&#39;-N-CA-C.</span>

<span class="sd">        :Returns: 4-atom selection in the correct order.  If no C&#39;</span>
<span class="sd">                  found in the previous residue (by resid) then this</span>
<span class="sd">                  method returns ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">selectAtoms</span><span class="p">(</span>
            <span class="s">&#39;segid </span><span class="si">%s</span><span class="s"> and resid </span><span class="si">%d</span><span class="s"> and name C&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> \
              <span class="bp">self</span><span class="p">[</span><span class="s">&#39;N&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;CA&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;C&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>  <span class="c"># selectAtoms doesnt raise errors if nothing found, so check size</span>
            <span class="k">return</span> <span class="n">sel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="Residue.psi_selection"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Residue.psi_selection">[docs]</a>    <span class="k">def</span> <span class="nf">psi_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;AtomGroup corresponding to the psi protein backbone dihedral N-CA-C-N&#39;.</span>

<span class="sd">        :Returns: 4-atom selection in the correct order.  If no N&#39;</span>
<span class="sd">                  found in the following residue (by resid) then this</span>
<span class="sd">                  method returns ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;N&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;CA&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;C&#39;</span><span class="p">]</span> <span class="o">+</span> \
              <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">selectAtoms</span><span class="p">(</span>
                  <span class="s">&#39;segid </span><span class="si">%s</span><span class="s"> and resid </span><span class="si">%d</span><span class="s"> and name N&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="Residue.omega_selection"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Residue.omega_selection">[docs]</a>    <span class="k">def</span> <span class="nf">omega_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;AtomGroup corresponding to the omega protein backbone dihedral CA-C-N&#39;-CA&#39;.</span>

<span class="sd">        omega describes the -C-N- peptide bond. Typically, it is trans</span>
<span class="sd">        (180 degrees) although cis-bonds (0 degrees) are also</span>
<span class="sd">        occasionally observed (especially near Proline).</span>

<span class="sd">        :Returns: 4-atom selection in the correct order.  If no C&#39;</span>
<span class="sd">                  found in the previous residue (by resid) then this</span>
<span class="sd">                  method returns ``None``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nextres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">segid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">id</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;CA&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;C&#39;</span><span class="p">]</span> <span class="o">+</span> \
              <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">selectAtoms</span><span class="p">(</span>
                  <span class="s">&#39;segid </span><span class="si">%s</span><span class="s"> and resid </span><span class="si">%d</span><span class="s"> and name N&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">segid</span><span class="p">,</span> <span class="n">nextres</span><span class="p">),</span>
                  <span class="s">&#39;segid </span><span class="si">%s</span><span class="s"> and resid </span><span class="si">%d</span><span class="s"> and name CA&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">segid</span><span class="p">,</span> <span class="n">nextres</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="Residue.chi1_selection"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Residue.chi1_selection">[docs]</a>    <span class="k">def</span> <span class="nf">chi1_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;AtomGroup corresponding to the chi1 sidechain dihedral N-CA-CB-CG.</span>

<span class="sd">        :Returns: 4-atom selection in the correct order.  If no CB and/or CG is</span>
<span class="sd">                  found then this method returns ``None``.</span>

<span class="sd">        .. versionadded:: 0.7.5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;N&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;CA&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;CB&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;CG&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">SelectionError</span><span class="p">,</span> <span class="n">NoDataError</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&lt;Residue {name}, {id}&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ResidueGroup"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.ResidueGroup">[docs]</a><span class="k">class</span> <span class="nc">ResidueGroup</span><span class="p">(</span><span class="n">AtomGroup</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A group of residues.</span>

<span class="sd">    Pythonic access to atoms:</span>
<span class="sd">      - Using a atom name as attribute returns a list of all atoms (a</span>
<span class="sd">        :class:`AtomGroup`) of the same name. Example::</span>

<span class="sd">          &gt;&gt;&gt; from MDAnalysis.tests.datafiles import PSF,DCD</span>
<span class="sd">          &gt;&gt;&gt; u = Universe(PSF,DCD)</span>
<span class="sd">          &gt;&gt;&gt; print(u.s4AKE.MET.CA)  # C-alpha of all Met</span>
<span class="sd">          &lt;AtomGroup with 6 atoms&gt;</span>

<span class="sd">    :Data: :attr:`ResidueGroup._residues`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_containername</span> <span class="o">=</span> <span class="s">&quot;_residues&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">residues</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the ResidueGroup with a list of :class:`Residue` instances.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_residues</span> <span class="o">=</span> <span class="n">residues</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">residues</span><span class="p">:</span>
            <span class="n">atoms</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ResidueGroup</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span>

    <span class="k">def</span> <span class="nf">_set_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set attribute *name* to *value* for all residues in the :class:`ResidueGroup`.</span>

<span class="sd">        If *value* is a sequence of the same length as the</span>
<span class="sd">        :class:`ResidueGroup` (:attr:`AtomGroup.residues`) then each</span>
<span class="sd">        :class:`Residue`&#39;s property *name* is set to the corresponding</span>
<span class="sd">        value. If *value* is neither of length 1 (or a scalar) nor of the</span>
<span class="sd">        length of the :class:`ResidueGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. versionadded:: 0.7.5</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">asiterable</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_atoms</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
                <span class="n">r</span><span class="o">.</span><span class="n">_set_atoms</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;set_residues: can only set all atoms to a single value or each atom to a distinct one &quot;</span>
                             <span class="s">&quot;but len(residues)={0} whereas len(value)={1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)))</span>

        <span class="c"># also fix self --- otherwise users will get confused if the changes are not reflected in the</span>
        <span class="c"># object they are currently using (it works automatically for AtomGroup but not higher order groups)</span>
        <span class="c">#</span>
        <span class="c"># This is a hack to be able to set properties on Atom and Residue</span>
        <span class="c"># instances where they have different names</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;resname&#39;</span><span class="p">:</span> <span class="s">&#39;name&#39;</span><span class="p">,</span>
            <span class="s">&#39;resid&#39;</span><span class="p">:</span> <span class="s">&#39;id&#39;</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">,</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">values</span><span class="p">)):</span>
            <span class="n">attrname</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">attrname</span><span class="p">):</span>  <span class="c"># should use __slots__ on Residue and try/except here</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">attrname</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nb">set</span> <span class="o">=</span> <span class="n">_set_residues</span>

<div class="viewcode-block" id="ResidueGroup.set_resid"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.ResidueGroup.set_resid">[docs]</a>    <span class="k">def</span> <span class="nf">set_resid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the resid to integer *resid* for **all residues** in the :class:`ResidueGroup`.</span>

<span class="sd">        If *resid* is a sequence of the same length as the :class:`ResidueGroup`</span>
<span class="sd">        then each :attr:`Atom.resid` is set to the corresponding value together</span>
<span class="sd">        with the :attr:`Residue.id` of the residue the atom belongs to. If</span>
<span class="sd">        *value* is neither of length 1 (or a scalar) nor of the length of the</span>
<span class="sd">        :class:`AtomGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. Note::</span>

<span class="sd">           Changing resids can change the topology.</span>

<span class="sd">           Assigning the same *resid* to multiple residues will **merge** these</span>
<span class="sd">           residues. The new residue name will be the name of the first old</span>
<span class="sd">           residue in the merged residue.</span>

<span class="sd">        .. Warning::</span>

<span class="sd">           The values of *this* :class:`ResidueGroup` are not being</span>
<span class="sd">           changed. You **must create a new** :class:`ResidueGroup` **from the**</span>
<span class="sd">           :class:`Universe` --- only :class:`Atom` instances are changed,</span>
<span class="sd">           everything else is derived from these atoms.</span>

<span class="sd">        .. versionadded:: 0.8</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">MDAnalysis.topology.core</span> <span class="kn">import</span> <span class="n">build_residues</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;resid&#39;</span><span class="p">,</span> <span class="n">resid</span><span class="p">)</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="n">build_residues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="c"># update THIS residue group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="o">.</span><span class="n">_residues</span> <span class="o">=</span> <span class="n">residues</span>
        <span class="c"># make sure to update the whole universe: the Atoms are shared but ResidueGroups are not</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">_fill_cache</span><span class="p">(</span><span class="s">&#39;residues&#39;</span><span class="p">,</span> <span class="n">build_residues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="ResidueGroup.set_resnum"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.ResidueGroup.set_resnum">[docs]</a>    <span class="k">def</span> <span class="nf">set_resnum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resnum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the resnum to *resnum* for **all residues** in the :class:`ResidueGroup`.</span>

<span class="sd">        If *resnum* is a sequence of the same length as the :class:`ResidueGroup`</span>
<span class="sd">        then each :attr:`Atom.resnum` is set to the corresponding value together</span>
<span class="sd">        with the :attr:`Residue.resnum` of the residue the atom belongs to. If</span>
<span class="sd">        *value* is neither of length 1 (or a scalar) nor of the length of the</span>
<span class="sd">        :class:`AtomGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. Note::</span>

<span class="sd">           Changing *resnum* will not affect the topology: you can have</span>
<span class="sd">           multiple residues with the same *resnum*.</span>

<span class="sd">        .. SeeAlso:: :meth:`set_resid`</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.7.5</span>
<span class="sd">           Also changes the residues.</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;resnum&quot;</span><span class="p">,</span> <span class="n">resnum</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ResidueGroup.set_resname"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.ResidueGroup.set_resname">[docs]</a>    <span class="k">def</span> <span class="nf">set_resname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the resname to string *resname* for **all residues** in the :class:`ResidueGroup`.</span>

<span class="sd">        If *resname* is a sequence of the same length as the :class:`ResidueGroup`</span>
<span class="sd">        then each :attr:`Atom.resname` is set to the corresponding value together</span>
<span class="sd">        with the :attr:`Residue.name` of the residue the atom belongs to. If</span>
<span class="sd">        *value* is neither of length 1 (or a scalar) nor of the length of the</span>
<span class="sd">        :class:`AtomGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.7.5</span>
<span class="sd">           Also changes the residues.</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;resname&quot;</span><span class="p">,</span> <span class="n">resname</span><span class="p">,</span> <span class="n">conversion</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>

    <span class="c"># All other AtomGroup.set_xxx() methods should just work as</span>
    <span class="c"># ResidueGroup.set_xxx() because we overrode self.set(); the ones above</span>
    <span class="c"># where kept separate because we can save a call to build_residues()</span>
    <span class="c"># because there is no ambiguity as which residues are changed.</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&lt;ResidueGroup {res}&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">res</span><span class="o">=</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_residues</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="Segment"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Segment">[docs]</a><span class="k">class</span> <span class="nc">Segment</span><span class="p">(</span><span class="n">ResidueGroup</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A group of residues corresponding to one segment of the topology.</span>

<span class="sd">    Pythonic access to residues:</span>

<span class="sd">      - The attribute rN returns the N-th residue :class:`Residue` of the</span>
<span class="sd">        segment (numbering starts at N=1). Example::</span>

<span class="sd">          &gt;&gt;&gt; from MDAnalysis.tests.datafiles import PSF,DCD</span>
<span class="sd">          &gt;&gt;&gt; u = Universe(PSF,DCD)</span>
<span class="sd">          &gt;&gt;&gt; print(u.s4AKE.r1)</span>
<span class="sd">          &lt;Residue &#39;MET&#39;, 1&gt;</span>

<span class="sd">      - Using a residue name as attribute returns a list of all residues (a</span>
<span class="sd">        :class:`ResidueGroup`) of the same name. Example::</span>

<span class="sd">          &gt;&gt;&gt; from MDAnalysis.tests.datafiles import PSF,DCD</span>
<span class="sd">          &gt;&gt;&gt; u = Universe(PSF,DCD)</span>
<span class="sd">          &gt;&gt;&gt; print(u.s4AKE.CYS)</span>
<span class="sd">          &lt;ResidueGroup [&lt;Residue &#39;CYS&#39;, 77&gt;]&gt;</span>
<span class="sd">          &gt;&gt;&gt; print(u.s4AKE.MET)</span>
<span class="sd">          &lt;ResidueGroup [&lt;Residue &#39;MET&#39;, 1&gt;, &lt;Residue &#39;MET&#39;, 21&gt;, &lt;Residue &#39;MET&#39;, 34&gt;, &lt;Residue &#39;MET&#39;, 53&gt;,</span>
<span class="sd">          &lt;Residue &#39;MET&#39;, 96&gt;, &lt;Residue &#39;MET&#39;, 174&gt;]&gt;</span>

<span class="sd">    :Data: :attr:`Segment.name` is the segid from the topology or the</span>
<span class="sd">           chain identifier when loaded from a PDB</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">residues</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a Segment with segid *name* from a list of :class:`Residue` instances.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Segment</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">residues</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_residues</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">segment</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                <span class="n">atom</span><span class="o">.</span><span class="n">segment</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cls</span> <span class="o">=</span> <span class="n">ResidueGroup</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Segment id (alias for :attr:`Segment.name`)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="nd">@id.setter</span>
<div class="viewcode-block" id="Segment.id"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Segment.id">[docs]</a>    <span class="k">def</span> <span class="nf">id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">x</span>
</div>
    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">attr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;r&#39;</span><span class="p">:</span>
            <span class="n">resnum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">attr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c"># 1-based for the user, 0-based internally</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">resnum</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># There can be multiple residues with the same name</span>
            <span class="n">r</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_residues</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">attr</span><span class="p">):</span>
                    <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Segment</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__getattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
            <span class="c"># elif (len(r) == 1): return r[0]  ## creates unexpected behaviour (Issue 47)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ResidueGroup</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&lt;Segment {name}&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="SegmentGroup"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.SegmentGroup">[docs]</a><span class="k">class</span> <span class="nc">SegmentGroup</span><span class="p">(</span><span class="n">ResidueGroup</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A group of segments.</span>

<span class="sd">    Pythonic access to segments:</span>
<span class="sd">      - Using a segid as attribute returns the segment. Because</span>
<span class="sd">        of python language rule, any segid starting with a non-letter</span>
<span class="sd">        character is prefixed with &#39;s&#39;, thus &#39;4AKE&#39; --&gt; &#39;s4AKE&#39;.</span>

<span class="sd">        Example::</span>

<span class="sd">          &gt;&gt;&gt; from MDAnalysis.tests.datafiles import PSF,DCD</span>
<span class="sd">          &gt;&gt;&gt; u = Universe(PSF,DCD)</span>
<span class="sd">          &gt;&gt;&gt; print(u.atoms.segments.s4AKE)  # segment 4AKE</span>
<span class="sd">          &lt;AtomGroup with 3314 atoms&gt;</span>

<span class="sd">      - Indexing the group returns the appropriate segment.</span>

<span class="sd">    :Data: :attr:`SegmentGroup._segments`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_containername</span> <span class="o">=</span> <span class="s">&quot;_segments&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segments</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the SegmentGroup with a list of :class:`Segment` instances.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_segments</span> <span class="o">=</span> <span class="n">segments</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
            <span class="n">residues</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">residues</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SegmentGroup</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">residues</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span>

    <span class="k">def</span> <span class="nf">_set_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set attribute *name* to *value* for all :class:`Segment` in this :class:`AtomGroup`.</span>

<span class="sd">        If *value* is a sequence of the same length as the</span>
<span class="sd">        :class:`SegmentGroup` (:attr:`AtomGroup.residues`) then each</span>
<span class="sd">        :class:`Segment`&#39;s property *name* is set to the corresponding</span>
<span class="sd">        value. If *value* is neither of length 1 (or a scalar) nor of the</span>
<span class="sd">        length of the :class:`SegmentGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. versionadded:: 0.8</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">asiterable</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_atoms</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
                <span class="n">s</span><span class="o">.</span><span class="n">_set_atoms</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;set_segments: can only set all atoms to a single value or each atom to a distinct one &quot;</span>
                             <span class="s">&quot;but len(segments)={0} whereas len(value)={1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)))</span>

    <span class="nb">set</span> <span class="o">=</span> <span class="n">_set_segments</span>

<div class="viewcode-block" id="SegmentGroup.set_segid"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.SegmentGroup.set_segid">[docs]</a>    <span class="k">def</span> <span class="nf">set_segid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segid</span><span class="p">,</span> <span class="n">buildsegments</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the segid to *segid* for all atoms in the :class:`SegmentGroup`.</span>

<span class="sd">        If *segid* is a sequence of the same length as the :class:`SegmentGroup`</span>
<span class="sd">        then each :attr:`Atom.segid` is set to the corresponding value together</span>
<span class="sd">        with the :attr:`Segment.id` of the segment the atom belongs to. If</span>
<span class="sd">        *value* is neither of length 1 (or a scalar) nor of the length of the</span>
<span class="sd">        :class:`AtomGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. Note::</span>

<span class="sd">           :meth:`set_segid` can change the topology.</span>

<span class="sd">           With the default *buildsegments* = ``True`` it can be used to join</span>
<span class="sd">           segments or to break groups into multiple disjoint segments. Note</span>
<span class="sd">           that each :class:`Atom` can only belong to a single</span>
<span class="sd">           :class:`Segment`.</span>

<span class="sd">        For performance reasons, *buildsegments* can be set to ``False``. Then</span>
<span class="sd">        one needs to run :meth:`Universe._build_segments` manually later in</span>
<span class="sd">        order to update the list of :class:`Segment` instances and regenerate</span>
<span class="sd">        the segid instant selectors.</span>

<span class="sd">        .. Warning::</span>

<span class="sd">           The values of *this* :class:`SegmentGroup` are not being changed</span>
<span class="sd">           (i.e. if you assign multiple segids this instance will not be broken</span>
<span class="sd">           in multiple segments, rather you will have one :class:`SegmentGroup`</span>
<span class="sd">           that groups multiple segments together). You **must create a new**</span>
<span class="sd">           :class:`SegmentGroup` **from the** :class:`Universe` --- only</span>
<span class="sd">           :class:`Atom` instances are changed, everything else is derived from</span>
<span class="sd">           these atoms.</span>


<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SegmentGroup</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_segid</span><span class="p">(</span><span class="n">segid</span><span class="p">,</span> <span class="n">buildsegments</span><span class="o">=</span><span class="n">buildsegments</span><span class="p">)</span>

        <span class="c"># Is the following needed? -- orbeckst</span>
        <span class="c"># also fix self --- otherwise users will get confused if the changes are not reflected in the</span>
        <span class="c"># object they are currently using (it works automatically for AtomGroup but not higher order groups)</span>
        <span class="c">#</span>
        <span class="c"># This is a hack to be able to set properties on Segment/Atom</span>
        <span class="c"># instances where they have different names</span>
        <span class="c">#attr = {&#39;segid&#39;: &#39;id&#39;}</span>
        <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">,</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">asiterable</span><span class="p">(</span><span class="n">segid</span><span class="p">))):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;s&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">attr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="n">attr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c"># sNxxx only used for python, the name is stored without s-prefix</span>
        <span class="n">seglist</span> <span class="o">=</span> <span class="p">[</span><span class="n">segment</span> <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_segments</span> <span class="k">if</span> <span class="n">segment</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">attr</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seglist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SegmentGroup</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__getattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seglist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;SegmentGroup: Multiple segments with the same name {0};&quot;</span>
                          <span class="s">&quot; a combined, NON-CONSECUTIVE &quot;</span>
                          <span class="s">&quot;Segment is returned.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">attr</span><span class="p">),</span> <span class="n">category</span><span class="o">=</span><span class="n">SelectionWarning</span><span class="p">)</span>
            <span class="c">#return Segment(sum([s.residues for s in seglist])) ### FIXME: not working yet, need __add__</span>
            <span class="k">return</span> <span class="n">seglist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">seglist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&lt;SegmentGroup {segnames}&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">segnames</span><span class="o">=</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_segments</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="Universe"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Universe">[docs]</a><span class="k">class</span> <span class="nc">Universe</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The MDAnalysis Universe contains all the information describing the system.</span>

<span class="sd">    The system always requires a *topology* file --- in the simplest case just</span>
<span class="sd">    a list of atoms. This can be a CHARMM/NAMD PSF file or a simple coordinate</span>
<span class="sd">    file with atom informations such as XYZ, PDB, Gromacs GRO, or CHARMM CRD. See</span>
<span class="sd">    :ref:`Supported topology formats` for what kind of topologies can be read.</span>

<span class="sd">    A trajectory provides coordinates; the coordinates have to be ordered in</span>
<span class="sd">    the same way as the list of atoms in the topology. A trajectory can be a</span>
<span class="sd">    single frame such as a PDB, CRD, or GRO file, or it can be a MD trajectory</span>
<span class="sd">    (in CHARMM/NAMD/LAMMPS DCD, Gromacs XTC/TRR, or generic XYZ format).  See</span>
<span class="sd">    :ref:`Supported coordinate formats` for what can be read as a</span>
<span class="sd">    &quot;trajectory&quot;.</span>

<span class="sd">    As a special case, when the topology is a XYZ, PDB, GRO or CRD file</span>
<span class="sd">    then the coordinates are immediately loaded from the &quot;topology&quot;</span>
<span class="sd">    file unless a trajectory is supplied.</span>

<span class="sd">    Examples for setting up a universe::</span>

<span class="sd">       u = Universe(topology, trajectory)          # read system from file(s)</span>
<span class="sd">       u = Universe(pdbfile)                       # read atoms and coordinates from PDB or GRO</span>
<span class="sd">       u = Universe(topology, [traj1, traj2, ...]) # read from a list of trajectories</span>
<span class="sd">       u = Universe(topology, traj1, traj2, ...)   # read from multiple trajectories</span>

<span class="sd">    Load new data into a universe (replaces old trajectory and does *not* append)::</span>

<span class="sd">       u.load_new(trajectory)                      # read from a new trajectory file</span>

<span class="sd">    Select atoms, with syntax similar to CHARMM (see</span>
<span class="sd">    :class:`~Universe.selectAtoms` for details)::</span>

<span class="sd">       u.selectAtoms(...)</span>

<span class="sd">    *Attributes:*</span>

<span class="sd">    - :attr:`Universe.trajectory`: currently loaded trajectory reader;</span>
<span class="sd">      :attr:`Universe.trajectory.ts` is the current time step</span>
<span class="sd">    - :attr:`Universe.dimensions`: current system dimensions (simulation unit cell, if</span>
<span class="sd">      set in the trajectory)</span>
<span class="sd">    - :attr:`Universe.bonds`: TopologyGroup of bonds in Universe, also</span>
<span class="sd">      :attr:`Universe.angles`, :attr:`Universe.dihedrals`, and :attr:`Universe.impropers`</span>
<span class="sd">      (low level access through :attr:`Universe._topology`)</span>

<span class="sd">    .. Note::</span>

<span class="sd">       If atom attributes such as element, mass, or charge are not explicitly</span>
<span class="sd">       provided in the topology file then MDAnalysis tries to guess them (see</span>
<span class="sd">       :mod:`MDAnalysis.topology.tables`). This does not always work and if you</span>
<span class="sd">       require correct values (e.g. because you want to calculate the center of</span>
<span class="sd">       mass) then you need to make sure that MDAnalysis gets all the</span>
<span class="sd">       information needed.</span>

<span class="sd">    .. versionchanged:: 0.7.5</span>
<span class="sd">       Can also read multi-frame PDB files with the</span>
<span class="sd">       :class:`~MDAnalysis.coordinates.PDB.PrimitivePDBReader`.</span>

<span class="sd">    .. versionchanged:: 0.8</span>
<span class="sd">       Parse arbitrary number of arguments as a single topology file and a a sequence</span>
<span class="sd">       of trajectories.</span>

<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Topology information now loaded lazily, but can be forced with</span>
<span class="sd">       :meth:`build_topology`</span>
<span class="sd">       Changed .bonds attribute to be a :class:`~MDAnalysis.topology.core.TopologyGroup`</span>
<span class="sd">       Added .angles and .torsions attribute as :class:`~MDAnalysis.topology.core.TopologyGroup`</span>
<span class="sd">       Added fragments to Universe cache</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the central MDAnalysis Universe object.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *topologyfile*</span>
<span class="sd">             A CHARMM/XPLOR PSF topology file, PDB file or Gromacs GRO file; used to define the</span>
<span class="sd">             list of atoms. If the file includes bond information, partial</span>
<span class="sd">             charges, atom masses, ... then these data will be available to</span>
<span class="sd">             MDAnalysis. A &quot;structure&quot; file (PSF, PDB or GRO, in the sense of a</span>
<span class="sd">             topology) is always required.</span>
<span class="sd">          *coordinatefile*</span>
<span class="sd">             A trajectory (such as CHARMM DCD, Gromacs XTC/TRR/GRO, XYZ, XYZ.bz2) or a PDB that</span>
<span class="sd">             will provide coordinates, possibly multiple frames.</span>
<span class="sd">             If a **list of filenames** is provided then they are sequentially read and appear</span>
<span class="sd">             as one single trajectory to the Universe. The list can contain different file</span>
<span class="sd">             formats.</span>

<span class="sd">             .. deprecated:: 0.8</span>
<span class="sd">                Do not use the *coordinatefile* keyword argument, just provide trajectories as</span>
<span class="sd">                positional arguments.</span>

<span class="sd">          *permissive*</span>
<span class="sd">             currently only relevant for PDB files: Set to ``True`` in order to ignore most errors</span>
<span class="sd">             and read typical MD simulation PDB files; set to ``False`` to read with the Bio.PDB reader,</span>
<span class="sd">             which can be useful for real Protein Databank PDB files. ``None``  selects the</span>
<span class="sd">             MDAnalysis default (which is set in :class:`MDAnalysis.core.flags`) [``None``]</span>
<span class="sd">          *topology_format*</span>
<span class="sd">             provide the file format of the topology file; ``None`` guesses it from the file</span>
<span class="sd">             extension [``None``]</span>
<span class="sd">             Can also pass a subclass of :class:`MDAnalysis.topology.base.TopologyReader`</span>
<span class="sd">             to define a custom reader to be used on the topology file.</span>
<span class="sd">          *format*</span>
<span class="sd">             provide the file format of the coordinate or trajectory file;</span>
<span class="sd">             ``None`` guesses it from the file extension. Note that this</span>
<span class="sd">             keyword has no effect if a list of file names is supplied because</span>
<span class="sd">             the &quot;chained&quot; reader has to guess the file format for each</span>
<span class="sd">             individual list member. [``None``]</span>
<span class="sd">             Can also pass a subclass of :class:`MDAnalysis.coordinates.base.Reader`</span>
<span class="sd">             to define a custom reader to be used on the trajectory file.</span>
<span class="sd">          *guess_bonds*</span>
<span class="sd">              Once Universe has been loaded, attempt to guess the connectivity</span>
<span class="sd">              between atoms.  This will populate the .bonds .angles and</span>
<span class="sd">              .torsions attributes of the Universe.</span>
<span class="sd">          *vdwradii*</span>
<span class="sd">              For use with *guess_bonds*. Supply a dict giving a vdwradii for each atom type</span>
<span class="sd">              which are used in guessing bonds.</span>


<span class="sd">        This routine tries to do the right thing:</span>

<span class="sd">        1. If a pdb/gro file is provided instead of a psf and no *coordinatefile*</span>
<span class="sd">           then the coordinates are taken from the first file. Thus you can load</span>
<span class="sd">           a functional universe with ::</span>

<span class="sd">              u = Universe(&#39;1ake.pdb&#39;)</span>

<span class="sd">           If you want to specify the coordinate file format yourself you can</span>
<span class="sd">           do so using the *format* keyword::</span>

<span class="sd">              u = Universe(&#39;1ake.ent1&#39;, format=&#39;pdb&#39;)</span>

<span class="sd">        2. If only a topology file without coordinate information is provided</span>
<span class="sd">           one will have to load coordinates manually using</span>
<span class="sd">           :meth:`Universe.load_new`. The file format of the topology file</span>
<span class="sd">           can be explicitly set with the *topology_format* keyword.</span>

<span class="sd">        .. versionchanged:: 0.7.4</span>
<span class="sd">           New *topology_format* and *format* parameters to override the file</span>
<span class="sd">           format detection.</span>
<span class="sd">        .. versionchanged:: 0.10.0</span>
<span class="sd">           Added ``&#39;guess_bonds&#39;`` keyword to cause topology to be guessed on</span>
<span class="sd">           Universe creation.</span>
<span class="sd">           Deprecated ``&#39;bonds&#39;`` keyword, use ``&#39;guess_bonds&#39;`` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..topology.core</span> <span class="kn">import</span> <span class="n">get_parser_for</span><span class="p">,</span> <span class="n">guess_format</span>
        <span class="kn">from</span> <span class="nn">..topology.base</span> <span class="kn">import</span> <span class="n">TopologyReader</span>

        <span class="c"># managed attribute holding Reader</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__trajectory</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># Cache is used to store objects which are built lazily into Universe</span>
        <span class="c"># Currently cached objects (managed property name and cache key):</span>
        <span class="c"># - bonds</span>
        <span class="c"># - angles</span>
        <span class="c"># - torsions</span>
        <span class="c"># - improper torsions</span>
        <span class="c"># - fragments</span>
        <span class="c"># Cached stuff is handled using util.cached decorator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># create an empty universe</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_topology</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="n">AtomGroup</span><span class="p">([])</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c"># old behaviour (explicit coordfile) overrides new behaviour</span>
        <span class="n">coordinatefile</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;coordinatefile&#39;</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">topology_format</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;topology_format&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">coordinatefile</span><span class="p">:</span>
            <span class="c"># special hacks to treat a coordinate file as a coordinate AND topology file</span>
            <span class="c"># coordinatefile can be None or () (from an empty slice args[1:])</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;format&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;format&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">topology_format</span>
            <span class="k">elif</span> <span class="n">topology_format</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">topology_format</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;format&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">guess_format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;format&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span> <span class="ow">in</span> \
                    <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">_topology_coordinates_readers</span><span class="p">:</span>
                <span class="n">coordinatefile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>  <span class="c"># hack for pdb/gro/crd - only</span>
            <span class="c"># Fix by SB: make sure coordinatefile is never an empty tuple</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coordinatefile</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">coordinatefile</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># build the topology (or at least a list of atoms)</span>
        <span class="k">try</span><span class="p">:</span>  <span class="c"># Try and check if the topology format is a TopologyReader</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">topology_format</span><span class="p">,</span> <span class="n">TopologyReader</span><span class="p">):</span>
                <span class="n">parser</span> <span class="o">=</span> <span class="n">topology_format</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c"># But strings/None raise TypeError in issubclass</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;permissive&#39;</span><span class="p">,</span>
                              <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s">&#39;permissive_pdb_reader&#39;</span><span class="p">])</span>
            <span class="n">parser</span> <span class="o">=</span> <span class="n">get_parser_for</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span>
                                    <span class="n">permissive</span><span class="o">=</span><span class="n">perm</span><span class="p">,</span>
                                    <span class="n">tformat</span><span class="o">=</span><span class="n">topology_format</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">parser</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">universe</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span> <span class="k">as</span> <span class="n">p</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_topology</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">parse</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&quot;Failed to load from the topology file {0}&quot;</span>
                          <span class="s">&quot; with parser {1}.</span><span class="se">\n</span><span class="s">&quot;</span>
                          <span class="s">&quot;Error: {2}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">err</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Failed to construct topology from file {0}&quot;</span>
                             <span class="s">&quot; with parser {1} </span><span class="se">\n</span><span class="s">&quot;</span>
                             <span class="s">&quot;Error: {2}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">err</span><span class="p">))</span>

        <span class="c"># Generate atoms, residues and segments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_topology</span><span class="p">()</span>

        <span class="c"># Load coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_new</span><span class="p">(</span><span class="n">coordinatefile</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c"># Deprecated bonds mode handling here, remove eventually.</span>
        <span class="k">if</span> <span class="s">&#39;bonds&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;The &#39;bonds&#39; keyword has been deprecated&quot;</span>
                          <span class="s">&quot; and will be removed in 0.11.0.&quot;</span>
                          <span class="s">&quot; Please use &#39;guess_bonds&#39; instead.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;bonds&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;all&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">]:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;guess_bonds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;guess_bonds&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">guess_bonds</span><span class="p">(</span><span class="n">vdwradii</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;vdwradii&#39;</span><span class="p">,</span><span class="bp">None</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_clear_caches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear cache for all *args*.</span>

<span class="sd">        If not args are provided, all caches are cleared.</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_fill_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Populate _cache[name] with value.</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_init_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Populate Universe attributes from the structure dictionary</span>
<span class="sd">        *_topology*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="n">AtomGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_topology</span><span class="p">[</span><span class="s">&#39;atoms&#39;</span><span class="p">])</span>

        <span class="c"># XXX: add H-bond information here if available from psf (or other sources)</span>
        <span class="c"># segment instant selectors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_segments</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_build_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse list of atoms into segments.</span>

<span class="sd">        * updates :attr:`Universe.atoms` as a side effect</span>
<span class="sd">        * updates :attr:`Universe.segments` and :attr:`Universe.residues`</span>
<span class="sd">        * creates the segid instant selectors</span>

<span class="sd">        Because of Python&#39;s syntax rules, attribute names cannot start with a</span>
<span class="sd">        digit and so we prefix any segments starting with a digit with the</span>
<span class="sd">        letter &#39;s&#39;. For instance, &#39;4AKE&#39; becomes the segid instant selector</span>
<span class="sd">        &#39;s4AKE&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">MDAnalysis.topology.core</span> <span class="kn">import</span> <span class="n">build_segments</span>

        <span class="n">segments</span> <span class="o">=</span> <span class="n">build_segments</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">segments</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                <span class="n">newsegname</span> <span class="o">=</span> <span class="s">&#39;s&#39;</span> <span class="o">+</span> <span class="n">seg</span>
                <span class="n">segments</span><span class="p">[</span><span class="n">newsegname</span><span class="p">]</span> <span class="o">=</span> <span class="n">segments</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>
        <span class="c"># convenience access to residues and segments (these are managed attributes</span>
        <span class="c"># (properties) and are built on the fly or read from a cache) -- does this</span>
        <span class="c"># create memory problems?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">segments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">residues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">residues</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span> <span class="o">=</span> <span class="bp">self</span>  <span class="c"># for Writer.write(universe), see Issue 49</span>

    <span class="k">def</span> <span class="nf">_init_top</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cat</span><span class="p">,</span> <span class="n">Top</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initiate a generic form of topology.</span>

<span class="sd">        Arguments:</span>
<span class="sd">          *cat*</span>
<span class="sd">            The key which will be searched in the _topology dict.</span>
<span class="sd">            The key &quot;guessed_&quot; + cat will also be searched.</span>
<span class="sd">          *Top*</span>
<span class="sd">            Class of the topology object to be created.</span>

<span class="sd">        .. versionadded:: 0.10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..topology.core</span> <span class="kn">import</span> <span class="n">TopologyGroup</span>

        <span class="n">defined</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
        <span class="n">guessed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;guessed_&#39;</span> <span class="o">+</span> <span class="n">cat</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>

        <span class="n">TopSet</span> <span class="o">=</span> <span class="n">TopologyGroup</span><span class="o">.</span><span class="n">from_indices</span><span class="p">(</span><span class="n">defined</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span>
                                            <span class="n">bondclass</span><span class="o">=</span><span class="n">Top</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                            <span class="n">remove_duplicates</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">TopSet</span> <span class="o">+=</span> <span class="n">TopologyGroup</span><span class="o">.</span><span class="n">from_indices</span><span class="p">(</span><span class="n">guessed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span>
                                             <span class="n">bondclass</span><span class="o">=</span><span class="n">Top</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                             <span class="n">remove_duplicates</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">TopSet</span>

    <span class="k">def</span> <span class="nf">_init_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set bond information from u._topology[&#39;bonds&#39;]</span>

<span class="sd">        .. versionchanged 0.9.0</span>
<span class="sd">           Now returns a :class:`~MDAnalysis.topology.core.TopologyGroup`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..topology.core</span> <span class="kn">import</span> <span class="n">Bond</span>

        <span class="n">bonds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_top</span><span class="p">(</span><span class="s">&#39;bonds&#39;</span><span class="p">,</span> <span class="n">Bond</span><span class="p">)</span>

        <span class="n">bondorder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;bondorder&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bondorder</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bonds</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">b</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">bondorder</span><span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="k">return</span> <span class="n">bonds</span>

    <span class="k">def</span> <span class="nf">_init_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Builds angle information from u._topology[&#39;angles&#39;]</span>

<span class="sd">        Returns ``None`` if no angle information is present, otherwise</span>
<span class="sd">        returns a :class:`~MDAnalysis.topology.core.TopologyGroup`</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        .. versionchanged:: 0.10.0</span>
<span class="sd">           Now reads guessed angles and tags them appropriately.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..topology.core</span> <span class="kn">import</span> <span class="n">Angle</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_top</span><span class="p">(</span><span class="s">&#39;angles&#39;</span><span class="p">,</span> <span class="n">Angle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_torsions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Builds torsion information from u._topology[&#39;torsions&#39;]</span>

<span class="sd">        Returns ``None`` if no torsion information is present, otherwise</span>
<span class="sd">        returns a :class:`~MDAnalysis.topology.core.TopologyGroup`</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        .. versionchanged:: 0.10.0</span>
<span class="sd">           Now reads guessed torsions and tags them appropriately.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..topology.core</span> <span class="kn">import</span> <span class="n">Torsion</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_top</span><span class="p">(</span><span class="s">&#39;torsions&#39;</span><span class="p">,</span> <span class="n">Torsion</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_impropers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build improper torsion information from u._topology[&#39;impropers&#39;]</span>

<span class="sd">        Returns ``None`` if no improper torsion information is present,</span>
<span class="sd">        otherwise returns a :class:`~MDAnalysis.topology.core.TopologyGroup`</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        .. versionchanged:: 0.10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..topology.core</span> <span class="kn">import</span> <span class="n">Improper_Torsion</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_top</span><span class="p">(</span><span class="s">&#39;impropers&#39;</span><span class="p">,</span> <span class="n">Improper_Torsion</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_fragments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build all fragments in the Universe</span>

<span class="sd">        Generally built on demand by an Atom querying its fragment property.</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Check that bond information is present, else inform</span>
        <span class="n">bonds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bonds</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s">&quot;Fragments require that the Universe has Bond information&quot;</span><span class="p">)</span>

        <span class="c"># This current finds all fragments from all Atoms</span>
        <span class="c"># Could redo this to only find fragments for a queried atom (ie. only fill out</span>
        <span class="c"># a single fragment).  This would then make it scale better for large systems.</span>
        <span class="c"># eg:</span>
        <span class="c"># try:</span>
        <span class="c">#    return self._fragDict[a]</span>
        <span class="c"># except KeyError:</span>
        <span class="c">#    self._init_fragments(a)  # builds the fragment a belongs to</span>

        <span class="k">class</span> <span class="nc">_fragset</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Normal sets aren&#39;t hashable, this is&quot;&quot;&quot;</span>

            <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ats</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ats</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ats</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ats</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ats</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ats</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">ats</span><span class="p">)</span>

        <span class="n">f</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>  <span class="c"># each atom starts with its own list</span>

        <span class="k">for</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="ow">in</span> <span class="n">bonds</span><span class="p">:</span>  <span class="c"># Iterate through all bonds</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">f</span><span class="p">[</span><span class="n">a2</span><span class="p">]):</span>  <span class="c"># New set made here</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">_fragset</span><span class="p">([</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">])</span>
                <span class="n">f</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">a2</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span>
            <span class="k">elif</span> <span class="n">f</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">f</span><span class="p">[</span><span class="n">a2</span><span class="p">]:</span>  <span class="c"># If a2 isn&#39;t in a fragment, add it to a1&#39;s</span>
                <span class="n">f</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
                <span class="n">f</span><span class="p">[</span><span class="n">a2</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">f</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">f</span><span class="p">[</span><span class="n">a2</span><span class="p">]:</span>  <span class="c"># If a1 isn&#39;t in a fragment, add it to a2&#39;s</span>
                <span class="n">f</span><span class="p">[</span><span class="n">a2</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
                <span class="n">f</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">a2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">f</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">f</span><span class="p">[</span><span class="n">a2</span><span class="p">]:</span>  <span class="c"># If they&#39;re in the same fragment, do nothing</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c"># If they are both in different fragments, combine fragments</span>
                <span class="n">f</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">a2</span><span class="p">])</span>
                <span class="n">f</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="n">a1</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="n">a2</span><span class="p">]))</span>

                <span class="c"># Lone atoms get their own fragment</span>
        <span class="n">f</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">_fragset</span><span class="p">((</span><span class="n">a</span><span class="p">,)))</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">val</span><span class="p">))</span>

        <span class="c"># All the unique values in f are the fragments</span>
        <span class="n">frags</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">AtomGroup</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ats</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">values</span><span class="p">())])</span>

        <span class="k">return</span> <span class="n">frags</span>

    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;fragments&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="Universe.fragments"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Universe.fragments">[docs]</a>    <span class="k">def</span> <span class="nf">fragments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read only tuple of fragments in the Universe</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_fragments</span><span class="p">()</span>
</div>
    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;bondDict&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_bondDict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lazily built dictionary of bonds</span>

<span class="sd">        Translates Atom to list of bonds</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bonds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span>
        <span class="n">bd</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">bonds</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bonds</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">b</span><span class="p">:</span>
                    <span class="n">bd</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bd</span>

    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;angleDict&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_angleDict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lazily built dictionary of angles</span>

<span class="sd">        Translates Atom to list of angles</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bonds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angles</span>
        <span class="n">bd</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">bonds</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bonds</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">b</span><span class="p">:</span>
                    <span class="n">bd</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bd</span>

    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;torsionDict&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_torsionDict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lazily built dictionary of torsions</span>

<span class="sd">        Translates Atom to list of torsions</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bonds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">torsions</span>
        <span class="n">bd</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bonds</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bonds</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">b</span><span class="p">:</span>
                    <span class="n">bd</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bd</span>

    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;improperDict&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_improperDict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lazily built dictionary of improper torsions</span>

<span class="sd">        Translates Atom to list of improper torsions</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bonds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">impropers</span>
        <span class="n">bd</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bonds</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bonds</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">b</span><span class="p">:</span>
                    <span class="n">bd</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bd</span>

    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;fragDict&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_fragmentDict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lazily built dictionary of fragments.</span>

<span class="sd">        Translates :class:`Atom` objects into the fragment they belong to.</span>

<span class="sd">        The Atom.fragment managed property queries this dictionary.</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">frags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span>  <span class="c"># will build if not built</span>
        <span class="n">fd</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">frags</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">fd</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>
        <span class="k">return</span> <span class="n">fd</span>

<div class="viewcode-block" id="Universe.build_topology"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Universe.build_topology">[docs]</a>    <span class="k">def</span> <span class="nf">build_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bond angle and torsion information is lazily constructed into the</span>
<span class="sd">        Universe.</span>

<span class="sd">        This method forces all this information to be loaded.</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s">&#39;bonds&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;bonds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_bonds</span><span class="p">()</span>
        <span class="k">if</span> <span class="s">&#39;angles&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;angles&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_angles</span><span class="p">()</span>
        <span class="k">if</span> <span class="s">&#39;torsions&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;torsions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_torsions</span><span class="p">()</span>
        <span class="k">if</span> <span class="s">&#39;impropers&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;impropers&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_impropers</span><span class="p">()</span>
</div>
    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;bonds&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a :class:`~MDAnalysis.topology.core.TopologyGroup` of all</span>
<span class="sd">        bonds in the Universe.</span>

<span class="sd">        .. versionchanged:: 0.9.0</span>
<span class="sd">           Now a lazily built :class:`~MDAnalysis.topology.core.TopologyGroup`</span>
<span class="sd">        .. versionchanged:: 0.9.2</span>
<span class="sd">           Now can return empty TopologyGroup</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_bonds</span><span class="p">()</span>

    <span class="nd">@bonds.setter</span>
    <span class="k">def</span> <span class="nf">bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bondlist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Can set bonds by supplying an iterable of bond tuples.</span>

<span class="sd">        Each bond tuple must contain the zero based indices of the two Atoms in</span>
<span class="sd">        the bond</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fill_cache</span><span class="p">(</span><span class="s">&#39;bonds&#39;</span><span class="p">,</span> <span class="n">bondlist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_caches</span><span class="p">(</span><span class="s">&#39;bondDict&#39;</span><span class="p">)</span>

    <span class="nd">@bonds.deleter</span>
<div class="viewcode-block" id="Universe.bonds"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Universe.bonds">[docs]</a>    <span class="k">def</span> <span class="nf">bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete the bonds from Universe</span>

<span class="sd">        This must also remove the per atom record of bonds (bondDict)</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_caches</span><span class="p">(</span><span class="s">&#39;bonds&#39;</span><span class="p">,</span> <span class="s">&#39;bondDict&#39;</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;angles&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">angles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a :class:`~MDAnalysis.topology.core.TopologyGroup`</span>
<span class="sd">        of all angles in the Universe</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        .. versionchanged:: 0.9.2</span>
<span class="sd">           Now can return empty TopologyGroup</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_angles</span><span class="p">()</span>

    <span class="nd">@angles.setter</span>
    <span class="k">def</span> <span class="nf">angles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bondlist</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fill_cache</span><span class="p">(</span><span class="s">&#39;angles&#39;</span><span class="p">,</span> <span class="n">bondlist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_caches</span><span class="p">(</span><span class="s">&#39;angleDict&#39;</span><span class="p">)</span>

    <span class="nd">@angles.deleter</span>
<div class="viewcode-block" id="Universe.angles"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Universe.angles">[docs]</a>    <span class="k">def</span> <span class="nf">angles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_caches</span><span class="p">(</span><span class="s">&#39;angles&#39;</span><span class="p">,</span> <span class="s">&#39;angleDict&#39;</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;torsions&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">torsions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a :class:`~MDAnalysis.topology.core.TopologyGroup`</span>
<span class="sd">        of all torsions in the Universe</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        .. versionchanged:: 0.9.2</span>
<span class="sd">           Now can return empty TopologyGroup</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_torsions</span><span class="p">()</span>

    <span class="nd">@torsions.setter</span>
    <span class="k">def</span> <span class="nf">torsions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bondlist</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fill_cache</span><span class="p">(</span><span class="s">&#39;torsions&#39;</span><span class="p">,</span> <span class="n">bondlist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_caches</span><span class="p">(</span><span class="s">&#39;torsionDict&#39;</span><span class="p">)</span>

    <span class="nd">@torsions.deleter</span>
<div class="viewcode-block" id="Universe.torsions"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Universe.torsions">[docs]</a>    <span class="k">def</span> <span class="nf">torsions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_caches</span><span class="p">(</span><span class="s">&#39;torsions&#39;</span><span class="p">,</span> <span class="s">&#39;torsionDict&#39;</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;impropers&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">impropers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a :class:`~MDAnalysis.topology.core.TopologyGroup`</span>
<span class="sd">        of all improper torsions in the Universe</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        .. versionchanged:: 0.9.2</span>
<span class="sd">           Now can return empty TopologyGroup</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_impropers</span><span class="p">()</span>

    <span class="nd">@impropers.setter</span>
    <span class="k">def</span> <span class="nf">impropers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bondlist</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fill_cache</span><span class="p">(</span><span class="s">&#39;impropers&#39;</span><span class="p">,</span> <span class="n">bondlist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_caches</span><span class="p">(</span><span class="s">&#39;improperDict&#39;</span><span class="p">)</span>

    <span class="nd">@impropers.deleter</span>
<div class="viewcode-block" id="Universe.impropers"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Universe.impropers">[docs]</a>    <span class="k">def</span> <span class="nf">impropers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_caches</span><span class="p">(</span><span class="s">&#39;impropers&#39;</span><span class="p">,</span> <span class="s">&#39;improperDict&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Universe.load_new"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Universe.load_new">[docs]</a>    <span class="k">def</span> <span class="nf">load_new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load coordinates from *filename*, using the suffix to detect file format.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">             *filename*</span>
<span class="sd">                 the coordinate file (single frame or trajectory) *or* a list of</span>
<span class="sd">                 filenames, which are read one after another.</span>
<span class="sd">             *permissive*</span>
<span class="sd">                 currently only relevant for PDB files: Set to ``True`` in order to ignore most errors</span>
<span class="sd">                 and read typical MD simulation PDB files; set to ``False`` to read with the Bio.PDB reader,</span>
<span class="sd">                 which can be useful for real Protein Databank PDB files. ``None``  selects the</span>
<span class="sd">                 MDAnalysis default (which is set in :class:`MDAnalysis.core.flags`) [``None``]</span>
<span class="sd">             *format*</span>
<span class="sd">                 provide the file format of the coordinate or trajectory file;</span>
<span class="sd">                 ``None`` guesses it from the file extension. Note that this</span>
<span class="sd">                 keyword has no effect if a list of file names is supplied because</span>
<span class="sd">                 the &quot;chained&quot; reader has to guess the file format for each</span>
<span class="sd">                 individual list member [``None``]</span>
<span class="sd">                 Can also pass a subclass of :class:`MDAnalysis.coordinates.base.Reader`</span>
<span class="sd">                 to define a custom reader to be used on the trajectory file.</span>
<span class="sd">             *kwargs*</span>
<span class="sd">                 Other kwargs are passed to the trajectory reader (only for advanced use)</span>

<span class="sd">        :Returns: (filename, trajectory_format) or ``None`` if *filename* == ``None``</span>
<span class="sd">        :Raises: :exc:`TypeError` if trajectory format can not be</span>
<span class="sd">                  determined or no appropriate trajectory reader found</span>

<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           If a list or sequence that is provided for *filename*  only contains a single entry</span>
<span class="sd">           then it is treated as single coordinate file. This has the consequence that it is</span>
<span class="sd">           not read by the :class:`~MDAnalysis.coordinates.base.ChainReader` but directly by</span>
<span class="sd">           its specialized file format reader, which typically has more features than the</span>
<span class="sd">           :class:`~MDAnalysis.coordinates.base.ChainReader`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="kn">import</span> <span class="nn">MDAnalysis.core</span>
        <span class="kn">from</span> <span class="nn">..coordinates.core</span> <span class="kn">import</span> <span class="n">get_reader_for</span>
        <span class="kn">from</span> <span class="nn">..coordinates.base</span> <span class="kn">import</span> <span class="n">Reader</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">asiterable</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># make sure a single filename is not handed to the ChainReader</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">asiterable</span><span class="p">(</span><span class="n">filename</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Universe.load_new(): loading {0}...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>

        <span class="n">reader_format</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;format&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;permissive&#39;</span><span class="p">,</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s">&#39;permissive_pdb_reader&#39;</span><span class="p">])</span>
        <span class="n">reader</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">reader_format</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">reader_format</span><span class="p">,</span> <span class="n">Reader</span><span class="p">):</span>
                <span class="n">reader</span> <span class="o">=</span> <span class="n">reader_format</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">reader</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">reader</span> <span class="o">=</span> <span class="n">get_reader_for</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span>
                                        <span class="n">permissive</span><span class="o">=</span><span class="n">perm</span><span class="p">,</span>
                                        <span class="n">format</span><span class="o">=</span><span class="n">reader_format</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s">&quot;Cannot find an appropriate coordinate reader for file &#39;{0}&#39;.</span><span class="se">\n</span><span class="s">&quot;</span>
                    <span class="s">&quot;           {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">err</span><span class="p">))</span>
                    <span class="c">#TypeError: ....&quot;</span>

        <span class="c"># supply number of atoms for readers that cannot do it for themselves</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;numatoms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">numberOfAtoms</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span> <span class="o">=</span> <span class="n">reader</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>    <span class="c"># unified trajectory API</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">numatoms</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">numberOfAtoms</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The topology and {form} trajectory files don&#39;t&quot;</span>
                             <span class="s">&quot; have the same number of atoms!</span><span class="se">\n</span><span class="s">&quot;</span>
                             <span class="s">&quot;Topology number of atoms {top_natoms}</span><span class="se">\n</span><span class="s">&quot;</span>
                             <span class="s">&quot;Trajectory: {fname} Number of atoms {trj_natoms}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                 <span class="n">form</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">format</span><span class="p">,</span>
                                 <span class="n">top_natoms</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">),</span>
                                 <span class="n">fname</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span>
                                 <span class="n">trj_natoms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">numatoms</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">format</span>
</div>
<div class="viewcode-block" id="Universe.selectAtoms"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Universe.selectAtoms">[docs]</a>    <span class="k">def</span> <span class="nf">selectAtoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="o">*</span><span class="n">othersel</span><span class="p">,</span> <span class="o">**</span><span class="n">selgroups</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select atoms using a CHARMM selection string.</span>

<span class="sd">        Returns an :class:`AtomGroup` with atoms sorted according to their</span>
<span class="sd">        index in the psf (this is to ensure that there aren&#39;t any duplicates,</span>
<span class="sd">        which can happen with complicated selections).</span>

<span class="sd">        Existing :class:`AtomGroup` objects can be passed as named arguments,</span>
<span class="sd">        which will then be available to the selection parser.</span>

<span class="sd">        Subselections can be grouped with parentheses.</span>

<span class="sd">        Example::</span>
<span class="sd">           &gt;&gt;&gt; sel = universe.selectAtoms(&quot;segid DMPC and not ( name H* or name O* )&quot;)</span>
<span class="sd">           &gt;&gt;&gt; sel</span>
<span class="sd">           &lt;AtomGroup with 3420 atoms&gt;</span>

<span class="sd">           &gt;&gt;&gt; universe.selectAtoms(&quot;around 10 group notHO&quot;, notHO=sel)</span>
<span class="sd">           &lt;AtomGroup with 1250 atoms&gt;</span>

<span class="sd">        .. Note::</span>

<span class="sd">           If exact ordering of atoms is required (for instance, for</span>
<span class="sd">           :meth:`~AtomGroup.angle` or :meth:`~AtomGroup.dihedral`</span>
<span class="sd">           calculations) then one supplies selections *separately* in the</span>
<span class="sd">           required order. Also, when multiple :class:`AtomGroup` instances are</span>
<span class="sd">           concatenated with the ``+`` operator then the order of :class:`Atom`</span>
<span class="sd">           instances is preserved and duplicates are not removed.</span>

<span class="sd">        .. SeeAlso:: :ref:`selection-commands-label` for further details and examples.</span>

<span class="sd">        The selection parser understands the following CASE SENSITIVE *keywords*:</span>

<span class="sd">        **Simple selections**</span>

<span class="sd">            protein, backbone, nucleic, nucleicbackbone</span>
<span class="sd">                selects all atoms that belong to a standard set of residues; a protein</span>
<span class="sd">                is identfied by a hard-coded set of residue names so it  may not</span>
<span class="sd">                work for esoteric residues.</span>
<span class="sd">            segid *seg-name*</span>
<span class="sd">                select by segid (as given in the topology), e.g. ``segid 4AKE`` or ``segid DMPC``</span>
<span class="sd">            resid *residue-number-range*</span>
<span class="sd">                resid can take a single residue number or a range of numbers. A range</span>
<span class="sd">                consists of two numbers separated by a colon (inclusive) such</span>
<span class="sd">                as ``resid 1:5``. A residue number (&quot;resid&quot;) is taken directly from the</span>
<span class="sd">                topology.</span>
<span class="sd">            resnum *resnum-number-range*</span>
<span class="sd">                resnum is the canonical residue number; typically it is set to the residue id</span>
<span class="sd">                in the original PDB structure.</span>
<span class="sd">            resname *residue-name*</span>
<span class="sd">                select by residue name, e.g. ``resname LYS``</span>
<span class="sd">            name *atom-name*</span>
<span class="sd">                select by atom name (as given in the topology). Often, this is force</span>
<span class="sd">                field dependent. Example: ``name CA`` (for C&amp;alpha; atoms) or ``name OW`` (for SPC water oxygen)</span>
<span class="sd">            type *atom-type*</span>
<span class="sd">                select by atom type; this is either a string or a number and depends on</span>
<span class="sd">                the force field; it is read from the topology file (e.g. the CHARMM PSF</span>
<span class="sd">                file contains numeric atom types). It has non-sensical values when a</span>
<span class="sd">                PDB or GRO file is used as a topology.</span>
<span class="sd">            atom *seg-name*  *residue-number*  *atom-name*</span>
<span class="sd">                a selector for a single atom consisting of segid resid atomname,</span>
<span class="sd">                e.g. ``DMPC 1 C2`` selects the C2 carbon of the first residue of the DMPC</span>
<span class="sd">                segment</span>
<span class="sd">            altloc *alternative-location*</span>
<span class="sd">                a selection for atoms where alternative locations are available,</span>
<span class="sd">                which is often the case with high-resolution crystal structures</span>
<span class="sd">                e.g. `resid 4 and resname ALA and altloc B` selects only the atoms</span>
<span class="sd">                of ALA-4 that have an altloc B record.</span>

<span class="sd">        **Boolean**</span>

<span class="sd">            not</span>
<span class="sd">                all atoms not in the selection, e.g. ``not protein`` selects</span>
<span class="sd">                all atoms that aren&#39;t part of a protein</span>

<span class="sd">            and, or</span>
<span class="sd">                combine two selections according to the rules of boolean algebra,</span>
<span class="sd">                e.g. ``protein and not (resname ALA or resname LYS)`` selects all atoms</span>
<span class="sd">                that belong to a protein, but are not in a lysine or alanine residue</span>

<span class="sd">        **Geometric**</span>

<span class="sd">            around *distance*  *selection*</span>
<span class="sd">                selects all atoms a certain cutoff away from another selection,</span>
<span class="sd">                e.g. ``around 3.5 protein`` selects all atoms not belonging to protein</span>
<span class="sd">                that are within 3.5 Angstroms from the protein</span>
<span class="sd">            point *x* *y* *z*  *distance*</span>
<span class="sd">                selects all atoms within a cutoff of a point in space, make sure</span>
<span class="sd">                coordinate is separated by spaces, e.g. ``point 5.0 5.0 5.0  3.5`` selects</span>
<span class="sd">                all atoms within 3.5 Angstroms of the coordinate (5.0, 5.0, 5.0)</span>
<span class="sd">            prop [abs] *property*  *operator*  *value*</span>
<span class="sd">                selects atoms based on position, using *property*  **x**, **y**, or</span>
<span class="sd">                **z** coordinate. Supports the **abs** keyword (for absolute value) and</span>
<span class="sd">                the following *operators*: **&lt;, &gt;, &lt;=, &gt;=, ==, !=**. For example, ``prop z &gt;= 5.0``</span>
<span class="sd">                selects all atoms with z coordinate greater than 5.0; ``prop abs z &lt;= 5.0``</span>
<span class="sd">                selects all atoms within -5.0 &lt;= z &lt;= 5.0.</span>

<span class="sd">        **Connectivity**</span>

<span class="sd">            byres *selection*</span>
<span class="sd">                selects all atoms that are in the same segment and residue as</span>
<span class="sd">                selection, e.g. specify the subselection after the byres keyword</span>

<span class="sd">        **Index**</span>

<span class="sd">            bynum *index-range*</span>
<span class="sd">                selects all atoms within a range of (1-based) inclusive indices,</span>
<span class="sd">                e.g. ``bynum 1`` selects the first atom in the universe; ``bynum 5:10``</span>
<span class="sd">                selects atoms 5 through 10 inclusive. All atoms in the</span>
<span class="sd">                :class:`MDAnalysis.Universe` are consecutively numbered, and the index</span>
<span class="sd">                runs from 1 up to the total number of atoms.</span>

<span class="sd">        **Preexisting selections**</span>

<span class="sd">            group *group-name*</span>
<span class="sd">                selects the atoms in the :class:`AtomGroup` passed to the function as an</span>
<span class="sd">                argument named *group-name*. Only the atoms common to *group-name* and the</span>
<span class="sd">                instance :meth:`~selectAtoms` was called from will be considered.</span>
<span class="sd">                *group-name* will be included in the parsing just by comparison of atom indices.</span>
<span class="sd">                This means that it is up to the user to make sure they were defined in an</span>
<span class="sd">                appropriate :class:`Universe`.</span>

<span class="sd">            fullgroup *group-name*</span>
<span class="sd">                just like the ``group`` keyword with the difference that all the atoms of</span>
<span class="sd">                *group-name* are included. The resulting selection may therefore have atoms</span>
<span class="sd">                that were initially absent from the instance :meth:`~selectAtoms` was</span>
<span class="sd">                called from.</span>


<span class="sd">        .. versionchanged:: 0.7.4</span>
<span class="sd">           Added *resnum* selection.</span>
<span class="sd">        .. versionchanged:: 0.8.1</span>
<span class="sd">           Added *group* and *fullgroup* selections.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">Selection</span>  <span class="c"># can ONLY import in method, otherwise cyclical import!</span>

        <span class="n">atomgrp</span> <span class="o">=</span> <span class="n">Selection</span><span class="o">.</span><span class="n">Parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">sel</span><span class="p">,</span> <span class="n">selgroups</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">othersel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">atomgrp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Generate a selection for each selection string</span>
            <span class="c">#atomselections = [atomgrp]</span>
            <span class="k">for</span> <span class="n">sel</span> <span class="ow">in</span> <span class="n">othersel</span><span class="p">:</span>
                <span class="n">atomgrp</span> <span class="o">=</span> <span class="n">atomgrp</span> <span class="o">+</span> <span class="n">Selection</span><span class="o">.</span><span class="n">Parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">sel</span><span class="p">,</span> <span class="n">selgroups</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="c">#atomselections.append(Selection.Parser.parse(sel).apply(self))</span>
            <span class="c">#return tuple(atomselections)</span>
            <span class="k">return</span> <span class="n">atomgrp</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&lt;Universe with {natoms} atoms{bonds}&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">natoms</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">),</span>
            <span class="n">bonds</span><span class="o">=</span><span class="s">&quot; and {0} bonds&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">))</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span> <span class="k">else</span> <span class="s">&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="c"># Properties</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Current dimensions of the unitcell&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">dimensions</span>

    <span class="nd">@dimensions.setter</span>
<div class="viewcode-block" id="Universe.dimensions"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Universe.dimensions">[docs]</a>    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set dimensions if the Timestep allows this</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Add fancy error handling here or use Timestep?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="n">box</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Universe.coord"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Universe.coord">[docs]</a>    <span class="k">def</span> <span class="nf">coord</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reference to current timestep and coordinates of universe.</span>

<span class="sd">        The raw trajectory coordinates are :attr:`Universe.coord._pos`,</span>
<span class="sd">        represented as a :class:`numpy.float32` array.</span>

<span class="sd">        Because :attr:`coord` is a reference to a</span>
<span class="sd">        :class:`~MDAnalysis.coordinates.base.Timestep`, it changes its contents</span>
<span class="sd">        while one is stepping through the trajectory.</span>

<span class="sd">        .. Note::</span>

<span class="sd">           In order to access the coordinates it is probably better to use the</span>
<span class="sd">           :meth:`AtomGroup.coordinates` method; for instance, all coordinates</span>
<span class="sd">           of the Universe as a numpy array:</span>
<span class="sd">           :meth:`Universe.atoms.coordinates`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">trajectory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reference to trajectory reader object containing trajectory data.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__trajectory</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__trajectory</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;No trajectory loaded into Universe&quot;</span><span class="p">)</span>

    <span class="nd">@trajectory.setter</span>
<div class="viewcode-block" id="Universe.trajectory"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Universe.trajectory">[docs]</a>    <span class="k">def</span> <span class="nf">trajectory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__trajectory</span>  <span class="c"># guarantees that files are closed (?)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__trajectory</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c"># NOTE: DO NOT ADD A __del__() method: it somehow keeps the Universe</span>
    <span class="c">#       alive during unit tests and the unit tests run out of memory!</span>
    <span class="c">#### def __del__(self): &lt;------ do not add this! [orbeckst]</span>

</div></div>
<div class="viewcode-block" id="asUniverse"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.asUniverse">[docs]</a><span class="k">def</span> <span class="nf">asUniverse</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a universe from the input arguments.</span>

<span class="sd">    1. If the first argument is a universe, just return it::</span>

<span class="sd">         as_universe(universe) --&gt; universe</span>

<span class="sd">    2. Otherwise try to build a universe from the first or the first</span>
<span class="sd">       and second argument::</span>

<span class="sd">         asUniverse(PDB, **kwargs) --&gt; Universe(PDB, **kwargs)</span>
<span class="sd">         asUniverse(PSF, DCD, **kwargs) --&gt; Universe(PSF, DCD, **kwargs)</span>
<span class="sd">         asUniverse(*args, **kwargs) --&gt; Universe(*args, **kwargs)</span>

<span class="sd">    :Returns: an instance of :class:`~MDAnalaysis.AtomGroup.Universe`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;asUniverse() takes at least one argument (</span><span class="si">%d</span><span class="s"> given)&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Universe</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Universe</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Merge"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Merge">[docs]</a><span class="k">def</span> <span class="nf">Merge</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a :class:`Universe` from two or more :class:`AtomGroup` instances.</span>

<span class="sd">    :class:`AtomGroup` instances can come from different Universes, or come</span>
<span class="sd">    directly from a :meth:`~Universe.selectAtoms` call.</span>

<span class="sd">    It can also be used with a single :class:`AtomGroup` if the user wants to,</span>
<span class="sd">    for example, re-order the atoms in the Universe.</span>

<span class="sd">    :Arguments: One or more :class:`AtomGroup` instances.</span>

<span class="sd">    :Returns: an instance of :class:`~MDAnalaysis.AtomGroup.Universe`</span>

<span class="sd">    :Raises: :exc:`ValueError` for too few arguments or if an AtomGroup is</span>
<span class="sd">             empty and :exc:`TypeError` if arguments are not</span>
<span class="sd">             :class:`AtomGroup` instances.</span>

<span class="sd">    .. rubric:: Example</span>

<span class="sd">    In this example, protein, ligand, and solvent were externally prepared in</span>
<span class="sd">    three different PDB files. They are loaded into separate :class:`Universe`</span>
<span class="sd">    objects (where they could be further manipulated, e.g. renumbered,</span>
<span class="sd">    relabeled, rotated, ...) The :func:`Merge` command is used to combine all</span>
<span class="sd">    of them together::</span>

<span class="sd">       u1 = Universe(&quot;protein.pdb&quot;)</span>
<span class="sd">       u2 = Universe(&quot;ligand.pdb&quot;)</span>
<span class="sd">       u3 = Universe(&quot;solvent.pdb&quot;)</span>
<span class="sd">       u = Merge(u1.selectAtoms(&quot;protein&quot;), u2.atoms, u3.atoms)</span>
<span class="sd">       u.atoms.write(&quot;system.pdb&quot;)</span>

<span class="sd">    The complete system is then written out to a new PDB file.</span>

<span class="sd">    .. Note:: Merging does not create a full trajectory but only a single</span>
<span class="sd">              structure even if the input consists of one or more trajectories.</span>

<span class="sd">    .. versionchanged 0.9.0::</span>
<span class="sd">       Raises exceptions instead of assertion errors.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">MDAnalysis.topology.core</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Need at least one AtomGroup for merging&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">AtomGroup</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; is not an AtomGroup&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;cannot merge empty AtomGroup&quot;</span><span class="p">)</span>

    <span class="n">coords</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>
    <span class="n">trajectory</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">Reader</span><span class="p">()</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">Timestep</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">trajectory</span><span class="p">,</span> <span class="s">&quot;ts&quot;</span><span class="p">,</span> <span class="n">ts</span><span class="p">)</span>
    <span class="n">trajectory</span><span class="o">.</span><span class="n">numframes</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c"># create an empty Universe object</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">()</span>
    <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span> <span class="o">=</span> <span class="n">trajectory</span>

    <span class="c"># create a list of Atoms, then convert it to an AtomGroup</span>
    <span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">gr</span> <span class="ow">in</span> <span class="n">args</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">gr</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
        <span class="n">a</span><span class="o">.</span><span class="n">universe</span> <span class="o">=</span> <span class="n">u</span>
    <span class="c"># adjust the atom numbering</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
        <span class="n">a</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">a</span><span class="o">.</span><span class="n">serial</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">u</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="n">AtomGroup</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="c"># adjust the residue and segment numbering (removes any remaining references to the old universe)</span>
    <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">build_residues</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
    <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">build_segments</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">u</span>
</pre></div></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">MDAnalysis 0.10.0-dev documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../MDAnalysis.html" >MDAnalysis</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Joshua Adelman,
    Christian Beckstein (logo), Alejandro Bernardin, Sébastien Buchoux,
    David Caplan, Matthieu Chavent, Xavier Deupi, Jan Domański, David L. Dotson
    Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar,
    Benjamin Hall, Joe Jordan, Jinju Lu, Robert McGibbon, Alex Nesterenko,
    Manuel Nuno Melo, Caio S. Souza, Danny Parton, Joshua L. Phillips, Tyler Reddy,
    Paul Rigor, Sean L. Seyler, Andy Somogyi, Lukas Stelzl, Zhuyi Xue,
    and Oliver Beckstein.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>