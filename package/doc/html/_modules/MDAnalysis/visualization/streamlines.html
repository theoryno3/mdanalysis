

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.visualization.streamlines &mdash; MDAnalysis 0.10.0-dev documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.10.0-dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.10.0-dev documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.10.0-dev documentation" href="../../../index.html" />
    <link rel="up" title="MDAnalysis" href="../../MDAnalysis.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">MDAnalysis 0.10.0-dev documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../MDAnalysis.html" accesskey="U">MDAnalysis</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for MDAnalysis.visualization.streamlines</h1><div class="highlight"><pre>
<span class="c"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8</span>
<span class="c">#</span>
<span class="c"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver Beckstein</span>
<span class="c"># and contributors (see AUTHORS for the full list)</span>
<span class="c">#</span>
<span class="c"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c">#</span>
<span class="c"># Please cite your use of MDAnalysis in published work:</span>
<span class="c">#</span>
<span class="c"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c">#</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Multicore 2D streamplot Python library for MDAnalysis --- :mod:`MDAnalysis.visualization.streamlines`</span>
<span class="sd">=====================================================================================================</span>

<span class="sd">:Authors: Tyler Reddy and Matthieu Chavent</span>
<span class="sd">:Year: 2014</span>
<span class="sd">:Copyright: GNU Public License v3</span>
<span class="sd">:Citation: [Chavent2014]_</span>

<span class="sd">.. autofunction:: generate_streamlines</span>

<span class="sd">&#39;&#39;&#39;</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">matplotlib</span>
    <span class="kn">import</span> <span class="nn">matplotlib.path</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
        <span class="s">&#39;2d streamplot module requires: matplotlib.path for its path.Path.contains_points method. The installation &#39;</span>
        <span class="s">&#39;instructions for the matplotlib module can be found here: &#39;</span>
        <span class="s">&#39;http://matplotlib.org/faq/installing_faq.html?highlight=install&#39;</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">MDAnalysis</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">scipy</span>


<span class="k">def</span> <span class="nf">produce_grid</span><span class="p">(</span><span class="n">tuple_of_limits</span><span class="p">,</span> <span class="n">grid_spacing</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Produce a grid for the simulation system based on the tuple of Cartesian Coordinate limits calculated in an</span>
<span class="sd">    earlier step.&#39;&#39;&#39;</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">tuple_of_limits</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="p">:</span><span class="n">grid_spacing</span><span class="p">,</span> <span class="n">y_min</span><span class="p">:</span><span class="n">y_max</span><span class="p">:</span><span class="n">grid_spacing</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">grid</span>


<span class="k">def</span> <span class="nf">split_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">num_cores</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Take the overall grid for the system and split it into lists of square vertices that can be distributed to</span>
<span class="sd">    each core. Limited to 2D for now&#39;&#39;&#39;</span>

    <span class="c"># produce an array containing the cartesian coordinates of all vertices in the grid:</span>
    <span class="n">x_array</span><span class="p">,</span> <span class="n">y_array</span> <span class="o">=</span> <span class="n">grid</span>
    <span class="n">grid_vertex_cartesian_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">x_array</span><span class="p">,</span> <span class="n">y_array</span><span class="p">))</span>
    <span class="c">#the grid_vertex_cartesian_array has N_rows, with each row corresponding to a column of coordinates in the grid (</span>
    <span class="c"># so a given row has shape N_rows, 2); overall shape (N_columns_in_grid, N_rows_in_a_column, 2)</span>
    <span class="c">#although I&#39;ll eventually want a pure numpy/scipy/vector-based solution, for now I&#39;ll allow loops to simplify the</span>
    <span class="c">#  division of the cartesian coordinates into a list of the squares in the grid</span>
    <span class="n">list_all_squares_in_grid</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># should eventually be a nested list of all the square vertices in the grid/system</span>
    <span class="n">list_parent_index_values</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># want an ordered list of assignment indices for reconstructing the grid positions</span>
    <span class="c"># in the parent process</span>
    <span class="n">current_column</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">current_column</span> <span class="o">&lt;</span> <span class="n">grid_vertex_cartesian_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
    <span class="c"># go through all the columns except the last one and account for the square vertices (the last column</span>
        <span class="c">#  has no &#39;right neighbour&#39;)</span>
        <span class="n">current_row</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">current_row</span> <span class="o">&lt;</span> <span class="n">grid_vertex_cartesian_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c"># all rows except the top row, which doesn&#39;t have a row above it for forming squares</span>
            <span class="n">bottom_left_vertex_current_square</span> <span class="o">=</span> <span class="n">grid_vertex_cartesian_array</span><span class="p">[</span><span class="n">current_column</span><span class="p">,</span> <span class="n">current_row</span><span class="p">]</span>
            <span class="n">bottom_right_vertex_current_square</span> <span class="o">=</span> <span class="n">grid_vertex_cartesian_array</span><span class="p">[</span><span class="n">current_column</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">current_row</span><span class="p">]</span>
            <span class="n">top_right_vertex_current_square</span> <span class="o">=</span> <span class="n">grid_vertex_cartesian_array</span><span class="p">[</span><span class="n">current_column</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">current_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">top_left_vertex_current_square</span> <span class="o">=</span> <span class="n">grid_vertex_cartesian_array</span><span class="p">[</span><span class="n">current_column</span><span class="p">,</span> <span class="n">current_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c">#append the vertices of this square to the overall list of square vertices:</span>
            <span class="n">list_all_squares_in_grid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span><span class="n">bottom_left_vertex_current_square</span><span class="p">,</span> <span class="n">bottom_right_vertex_current_square</span><span class="p">,</span> <span class="n">top_right_vertex_current_square</span><span class="p">,</span>
                    <span class="n">top_left_vertex_current_square</span><span class="p">])</span>
            <span class="n">list_parent_index_values</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">current_row</span><span class="p">,</span> <span class="n">current_column</span><span class="p">])</span>
            <span class="n">current_row</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">current_column</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c">#split the list of square vertices [[v1,v2,v3,v4],[v1,v2,v3,v4],...,...] into roughly equally-sized sublists to</span>
    <span class="c"># be distributed over the available cores on the system:</span>
    <span class="n">list_square_vertex_arrays_per_core</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">list_all_squares_in_grid</span><span class="p">,</span> <span class="n">num_cores</span><span class="p">)</span>
    <span class="n">list_parent_index_values</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">list_parent_index_values</span><span class="p">,</span> <span class="n">num_cores</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">list_square_vertex_arrays_per_core</span><span class="p">,</span> <span class="n">list_parent_index_values</span><span class="p">,</span> <span class="n">current_row</span><span class="p">,</span> <span class="n">current_column</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">per_core_work</span><span class="p">(</span><span class="n">coordinate_file_path</span><span class="p">,</span> <span class="n">trajectory_file_path</span><span class="p">,</span> <span class="n">list_square_vertex_arrays_this_core</span><span class="p">,</span> <span class="n">MDA_selection</span><span class="p">,</span>
                  <span class="n">start_frame</span><span class="p">,</span> <span class="n">end_frame</span><span class="p">,</span> <span class="n">reconstruction_index_list</span><span class="p">,</span> <span class="n">maximum_delta_magnitude</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;The code to perform on a given core given the list of square vertices assigned to it.&#39;&#39;&#39;</span>
    <span class="c"># obtain the relevant coordinates for particles of interest</span>
    <span class="n">universe_object</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="n">coordinate_file_path</span><span class="p">,</span> <span class="n">trajectory_file_path</span><span class="p">)</span>
    <span class="n">list_previous_frame_centroids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">list_previous_frame_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c">#define some utility functions for trajectory iteration:</span>

    <span class="k">def</span> <span class="nf">produce_list_indices_point_in_polygon_this_frame</span><span class="p">(</span><span class="n">vertex_coord_list</span><span class="p">):</span>
        <span class="n">list_indices_point_in_polygon</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">square_vertices</span> <span class="ow">in</span> <span class="n">vertex_coord_list</span><span class="p">:</span>
            <span class="n">path_object</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">square_vertices</span><span class="p">)</span>
            <span class="n">index_list_in_polygon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">path_object</span><span class="o">.</span><span class="n">contains_points</span><span class="p">(</span><span class="n">relevant_particle_coordinate_array_xy</span><span class="p">))</span>
            <span class="n">list_indices_point_in_polygon</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_list_in_polygon</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">list_indices_point_in_polygon</span>

    <span class="k">def</span> <span class="nf">produce_list_centroids_this_frame</span><span class="p">(</span><span class="n">list_indices_in_polygon</span><span class="p">):</span>
        <span class="n">list_centroids_this_frame</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">list_indices_in_polygon</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># if there are no particles of interest in this particular square</span>
                <span class="n">list_centroids_this_frame</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;empty&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current_coordinate_array_in_square</span> <span class="o">=</span> <span class="n">relevant_particle_coordinate_array_xy</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
                <span class="n">current_square_indices_centroid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">current_coordinate_array_in_square</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">list_centroids_this_frame</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_square_indices_centroid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">list_centroids_this_frame</span>  <span class="c"># a list of numpy xy centroid arrays for this frame</span>

    <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">universe_object</span><span class="o">.</span><span class="n">trajectory</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span> <span class="o">&lt;</span> <span class="n">start_frame</span><span class="p">:</span>  <span class="c"># don&#39;t start until first specified frame</span>
            <span class="k">continue</span>
        <span class="n">relevant_particle_coordinate_array_xy</span> <span class="o">=</span> <span class="n">universe_object</span><span class="o">.</span><span class="n">selectAtoms</span><span class="p">(</span><span class="n">MDA_selection</span><span class="p">)</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
          <span class="c"># only 2D / xy coords for now</span>
        <span class="c">#I will need a list of indices for relevant particles falling within each square in THIS frame:</span>
        <span class="n">list_indices_in_squares_this_frame</span> <span class="o">=</span> <span class="n">produce_list_indices_point_in_polygon_this_frame</span><span class="p">(</span>
            <span class="n">list_square_vertex_arrays_this_core</span><span class="p">)</span>
        <span class="c">#likewise, I will need a list of centroids of particles in each square (same order as above list):</span>
        <span class="n">list_centroids_in_squares_this_frame</span> <span class="o">=</span> <span class="n">produce_list_centroids_this_frame</span><span class="p">(</span><span class="n">list_indices_in_squares_this_frame</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">list_previous_frame_indices</span><span class="p">:</span>  <span class="c"># if the previous frame had indices in at least one square I will need to use</span>
        <span class="c">#  those indices to generate the updates to the corresponding centroids in this frame:</span>
            <span class="n">list_centroids_this_frame_using_indices_from_last_frame</span> <span class="o">=</span> <span class="n">produce_list_centroids_this_frame</span><span class="p">(</span>
                <span class="n">list_previous_frame_indices</span><span class="p">)</span>
            <span class="c">#I need to write a velocity of zero if there are any &#39;empty&#39; squares in either frame:</span>
            <span class="n">xy_deltas_to_write</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">square_1_centroid</span><span class="p">,</span> <span class="n">square_2_centroid</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">list_centroids_this_frame_using_indices_from_last_frame</span><span class="p">,</span>
                                                            <span class="n">list_previous_frame_centroids</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">square_1_centroid</span> <span class="o">==</span> <span class="s">&#39;empty&#39;</span> <span class="ow">or</span> <span class="n">square_2_centroid</span> <span class="o">==</span> <span class="s">&#39;empty&#39;</span><span class="p">:</span>
                    <span class="n">xy_deltas_to_write</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xy_deltas_to_write</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">square_1_centroid</span><span class="p">,</span> <span class="n">square_2_centroid</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

            <span class="c">#xy_deltas_to_write = numpy.subtract(numpy.array(</span>
            <span class="c"># list_centroids_this_frame_using_indices_from_last_frame),numpy.array(list_previous_frame_centroids))</span>
            <span class="n">xy_deltas_to_write</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xy_deltas_to_write</span><span class="p">)</span>
            <span class="c">#now filter the array to only contain distances in the range [-8,8] as a placeholder for dealing with PBC</span>
            <span class="c">#  issues (Matthieu seemed to use a limit of 8 as well);</span>
            <span class="n">xy_deltas_to_write</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">xy_deltas_to_write</span><span class="p">,</span> <span class="o">-</span><span class="n">maximum_delta_magnitude</span><span class="p">,</span> <span class="n">maximum_delta_magnitude</span><span class="p">)</span>

            <span class="c">#with the xy and dx,dy values calculated I need to set the values from this frame to previous frame</span>
            <span class="c"># values in anticipation of the next frame:</span>
            <span class="n">list_previous_frame_centroids</span> <span class="o">=</span> <span class="n">list_centroids_in_squares_this_frame</span><span class="p">[:]</span>
            <span class="n">list_previous_frame_indices</span> <span class="o">=</span> <span class="n">list_indices_in_squares_this_frame</span><span class="p">[:]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c"># either no points in squares or after the first frame I&#39;ll just reset the &#39;previous&#39; values so they</span>
        <span class="c"># can be used when consecutive frames have proper values</span>
            <span class="n">list_previous_frame_centroids</span> <span class="o">=</span> <span class="n">list_centroids_in_squares_this_frame</span><span class="p">[:]</span>
            <span class="n">list_previous_frame_indices</span> <span class="o">=</span> <span class="n">list_indices_in_squares_this_frame</span><span class="p">[:]</span>
        <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span> <span class="o">&gt;</span> <span class="n">end_frame</span><span class="p">:</span>
            <span class="k">break</span>  <span class="c"># stop here</span>
    <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="n">reconstruction_index_list</span><span class="p">,</span> <span class="n">xy_deltas_to_write</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>


<div class="viewcode-block" id="generate_streamlines"><a class="viewcode-back" href="../../../documentation_pages/visualization/streamlines.html#MDAnalysis.visualization.streamlines.generate_streamlines">[docs]</a><span class="k">def</span> <span class="nf">generate_streamlines</span><span class="p">(</span><span class="n">coordinate_file_path</span><span class="p">,</span> <span class="n">trajectory_file_path</span><span class="p">,</span> <span class="n">grid_spacing</span><span class="p">,</span> <span class="n">MDA_selection</span><span class="p">,</span> <span class="n">start_frame</span><span class="p">,</span>
                         <span class="n">end_frame</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">maximum_delta_magnitude</span><span class="p">,</span> <span class="n">num_cores</span><span class="o">=</span><span class="s">&#39;maximum&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Produce the x and y components of a 2D streamplot data set.</span>
<span class="sd">    </span>
<span class="sd">    :Parameters:</span>
<span class="sd">        **coordinate_file_path** : str</span>
<span class="sd">            Absolute path to the coordinate file</span>
<span class="sd">        **trajectory_file_path** : str</span>
<span class="sd">            Absolute path to the trajectory file. It will normally be desirable to filter the trajectory with a tool</span>
<span class="sd">            such as GROMACS g_filter (see [Chavent2014]_)</span>
<span class="sd">        **grid_spacing** : float</span>
<span class="sd">            The spacing between grid lines (angstroms)</span>
<span class="sd">        **MDA_selection** : str</span>
<span class="sd">            MDAnalysis selection string</span>
<span class="sd">        **start_frame** : int</span>
<span class="sd">            First frame number to parse</span>
<span class="sd">        **end_frame** : int</span>
<span class="sd">            Last frame number to parse</span>
<span class="sd">        **xmin** : float</span>
<span class="sd">            Minimum coordinate boundary for x-axis (angstroms)</span>
<span class="sd">        **xmax** : float</span>
<span class="sd">            Maximum coordinate boundary for x-axis (angstroms)</span>
<span class="sd">        **ymin** : float</span>
<span class="sd">            Minimum coordinate boundary for y-axis (angstroms)</span>
<span class="sd">        **ymax** : float</span>
<span class="sd">            Maximum coordinate boundary for y-axis (angstroms)</span>
<span class="sd">        **maximum_delta_magnitude** : float</span>
<span class="sd">            Absolute value of the largest displacement tolerated for the centroid of a group of particles (</span>
<span class="sd">            angstroms). Values above this displacement will not count in the streamplot (treated as excessively large</span>
<span class="sd">            displacements crossing the periodic boundary)</span>
<span class="sd">        **num_cores** : int, optional</span>
<span class="sd">            The number of cores to use. (Default &#39;maximum&#39; uses all available cores)</span>

<span class="sd">    :Returns:</span>
<span class="sd">        **dx_array** : array of floats</span>
<span class="sd">            An array object containing the displacements in the x direction</span>
<span class="sd">        **dy_array** : array of floats</span>
<span class="sd">            An array object containing the displacements in the y direction</span>
<span class="sd">        **average_displacement** : float</span>
<span class="sd">            :math:`\\frac {\\sum \\sqrt[]{dx^2 + dy^2}} {N}`</span>
<span class="sd">        **standard_deviation_of_displacement** : float</span>
<span class="sd">            standard deviation of :math:`\\sqrt[]{dx^2 + dy^2}`</span>
<span class="sd">            </span>
<span class="sd">    :Examples:</span>

<span class="sd">    ::</span>

<span class="sd">        import matplotlib, matplotlib.pyplot, numpy</span>
<span class="sd">        import MDAnalysis, MDAnalysis.visualization.streamlines</span>
<span class="sd">        u1, v1, average_displacement,standard_deviation_of_displacement =</span>
<span class="sd">        MDAnalysis.visualization.streamlines.generate_streamlines(&#39;testing.gro&#39;,&#39;testing_filtered.xtc&#39;,grid_spacing =</span>
<span class="sd">        20, MDA_selection = &#39;name PO4&#39;,start_frame=2,end_frame=3,xmin=-8.73000049591,xmax= 1225.96008301,</span>
<span class="sd">        ymin= -12.5799999237, ymax=1224.34008789,maximum_delta_magnitude = 1.0,num_cores=16)</span>
<span class="sd">        x = numpy.linspace(0,1200,61)</span>
<span class="sd">        y = numpy.linspace(0,1200,61)</span>
<span class="sd">        speed = numpy.sqrt(u1*u1 + v1*v1)</span>
<span class="sd">        fig = matplotlib.pyplot.figure()</span>
<span class="sd">        ax = fig.add_subplot(111,aspect=&#39;equal&#39;)</span>
<span class="sd">        ax.set_xlabel(&#39;x ($\AA$)&#39;)</span>
<span class="sd">        ax.set_ylabel(&#39;y ($\AA$)&#39;)</span>
<span class="sd">        ax.streamplot(x,y,u1,v1,density=(10,10),color=speed,linewidth=3*speed/speed.max())</span>
<span class="sd">        fig.savefig(&#39;testing_streamline.png&#39;,dpi=300)</span>
<span class="sd">    </span>
<span class="sd">    .. image:: testing_streamline.png</span>

<span class="sd">    .. [Chavent2014] Chavent, M.\*, Reddy, T.\*, Dahl, C.E., Goose, J., Jobard, B., and Sansom, M.S.P. (2014)</span>
<span class="sd">    Methodologies for the analysis of instantaneous lipid diffusion in MD simulations of large membrane systems.</span>
<span class="sd">    *Faraday Discussions* **169**: **Accepted**</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c"># work out the number of cores to use:</span>
    <span class="k">if</span> <span class="n">num_cores</span> <span class="o">==</span> <span class="s">&#39;maximum&#39;</span><span class="p">:</span>
        <span class="n">num_cores</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>  <span class="c"># use all available cores</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">num_cores</span> <span class="o">=</span> <span class="n">num_cores</span>  <span class="c"># use the value specified by the user</span>
        <span class="c">#assert isinstance(num_cores,(int,long)), &quot;The number of specified cores must (of course) be an integer.&quot;</span>
    <span class="n">numpy</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s">&#39;warn&#39;</span><span class="p">,</span> <span class="n">over</span><span class="o">=</span><span class="s">&#39;raise&#39;</span><span class="p">)</span>
    <span class="n">parent_list_deltas</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># collect all data from child processes here</span>

    <span class="k">def</span> <span class="nf">log_result_to_parent</span><span class="p">(</span><span class="n">delta_array</span><span class="p">):</span>
        <span class="n">parent_list_deltas</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">delta_array</span><span class="p">)</span>

    <span class="n">tuple_of_limits</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">produce_grid</span><span class="p">(</span><span class="n">tuple_of_limits</span><span class="o">=</span><span class="n">tuple_of_limits</span><span class="p">,</span> <span class="n">grid_spacing</span><span class="o">=</span><span class="n">grid_spacing</span><span class="p">)</span>
    <span class="n">list_square_vertex_arrays_per_core</span><span class="p">,</span> <span class="n">list_parent_index_values</span><span class="p">,</span> <span class="n">total_rows</span><span class="p">,</span> <span class="n">total_columns</span> <span class="o">=</span> \
        <span class="n">split_grid</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span>
                   <span class="n">num_cores</span><span class="o">=</span><span class="n">num_cores</span><span class="p">)</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">num_cores</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">vertex_sublist</span><span class="p">,</span> <span class="n">index_sublist</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">list_square_vertex_arrays_per_core</span><span class="p">,</span> <span class="n">list_parent_index_values</span><span class="p">):</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">per_core_work</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span>
            <span class="n">coordinate_file_path</span><span class="p">,</span> <span class="n">trajectory_file_path</span><span class="p">,</span> <span class="n">vertex_sublist</span><span class="p">,</span> <span class="n">MDA_selection</span><span class="p">,</span> <span class="n">start_frame</span><span class="p">,</span> <span class="n">end_frame</span><span class="p">,</span>
            <span class="n">index_sublist</span><span class="p">,</span> <span class="n">maximum_delta_magnitude</span><span class="p">),</span> <span class="n">callback</span><span class="o">=</span><span class="n">log_result_to_parent</span><span class="p">)</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="n">dx_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">total_rows</span><span class="p">,</span> <span class="n">total_columns</span><span class="p">))</span>
    <span class="n">dy_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">total_rows</span><span class="p">,</span> <span class="n">total_columns</span><span class="p">))</span>
    <span class="c">#the parent_list_deltas is shaped like this: [ ([row_index,column_index],[dx,dy]), ... (...),...,]</span>
    <span class="k">for</span> <span class="n">index_array</span><span class="p">,</span> <span class="n">delta_array</span> <span class="ow">in</span> <span class="n">parent_list_deltas</span><span class="p">:</span>  <span class="c"># go through the list in the parent process and assign to the</span>
    <span class="c">#  appropriate positions in the dx and dy matrices:</span>
        <span class="c">#build in a filter to replace all values at the cap (currently between -8,8) with 0 to match Matthieu&#39;s code</span>
        <span class="c"># (I think eventually we&#39;ll reduce the cap to a narrower boundary though)</span>
        <span class="n">index_1</span> <span class="o">=</span> <span class="n">index_array</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">index_2</span> <span class="o">=</span> <span class="n">index_array</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">delta_array</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">maximum_delta_magnitude</span><span class="p">:</span>
            <span class="n">dx_array</span><span class="p">[</span><span class="n">index_1</span><span class="p">,</span> <span class="n">index_2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dx_array</span><span class="p">[</span><span class="n">index_1</span><span class="p">,</span> <span class="n">index_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">delta_array</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">maximum_delta_magnitude</span><span class="p">:</span>
            <span class="n">dy_array</span><span class="p">[</span><span class="n">index_1</span><span class="p">,</span> <span class="n">index_2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dy_array</span><span class="p">[</span><span class="n">index_1</span><span class="p">,</span> <span class="n">index_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c">#at Matthieu&#39;s request, we now want to calculate the average and standard deviation of the displacement values:</span>
    <span class="n">displacement_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx_array</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">dy_array</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">average_displacement</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">displacement_array</span><span class="p">)</span>
    <span class="n">standard_deviation_of_displacement</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">displacement_array</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">dx_array</span><span class="p">,</span> <span class="n">dy_array</span><span class="p">,</span> <span class="n">average_displacement</span><span class="p">,</span> <span class="n">standard_deviation_of_displacement</span><span class="p">)</span>

<span class="c"># if __name__ == &#39;__main__&#39;: #execute the main control function only if this file is called as a top-level script</span>
<span class="c">#will probably mostly use this for testing on a trajectory:</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">MDAnalysis 0.10.0-dev documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../MDAnalysis.html" >MDAnalysis</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Joshua Adelman,
    Christian Beckstein (logo), Alejandro Bernardin, Sébastien Buchoux,
    David Caplan, Matthieu Chavent, Xavier Deupi, Jan Domański, David L. Dotson
    Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar,
    Benjamin Hall, Joe Jordan, Jinju Lu, Robert McGibbon, Alex Nesterenko,
    Manuel Nuno Melo, Caio S. Souza, Danny Parton, Joshua L. Phillips, Tyler Reddy,
    Paul Rigor, Sean L. Seyler, Andy Somogyi, Lukas Stelzl, Zhuyi Xue,
    and Oliver Beckstein.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>