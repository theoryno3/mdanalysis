

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.analysis.contacts &mdash; MDAnalysis 0.10.0-dev documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.10.0-dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.10.0-dev documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.10.0-dev documentation" href="../../../index.html" />
    <link rel="up" title="MDAnalysis" href="../../MDAnalysis.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">MDAnalysis 0.10.0-dev documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../MDAnalysis.html" accesskey="U">MDAnalysis</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for MDAnalysis.analysis.contacts</h1><div class="highlight"><pre>
<span class="c"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8</span>
<span class="c">#</span>
<span class="c"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver Beckstein</span>
<span class="c"># and contributors (see AUTHORS for the full list)</span>
<span class="c">#</span>
<span class="c"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c">#</span>
<span class="c"># Please cite your use of MDAnalysis in published work:</span>
<span class="c">#</span>
<span class="c"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c">#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Native contacts analysis --- :mod:`MDAnalysis.analysis.contacts`</span>
<span class="sd">================================================================</span>

<span class="sd">:Author: Oliver Beckstein</span>
<span class="sd">:Year: 2010</span>
<span class="sd">:Copyright: GNU Public License v3</span>

<span class="sd">Analysis of native contacts *q* over a trajectory.</span>

<span class="sd">* a &quot;contact&quot; exists between two atoms *i* and *j* if the distance between them is</span>
<span class="sd">  smaller than a given *radius*</span>

<span class="sd">* a &quot;native contact&quot; exists between *i* and *j* if a contact exists and if the</span>
<span class="sd">  contact also exists between the equivalent atoms in a reference structure or</span>
<span class="sd">  conformation</span>

<span class="sd">The &quot;fraction of native contacts&quot; *q(t)* is a number between 0 and 1 and</span>
<span class="sd">calculated as the total number of native contacts for a given time frame</span>
<span class="sd">divided by the total number of contacts in the reference structure.</span>

<span class="sd">Classes are available for two somewhat different ways to perform a contact</span>
<span class="sd">analysis:</span>

<span class="sd">1. Contacts between two groups of atoms are defined with</span>
<span class="sd">   :class:`ContactAnalysis1`), which allows one to calculate *q(t)* over</span>
<span class="sd">   time. This is especially useful in order to look at native contacts during</span>
<span class="sd">   an equilibrium simulation where one can also look at the average matrix of</span>
<span class="sd">   native contacts (see :meth:`ContactAnalysis1.plot_qavg`).</span>

<span class="sd">2. Contacts are defined within one group in a protein (e.g. all C-alpha atoms)</span>
<span class="sd">   but relative to *two different conformations* 1 and 2, using</span>
<span class="sd">   :class:`ContactAnalysis`. This allows one to do a *q1-q2* analysis that</span>
<span class="sd">   shows how native contacts of state 1 change in comparison to native contacts</span>
<span class="sd">   of state 2.  Transition pathways have been analyzed in terms of these two</span>
<span class="sd">   variables q1 and q2 that relate to the native contacts in the end states of</span>
<span class="sd">   the transition.</span>

<span class="sd">.. SeeAlso:: See http://lorentz.dynstr.pasteur.fr/joel/adenylate.php for an</span>
<span class="sd">   example of contact analysis applied to MinActionPath trajectories of AdK</span>
<span class="sd">   (although this was *not* performed with MDAnalysis --- it&#39;s provided as a</span>
<span class="sd">   very good illustrative example).</span>


<span class="sd">Examples</span>
<span class="sd">--------</span>

<span class="sd">One-dimensional contact analysis</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="sd">As an example we analyze the opening (&quot;unzipping&quot;) of salt bridges</span>
<span class="sd">when the AdK enzyme opens up; this is one of the example trajectories</span>
<span class="sd">in MDAnalysis. ::</span>

<span class="sd">    import MDAnalysis</span>
<span class="sd">    import MDAnalysis.analysis.contacts</span>
<span class="sd">    from MDAnalysis.tests.datafiles import PSF,DCD</span>

<span class="sd">    # example trajectory (transition of AdK from closed to open)</span>
<span class="sd">    u = MDAnalysis.Universe(PSF,DCD)</span>

<span class="sd">    # crude definition of salt bridges as contacts between NH/NZ in ARG/LYS and OE*/OD* in ASP/GLU.</span>
<span class="sd">    # You might want to think a little bit harder about the problem before using this for real work.</span>
<span class="sd">    sel_basic = &quot;(resname ARG or resname LYS) and (name NH* or name NZ)&quot;</span>
<span class="sd">    sel_acidic = &quot;(resname ASP or resname GLU) and (name OE* or name OD*)&quot;</span>

<span class="sd">    # reference groups (first frame of the trajectory, but you could also use a separate PDB, eg crystal structure)</span>
<span class="sd">    acidic = u.selectAtoms(sel_acidic)</span>
<span class="sd">    basic = u.selectAtoms(sel_basic)</span>

<span class="sd">    # set up analysis of native contacts (&quot;salt bridges&quot;); salt bridges have a distance &lt;6 A</span>
<span class="sd">    CA1 = MDAnalysis.analysis.contacts.ContactAnalysis1(u, selection=(sel_acidic, sel_basic), refgroup=(acidic,</span>
<span class="sd">    basic), radius=6.0, outfile=&quot;qsalt.dat&quot;)</span>

<span class="sd">    # iterate through trajectory and perform analysis of &quot;native contacts&quot; q</span>
<span class="sd">    # (force=True ignores any previous results, force=True is useful when testing)</span>
<span class="sd">    CA1.run(force=True)</span>

<span class="sd">    # plot time series q(t) [possibly do &quot;import pylab; pylab.clf()&quot; do clear the figure first...]</span>
<span class="sd">    CA1.plot(filename=&quot;adk_saltbridge_contact_analysis1.pdf&quot;, linewidth=3, color=&quot;blue&quot;)</span>

<span class="sd">    # or plot the data in qsalt.dat yourself.</span>
<span class="sd">    CA1.plot_qavg(filename=&quot;adk_saltbridge_contact_analysis1_matrix.pdf&quot;)</span>

<span class="sd">The first graph shows that when AdK opens, about 20% of the salt</span>
<span class="sd">bridges that existed in the closed state disappear when the enzyme</span>
<span class="sd">opens. They open in a step-wise fashion (made more clear by the movie</span>
<span class="sd">http://sbcb.bioch.ox.ac.uk/oliver/Movies/AdK/AdK_zipper_cartoon.avi</span>
<span class="sd">(divx, on Mac use http://perian.org)).</span>

<span class="sd">The output graphs can be made prettier but if you look at the code</span>
<span class="sd">itself then you&#39;ll quickly figure out what to do. The qavg plot is the</span>
<span class="sd">matrix of all contacts, averaged over the trajectory. This plot makes</span>
<span class="sd">more sense for an equilibrium trajectory than for the example above</span>
<span class="sd">but is is included for illustration.</span>

<span class="sd">See the docs for :class:`ContactAnalysis1` for another example.</span>


<span class="sd">Two-dimensional contact analysis (q1-q2)</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="sd">Analyze a single DIMS transition of AdK between its closed and open</span>
<span class="sd">conformation and plot the trajectory projected on q1-q2::</span>

<span class="sd">  import MDAnalysis.analysis.contacts</span>
<span class="sd">  from MDAnalysis.tests.datafiles import *</span>
<span class="sd">  C = MDAnalysis.analysis.contacts.ContactAnalysis(PSF, DCD)</span>
<span class="sd">  C.run()</span>
<span class="sd">  C.plot()</span>

<span class="sd">Compare the resulting pathway to the `MinActionPath result for AdK`_.</span>

<span class="sd">.. _MinActionPath result for AdK:</span>
<span class="sd">   http://lorentz.dynstr.pasteur.fr/joel/adenylate.php</span>

<span class="sd">Classes</span>
<span class="sd">-------</span>

<span class="sd">.. autoclass:: ContactAnalysis</span>
<span class="sd">   :members:</span>
<span class="sd">.. autoclass:: ContactAnalysis1</span>
<span class="sd">   :members:</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">errno</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">bz2</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">izip</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">MDAnalysis</span>
<span class="kn">import</span> <span class="nn">MDAnalysis.core.distances</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.core.util</span> <span class="kn">import</span> <span class="n">openany</span>

<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s">&quot;MDAnalysis.analysis.contacts&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="ContactAnalysis"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis">[docs]</a><span class="k">class</span> <span class="nc">ContactAnalysis</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform a native contact analysis (&quot;q1-q2&quot;).</span>

<span class="sd">    The analysis of the trajectory is performed with the</span>
<span class="sd">    :meth:`ContactAnalysis.run` method. The result is stored in</span>
<span class="sd">    :attr:`ContactAnalysis.timeseries`. It is a numpy array which</span>
<span class="sd">    contains the frame number at index 0, q1 and q2 at index 1 and 2,</span>
<span class="sd">    and the total number of contacts in 3 and 4. ::</span>

<span class="sd">        frame  q1 q2  n1 n2</span>

<span class="sd">    The total number of contacts in the reference states 1 and 2 are</span>
<span class="sd">    stored in :attr:`ContactAnalysis.nref` (index 0 and 1).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topology</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">,</span> <span class="n">ref1</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ref2</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
                 <span class="n">targetdir</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">curdir</span><span class="p">,</span> <span class="n">infix</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">selection</span><span class="o">=</span><span class="s">&quot;name CA&quot;</span><span class="p">,</span> <span class="n">centroids</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate native contacts from two reference structures.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *topology*</span>
<span class="sd">            psf or pdb file</span>
<span class="sd">          *trajectory*</span>
<span class="sd">            dcd or xtc/trr file</span>
<span class="sd">          *ref1*</span>
<span class="sd">            structure of the reference conformation 1 (pdb); if ``None`` the *first*</span>
<span class="sd">            frame of the trajectory is chosen</span>
<span class="sd">          *ref2*</span>
<span class="sd">            structure of the reference conformation 2 (pdb); if ``None`` the *last*</span>
<span class="sd">            frame of the trajectory is chosen</span>
<span class="sd">          *radius*</span>
<span class="sd">            contacts are deemed any Ca within radius [8 A]</span>
<span class="sd">          *targetdir*</span>
<span class="sd">            output files are saved there [.]</span>
<span class="sd">          *infix*</span>
<span class="sd">            additional tag string that is inserted into the output filename of the</span>
<span class="sd">            data file [&quot;&quot;]</span>
<span class="sd">          *selection*</span>
<span class="sd">            MDAnalysis selection string that selects the particles of</span>
<span class="sd">            interest; the default is to only select the C-alpha atoms</span>
<span class="sd">            in *ref1* and *ref*2 [&quot;name CA&quot;]</span>

<span class="sd">           .. Note:: If *selection* produces more than one atom per</span>
<span class="sd">                     residue then you will get multiple contacts per</span>
<span class="sd">                     residue unless you also set *centroids* = ``True``</span>
<span class="sd">          *centroids*</span>
<span class="sd">            If set to ``True``, use the centroids for the selected atoms on a</span>
<span class="sd">            per-residue basis to compute contacts. This allows, for instance</span>
<span class="sd">            defining the sidechains as *selection* and then computing distances</span>
<span class="sd">            between sidechain centroids.</span>

<span class="sd">        The function calculates the percentage of native contacts *q1* and *q2*</span>
<span class="sd">        along a trajectory. &quot;Contacts&quot; are defined as the number of Ca atoms (or</span>
<span class="sd">        per-residue *centroids* of a user defined *selection*) within *radius* of</span>
<span class="sd">        a primary Ca. *q1* is the fraction of contacts relative to the reference</span>
<span class="sd">        state 1 (typically the starting conformation of the trajectory) and *q2*</span>
<span class="sd">        is the fraction of contacts relative to the conformation 2.</span>

<span class="sd">        The timeseries is written to a bzip2-compressed file in *targetdir*</span>
<span class="sd">        named &quot;basename(*trajectory*)*infix*_q1q2.dat.bz2&quot; and is also</span>
<span class="sd">        accessible as the attribute</span>
<span class="sd">        :attr:`ContactAnalysis.timeseries`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">topology</span> <span class="o">=</span> <span class="n">topology</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span> <span class="o">=</span> <span class="n">trajectory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span> <span class="o">=</span> <span class="n">targetdir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force</span> <span class="o">=</span> <span class="n">force</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">selection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="n">centroids</span>

        <span class="n">trajectorybase</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">trajectory</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">trajectorybase</span> <span class="o">+</span> <span class="n">infix</span> <span class="o">+</span> <span class="s">&#39;_q1q2.dat&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_bz2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">+</span> <span class="s">&#39;.bz2&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># final result</span>

        <span class="c"># short circuit if output file already exists: skip everything</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_exists</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span>  <span class="c"># do not bother reading any data or initializing arrays... !!</span>
        <span class="c"># don&#39;t bother if trajectory is empty (can lead to segfaults so better catch it)</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stats</span><span class="o">.</span><span class="n">st_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;trajectory = </span><span class="si">%(trajectory)s</span><span class="s"> is empty, skipping...&#39;</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span>
        <span class="c"># under normal circumstances we do not skip</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c"># expensive initialization starts with building Universes :-)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ref1</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ref1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="n">trajectorybase</span> <span class="o">+</span> <span class="s">&#39;_first.pdb&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># extract first frame</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ref1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref1</span> <span class="o">=</span> <span class="n">ref1</span>
        <span class="k">if</span> <span class="n">ref2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ref2</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="n">trajectorybase</span> <span class="o">+</span> <span class="s">&#39;_last.pdb&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># extract last frame</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ref2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># rewind, just in case...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref2</span> <span class="o">=</span> <span class="n">ref2</span>

        <span class="n">r1</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref1</span><span class="p">)</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref2</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">selectAtoms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">)</span>
        <span class="n">ca1</span> <span class="o">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">selectAtoms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">)</span>
        <span class="n">ca2</span> <span class="o">=</span> <span class="n">r2</span><span class="o">.</span><span class="n">selectAtoms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">)</span>

        <span class="c"># NOTE: self_distance_array() produces a 1D array; this works here</span>
        <span class="c">#       but is not the same as the 2D output from distance_array()!</span>
        <span class="c">#       See the docs for self_distance_array().</span>
        <span class="n">dref</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_distance_array</span><span class="p">(</span><span class="n">ca1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_distance_array</span><span class="p">(</span><span class="n">ca2</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qref</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">qarray</span><span class="p">(</span><span class="n">dref</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">qarray</span><span class="p">(</span><span class="n">dref</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nref</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">qref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">qref</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">dref</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qtmp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">)</span>  <span class="c"># pre-allocated array</span>

<div class="viewcode-block" id="ContactAnalysis.get_distance_array"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis.get_distance_array">[docs]</a>    <span class="k">def</span> <span class="nf">get_distance_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the self_distance_array for atoms in group *g*.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">           *results*</span>
<span class="sd">              passed on to :func:`MDAnalysis.core.distances.self_distance_array`</span>
<span class="sd">              as a preallocated array</span>
<span class="sd">           *centroids*</span>
<span class="sd">              ``True``: calculate per-residue centroids from the selected atoms;</span>
<span class="sd">              ``False``: consider each atom separately; ``None``: use the class</span>
<span class="sd">              default for *centroids* [``None``]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;centroids&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroids</span> <span class="k">if</span> <span class="n">centroids</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">centroids</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">centroids</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">positions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># centroids per residue (but only including the selected atoms)</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">residue</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span> <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;residue&quot;</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">self_distance_array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ContactAnalysis.output_exists"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis.output_exists">[docs]</a>    <span class="k">def</span> <span class="nf">output_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if default output file already exists.</span>

<span class="sd">        Disable with force=True (will always return False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">)</span> <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_bz2</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">force</span> <span class="ow">or</span> <span class="n">force</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ContactAnalysis.run"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Analyze trajectory and produce timeseries.</span>

<span class="sd">        Stores results in :attr:`ContactAnalysis.timeseries` (if</span>
<span class="sd">        store=True) and writes them to a bzip2-compressed data file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_exists</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">):</span>
            <span class="kn">import</span> <span class="nn">warnings</span>

            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;File </span><span class="si">%(output)r</span><span class="s"> or </span><span class="si">%(output_bz2)r</span><span class="s"> already exists, loading </span><span class="si">%(trajectory)r</span><span class="s">.&quot;</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_bz2</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="n">outbz2</span> <span class="o">=</span> <span class="n">bz2</span><span class="o">.</span><span class="n">BZ2File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_bz2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">,</span> <span class="n">buffering</span><span class="o">=</span><span class="mi">8192</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">outbz2</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;# q1-q2 analysis</span><span class="se">\n</span><span class="s"># nref1 = </span><span class="si">%d</span><span class="se">\n</span><span class="s"># nref2 = </span><span class="si">%d</span><span class="se">\n</span><span class="s">&quot;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nref</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nref</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">outbz2</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;# frame  q1  q2   n1  n2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
            <span class="n">records</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">:</span>
                <span class="n">frame</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span>
                <span class="c"># use pre-allocated distance array to save a little bit of time</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_distance_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ca</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">)</span>
                <span class="n">n1</span><span class="p">,</span> <span class="n">q1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qN</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_qtmp</span><span class="p">)</span>
                <span class="n">n2</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qN</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_qtmp</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
                    <span class="n">records</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">frame</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">))</span>
                <span class="n">outbz2</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%(frame)4d</span><span class="s">  </span><span class="si">%(q1)8.6f</span><span class="s"> </span><span class="si">%(q2)8.6f</span><span class="s">  </span><span class="si">%(n1)5d</span><span class="s"> </span><span class="si">%(n2)5d</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">())</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">outbz2</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">records</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_bz2</span>
</div>
<div class="viewcode-block" id="ContactAnalysis.qarray"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis.qarray">[docs]</a>    <span class="k">def</span> <span class="nf">qarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return distance array with True for contacts.</span>

<span class="sd">        If *out* is supplied as a pre-allocated array of the correct</span>
<span class="sd">        shape then it is filled instead of allocating a new one in</span>
<span class="sd">        order to increase performance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
</div>
<div class="viewcode-block" id="ContactAnalysis.qN"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis.qN">[docs]</a>    <span class="k">def</span> <span class="nf">qN</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate native contacts relative to state n.</span>

<span class="sd">        If *out* is supplied as a pre-allocated array of the correct</span>
<span class="sd">        shape then it is filled instead of allocating a new one in</span>
<span class="sd">        order to increase performance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qref</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qref</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">out</span><span class="p">)</span>
        <span class="n">contacts</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">contacts</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">contacts</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nref</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="ContactAnalysis.load"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load the data file.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">MDAnalysis.core.util</span> <span class="kn">import</span> <span class="n">openany</span>

        <span class="n">records</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">openany</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;#&#39;</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">records</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">records</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
</div>
<div class="viewcode-block" id="ContactAnalysis.plot"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot q1-q2.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="n">plot</span><span class="p">,</span> <span class="n">xlabel</span><span class="p">,</span> <span class="n">ylabel</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&#39;color&#39;</span><span class="p">,</span> <span class="s">&#39;black&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;No timeseries data; do &#39;ContactAnalysis.run(store=True)&#39; first.&quot;</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">xlabel</span><span class="p">(</span><span class="s">r&quot;$q_1$&quot;</span><span class="p">)</span>
        <span class="n">ylabel</span><span class="p">(</span><span class="s">r&quot;$q_2$&quot;</span><span class="p">)</span>


<span class="c"># ContactAnalysis1 is a (hopefully) temporary hack. It should be unified with ContactAnalysis</span>
<span class="c"># or either should be derived from a base class because many methods are copy&amp;paste with</span>
<span class="c"># minor changes (mostly for going from q1q2 -&gt; q1 only).</span>
<span class="c"># If ContactAnalysis is enhanced to accept two references then this should be even easier.</span>
<span class="c"># It might also be worthwhile making a simpler class that just does the q calculation</span>
<span class="c"># and use it for both reference and trajectory data.</span>
</div></div>
<div class="viewcode-block" id="ContactAnalysis1"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1">[docs]</a><span class="k">class</span> <span class="nc">ContactAnalysis1</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform a very flexible native contact analysis with respect to a single reference.</span>

<span class="sd">    .. class:: ContactAnalysis1(topology, trajectory[,selection[,refgroup[,radius[,outfile]]]])</span>

<span class="sd">    .. class:: ContactAnalysis1(universe[,selection[,refgroup[,radius[,outfile]]]])</span>


<span class="sd">    This analysis class allows one to calculate the fraction of native contacts</span>
<span class="sd">    *q* between two arbitrary groups of atoms with respect to an arbitrary</span>
<span class="sd">    reference structure. For instance, as a reference one could take a crystal</span>
<span class="sd">    structure of a complex, and as the two groups atoms one selects two</span>
<span class="sd">    molecules A and B in the complex. Then the question to be answered by *q*</span>
<span class="sd">    is, is which percentage of the contacts between A and B persist during the simulation.</span>

<span class="sd">    First prepare :class:`~MDAnalysis.core.AtomGroup.AtomGroup` selections for</span>
<span class="sd">    the reference atoms; this example uses some arbitrary selections::</span>

<span class="sd">      ref = Universe(&#39;crystal.pdb&#39;)</span>
<span class="sd">      refA = re.selectAtoms(&#39;name CA and segid A and resid 6:100&#39;)</span>
<span class="sd">      refB = re.selectAtoms(&#39;name CA and segid B and resid 1:40&#39;)</span>

<span class="sd">    Load the trajectory::</span>

<span class="sd">      u = Universe(topology, trajectory)</span>

<span class="sd">    We then need two selection strings *selA* and *selB* that, when applied as</span>
<span class="sd">    ``u.selectAtoms(selA)`` produce a list of atoms that is equivalent to the</span>
<span class="sd">    reference (i.e. ``u.selectAtoms(selA)`` must select the same atoms as</span>
<span class="sd">    ``refA`` in this example)::</span>

<span class="sd">      selA = &#39;name CA and resid 1:95&#39;     # corresponds to refA</span>
<span class="sd">      selB = &#39;name CA and resid 150:189&#39;  # corresponds to refB</span>

<span class="sd">    .. Note::</span>

<span class="sd">       It is the user&#39;s responsibility to provide a reference group</span>
<span class="sd">       (or groups) that describe equivalent atoms to the ones selected</span>
<span class="sd">       by *selection*.</span>

<span class="sd">    Now we are ready to set up the analysis::</span>

<span class="sd">      CA1 = ContactAnalysis1(u, selection=(selA,selB), refgroup=(refA,refB), radius=8.0, outfile=&quot;q.dat&quot;)</span>

<span class="sd">    If the groups do not match in length then a :exc:`ValueError` is raised.</span>

<span class="sd">    The analysis across the whole trajectory is performed with ::</span>

<span class="sd">      CA1.run()</span>

<span class="sd">    Results are saved to *outfile* (``framenumber q N`` per line) and</span>
<span class="sd">    can also be plotted with ::</span>

<span class="sd">      CA1.plot()        # plots the time series q(t)</span>
<span class="sd">      CA1.plot_qavg()   # plots the matrix of average contacts &lt;q&gt;</span>

<span class="sd">    **Description of computed values** in the output file:</span>

<span class="sd">    *N*</span>
<span class="sd">         number of native contacts</span>

<span class="sd">    *q*</span>
<span class="sd">         fraction of native contacts relative to the reference</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate native contacts within a group or between two groups.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *topology*</span>
<span class="sd">            psf or pdb file</span>
<span class="sd">          *trajectory*</span>
<span class="sd">            dcd or xtc/trr file</span>
<span class="sd">          *universe*</span>
<span class="sd">            instead of a topology/trajectory combination, one can also supply</span>
<span class="sd">            a :class:`MDAnalysis.Universe`</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *selection*</span>
<span class="sd">            selection string that determines which distances are calculated; if this</span>
<span class="sd">            is a tuple or list with two entries then distances are calculated between</span>
<span class="sd">            these two different groups [&quot;name CA or name B*&quot;]</span>
<span class="sd">          *refgroup*</span>
<span class="sd">            reference group, either a single :class:`~MDAnalysis.core.AtomGroup.AtomGroup`</span>
<span class="sd">            (if there is only a single *selection*) or a list of two such groups.</span>
<span class="sd">            The reference contacts are directly computed from *refgroup* and hence</span>
<span class="sd">            the atoms in the reference group(s) must be equivalent to the ones produced</span>
<span class="sd">            by the *selection* on the input trajectory.</span>
<span class="sd">          *radius*</span>
<span class="sd">            contacts are deemed any atoms within radius [8.0 A]</span>
<span class="sd">          *outfile*</span>
<span class="sd">            name of the output file; with the gz or bz2 suffix, a compressed</span>
<span class="sd">            file is written. The average &lt;q&gt; is written to a second, gzipped</span>
<span class="sd">            file that has the same name with &#39;array&#39; included. E.g. for the</span>
<span class="sd">            default name &quot;q1.dat.gz&quot; the &lt;q&gt; file will be &quot;q1.array.gz&quot;. The</span>
<span class="sd">            format is the matrix in column-row format, i.e. selection 1</span>
<span class="sd">            residues are the columns and selection 2 residues are rows. The</span>
<span class="sd">            file can be read with :func:`numpy.loadtxt`.  [&quot;q1.dat.gz&quot;]</span>

<span class="sd">        The function calculates the percentage of native contacts q1</span>
<span class="sd">        along a trajectory. &quot;Contacts&quot; are defined as the number of atoms</span>
<span class="sd">        within *radius* of a given other atom. *q1* is the fraction of contacts</span>
<span class="sd">        relative to the reference state 1 (typically the starting conformation</span>
<span class="sd">        of the trajectory).</span>

<span class="sd">        The timeseries is written to a file *outfile* and is also accessible as</span>
<span class="sd">        the attribute :attr:`ContactAnalysis1.timeseries`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># XX or should I use as input</span>
        <span class="c">#   sel = (group1, group2), ref = (refgroup1, refgroup2)</span>
        <span class="c"># and get the universe from sel?</span>
        <span class="c"># Currently it&#39;s a odd hybrid.</span>
        <span class="c">#</span>
        <span class="c"># Enhancements:</span>
        <span class="c"># - select contact pairs to write out as a timecourse</span>
        <span class="c"># - make this selection based on qavg</span>
        <span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">splitext</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">selection_strings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_tuple2</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;selection&#39;</span><span class="p">,</span> <span class="s">&quot;name CA or name B*&quot;</span><span class="p">),</span> <span class="s">&quot;selection&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">references</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_tuple2</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;refgroup&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="s">&quot;refgroup&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;radius&#39;</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;targetdir&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">curdir</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;outfile&#39;</span><span class="p">,</span> <span class="s">&quot;q1.dat.gz&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outarray</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s">&quot;.array.gz&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;force&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># final result</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filenames</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">asUniverse</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">selections</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">selectAtoms</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection_strings</span><span class="p">]</span>

        <span class="c"># sanity checkes</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;a reference AtomGroup must be supplied&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ref</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">izip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selections</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection_strings</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ref</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">numberOfAtoms</span><span class="p">()</span> <span class="o">!=</span> <span class="n">sel</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">numberOfAtoms</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;selection=</span><span class="si">%r</span><span class="s">: Number of atoms differ between &quot;</span>
                                 <span class="s">&quot;reference (</span><span class="si">%d</span><span class="s">) and trajectory (</span><span class="si">%d</span><span class="s">)&quot;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">numberOfAtoms</span><span class="p">(),</span> <span class="n">sel</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">numberOfAtoms</span><span class="p">()))</span>

        <span class="c"># compute reference contacts</span>
        <span class="n">dref</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">distance_array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coordinates</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qarray</span><span class="p">(</span><span class="n">dref</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qref</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c"># setup arrays for the trajectory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">dref</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qtmp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">)</span>  <span class="c"># pre-allocated array</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">qavg</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_return_tuple2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%(name)s</span><span class="s"> must be a single object or a tuple/list with two objects &quot;</span>
                             <span class="s">&quot;and not </span><span class="si">%(x)r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">())</span>

<div class="viewcode-block" id="ContactAnalysis1.output_exists"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1.output_exists">[docs]</a>    <span class="k">def</span> <span class="nf">output_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if default output file already exists.</span>

<span class="sd">        Disable with force=True (will always return False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">force</span> <span class="ow">or</span> <span class="n">force</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ContactAnalysis1.run"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">start_frame</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">end_frame</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">step_value</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Analyze trajectory and produce timeseries.</span>

<span class="sd">        Stores results in :attr:`ContactAnalysis1.timeseries` (if store=True)</span>
<span class="sd">        and writes them to a data file. The average q is written to a second</span>
<span class="sd">        data file.</span>
<span class="sd">        *start_frame*</span>
<span class="sd">            The value of the first frame number in the trajectory to be used (default: frame 1)</span>
<span class="sd">        *end_frame*</span>
<span class="sd">            The value of the last frame number in the trajectory to be used (default: None -- use all frames)</span>
<span class="sd">        *step_value*</span>
<span class="sd">            The number of frames to skip during trajectory iteration (default: use every frame)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_exists</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">):</span>
            <span class="kn">import</span> <span class="nn">warnings</span>

            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;File </span><span class="si">%r</span><span class="s"> already exists, loading it INSTEAD of trajectory </span><span class="si">%r</span><span class="s">. &quot;</span>
                          <span class="s">&quot;Use force=True to overwrite the output file. &quot;</span> <span class="o">%</span>
                          <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">with</span> <span class="n">openany</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;# q1 analysis</span><span class="se">\n</span><span class="s"># nref = </span><span class="si">%d</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nref</span><span class="p">))</span>
            <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;# frame  q1  n1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
            <span class="n">records</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qavg</span> <span class="o">*=</span> <span class="mi">0</span>  <span class="c"># average contact existence</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selections</span>
            <span class="c"># determine the end_frame value to use:</span>
            <span class="n">total_frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">numframes</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">end_frame</span><span class="p">:</span>
                <span class="c"># use the total number of frames in trajectory if no final value specified</span>
                <span class="n">end_frame</span> <span class="o">=</span> <span class="n">total_frames</span>
            <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">start_frame</span><span class="p">:</span><span class="n">end_frame</span><span class="p">:</span><span class="n">step_value</span><span class="p">]:</span>
                <span class="n">frame</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span>
                <span class="c"># use pre-allocated distance array to save a little bit of time</span>
                <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">distance_array</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span> <span class="n">B</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span> <span class="n">result</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">)</span>
                <span class="n">n1</span><span class="p">,</span> <span class="n">q1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qN</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_qtmp</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qavg</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span>
                <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
                    <span class="n">records</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">frame</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">n1</span><span class="p">))</span>
                <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%(frame)4d</span><span class="s">  </span><span class="si">%(q1)8.6f</span><span class="s"> </span><span class="si">%(n1)5d</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">records</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">numframes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">total_frames</span><span class="p">)[</span><span class="n">start_frame</span><span class="p">:</span><span class="n">end_frame</span><span class="p">:</span><span class="n">step_value</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qavg</span> <span class="o">/=</span> <span class="n">numframes</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outarray</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qavg</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s">&quot;</span><span class="si">%8.6f</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span>
</div>
<div class="viewcode-block" id="ContactAnalysis1.qarray"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1.qarray">[docs]</a>    <span class="k">def</span> <span class="nf">qarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return distance array with True for contacts.</span>

<span class="sd">        *d* is the matrix of distances. The method uses the value of</span>
<span class="sd">        :attr:`ContactAnalysis1.radius` to determine if a ``distance &lt; radius``</span>
<span class="sd">        is considered a contact.</span>

<span class="sd">        If *out* is supplied as a pre-allocated array of the correct</span>
<span class="sd">        shape then it is filled instead of allocating a new one in</span>
<span class="sd">        order to increase performance.</span>

<span class="sd">        This method is typically only used internally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
</div>
<div class="viewcode-block" id="ContactAnalysis1.qN"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1.qN">[docs]</a>    <span class="k">def</span> <span class="nf">qN</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate native contacts relative to reference state.</span>

<span class="sd">        *q* is the matrix of contacts (e.g. :attr:`~ContactAnalysis1.q`).</span>

<span class="sd">        If *out* is supplied as a pre-allocated array of the correct</span>
<span class="sd">        shape then it is filled instead of allocating a new one in</span>
<span class="sd">        order to increase performance.</span>

<span class="sd">        This method is typically only used internally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qref</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qref</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="n">contacts</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">contacts</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">contacts</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nref</span>
</div>
<div class="viewcode-block" id="ContactAnalysis1.load"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load the data file.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">MDAnalysis.core.util</span> <span class="kn">import</span> <span class="n">openany</span>

        <span class="n">records</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">openany</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;#&#39;</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">records</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">records</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qavg</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outarray</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">errno</span><span class="o">.</span><span class="n">ENOENT</span><span class="p">:</span>
                <span class="k">raise</span>
</div>
<div class="viewcode-block" id="ContactAnalysis1.plot"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot q(t).</span>

<span class="sd">        .. function:: ContactAnalysis1.plot([filename, ...])</span>

<span class="sd">        If *filename* is supplied then the figure is also written to file (the</span>
<span class="sd">        suffix determines the file type, e.g. pdf, png, eps, ...). All other</span>
<span class="sd">        keyword arguments are passed on to :func:`pylab.plot`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="n">plot</span><span class="p">,</span> <span class="n">xlabel</span><span class="p">,</span> <span class="n">ylabel</span><span class="p">,</span> <span class="n">savefig</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&#39;color&#39;</span><span class="p">,</span> <span class="s">&#39;black&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&#39;linewidth&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;No timeseries data; do &#39;ContactAnalysis.run(store=True)&#39; first.&quot;</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">xlabel</span><span class="p">(</span><span class="s">r&quot;frame number $t$&quot;</span><span class="p">)</span>
        <span class="n">ylabel</span><span class="p">(</span><span class="s">r&quot;native contacts $q_1$&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">filename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_plot_qavg_pcolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot :attr:`ContactAnalysis1.qavg`, the matrix of average native contacts.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="n">pcolor</span><span class="p">,</span> <span class="n">gca</span><span class="p">,</span> <span class="n">meshgrid</span><span class="p">,</span> <span class="n">xlabel</span><span class="p">,</span> <span class="n">ylabel</span><span class="p">,</span> <span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span><span class="p">,</span> <span class="n">colorbar</span><span class="p">,</span> <span class="n">savefig</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">resids</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">selections</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">resids</span><span class="p">()</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="n">pcolor</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qavg</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s">&#39;equal&#39;</span><span class="p">)</span>

        <span class="n">xlim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">ylim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

        <span class="n">xlabel</span><span class="p">(</span><span class="s">&quot;residues&quot;</span><span class="p">)</span>
        <span class="n">ylabel</span><span class="p">(</span><span class="s">&quot;residues&quot;</span><span class="p">)</span>

        <span class="n">colorbar</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">filename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

<div class="viewcode-block" id="ContactAnalysis1.plot_qavg"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1.plot_qavg">[docs]</a>    <span class="k">def</span> <span class="nf">plot_qavg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot :attr:`ContactAnalysis1.qavg`, the matrix of average native contacts.</span>

<span class="sd">        .. function:: ContactAnalysis1.plot_qavg([filename, ...])</span>

<span class="sd">        If *filename* is supplied then the figure is also written to file (the</span>
<span class="sd">        suffix determines the file type, e.g. pdf, png, eps, ...). All other</span>
<span class="sd">        keyword arguments are passed on to :func:`pylab.imshow`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="n">imshow</span><span class="p">,</span> <span class="n">xlabel</span><span class="p">,</span> <span class="n">ylabel</span><span class="p">,</span> <span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span><span class="p">,</span> <span class="n">colorbar</span><span class="p">,</span> <span class="n">cm</span><span class="p">,</span> <span class="n">clf</span><span class="p">,</span> <span class="n">savefig</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">resids</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">selections</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">resids</span><span class="p">()</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;origin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;lower&#39;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&#39;aspect&#39;</span><span class="p">,</span> <span class="s">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&#39;interpolation&#39;</span><span class="p">,</span> <span class="s">&#39;nearest&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&#39;vmin&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&#39;vmax&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&#39;cmap&#39;</span><span class="p">,</span> <span class="n">cm</span><span class="o">.</span><span class="n">hot</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&#39;extent&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>

        <span class="n">clf</span><span class="p">()</span>
        <span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qavg</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">xlim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">ylim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

        <span class="n">xlabel</span><span class="p">(</span><span class="s">&quot;residue from </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection_strings</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ylabel</span><span class="p">(</span><span class="s">&quot;residue from </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection_strings</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">colorbar</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">filename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">MDAnalysis 0.10.0-dev documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../MDAnalysis.html" >MDAnalysis</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Joshua Adelman,
    Christian Beckstein (logo), Alejandro Bernardin, Sébastien Buchoux,
    David Caplan, Matthieu Chavent, Xavier Deupi, Jan Domański, David L. Dotson
    Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar,
    Benjamin Hall, Joe Jordan, Jinju Lu, Robert McGibbon, Alex Nesterenko,
    Manuel Nuno Melo, Caio S. Souza, Danny Parton, Joshua L. Phillips, Tyler Reddy,
    Paul Rigor, Sean L. Seyler, Andy Somogyi, Lukas Stelzl, Zhuyi Xue,
    and Oliver Beckstein.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>