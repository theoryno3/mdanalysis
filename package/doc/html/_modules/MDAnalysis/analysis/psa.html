

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.analysis.psa &mdash; MDAnalysis 0.10.0-dev documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.10.0-dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.10.0-dev documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.10.0-dev documentation" href="../../../index.html" />
    <link rel="up" title="MDAnalysis" href="../../MDAnalysis.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">MDAnalysis 0.10.0-dev documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../MDAnalysis.html" accesskey="U">MDAnalysis</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for MDAnalysis.analysis.psa</h1><div class="highlight"><pre>
<span class="c"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8</span>
<span class="c">#</span>
<span class="c"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver Beckstein</span>
<span class="c"># and contributors (see AUTHORS for the full list)</span>
<span class="c">#</span>
<span class="c"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c">#</span>
<span class="c"># Please cite your use of MDAnalysis in published work:</span>
<span class="c">#</span>
<span class="c"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c">#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Calculating path similarity --- :mod:`MDAnalysis.analysis.psa`</span>
<span class="sd">==========================================================================</span>

<span class="sd">:Author: Sean Seyler</span>
<span class="sd">:Year: 2015</span>
<span class="sd">:Copyright: GNU Public License v3</span>

<span class="sd">.. versionadded:: 0.10.0</span>

<span class="sd">The module contains code to calculate the geometric similarity of</span>
<span class="sd">trajectories using path metrics such as the Hausdorff or Fréchet</span>
<span class="sd">distances. The path metrics are functions of two paths and return a</span>
<span class="sd">nonnegative number, i.e., a distance. Two paths are identical if their distance</span>
<span class="sd">is zero, and large distances indicate dissimilarity. Each path metric</span>
<span class="sd">is a function of the individual points (e.g., coordinate snapshots)</span>
<span class="sd">that comprise each path and, loosely speaking, identify the two points,</span>
<span class="sd">one per path of a pair of paths, where the paths deviate the most.</span>
<span class="sd">The distance between these points of maximal deviation is measured by</span>
<span class="sd">the root mean square deviation (RMSD), i.e., to compute structural</span>
<span class="sd">similarity.</span>

<span class="sd">One typically computes the pairwise similarity for an ensemble of paths to</span>
<span class="sd">produce a symmetric distance matrix, which can be clustered to, at a glance,</span>
<span class="sd">identify patterns in the trajectory data. To properly analyze a path ensemble,</span>
<span class="sd">one must select a suitable reference structure to which all paths (each</span>
<span class="sd">conformer in each path) will be universally aligned using the rotations</span>
<span class="sd">determined by the best-fit rmsds. Distances between paths and their structures</span>
<span class="sd">are then computed directly with no further alignment. This pre-processing step</span>
<span class="sd">is necessary to preserve the metric properties of the Hausdorff and Fréchet</span>
<span class="sd">metrics; using the best-fit rmsd on a pairwise basis does not generally</span>
<span class="sd">preserve the triangle inequality.</span>

<span class="sd">`PSAnalysisTutorial`_ outlines a typical application of PSA to a set of</span>
<span class="sd">trajectories, including doing proper alignment, performing distance comparisons,</span>
<span class="sd">and generating heat map-dendrogram plots from hierarchical clustering.</span>

<span class="sd">.. SeeAlso::</span>

<span class="sd">   :mod:`MDAnalysis.analysis.psa`</span>
<span class="sd">        contains functions to align a set of paths and compute clustered</span>
<span class="sd">        (Hausdorff or Fréchet) distance matrices</span>

<span class="sd">.. _`PSAnalysisTutorial`: https://github.com/Becksteinlab/PSAnalysisTutorial</span>

<span class="sd">Helper functions and variables</span>
<span class="sd">------------------------------</span>

<span class="sd">The following global variables are used by the functions and classes in this</span>
<span class="sd">module.</span>

<span class="sd">   hausdorff_names</span>
<span class="sd">   frechet_names</span>

<span class="sd">The following functions are used by the other functions in this module.</span>

<span class="sd">.. autofunction:: sqnorm</span>


<span class="sd">Classes, methods, and functions</span>
<span class="sd">-------------------------------</span>

<span class="sd">.. autofunction:: get_path_metric_func</span>
<span class="sd">.. autofunction:: hausdorff</span>
<span class="sd">.. autofunction:: frechet</span>

<span class="sd">.. autoclass:: Path</span>
<span class="sd">   :members:</span>

<span class="sd">   .. attribute:: u_original</span>

<span class="sd">      :class:`MDAnalysis.Universe` object with a trajectory</span>

<span class="sd">   .. attribute:: u_reference</span>

<span class="sd">      :class:`MDAnalysis.Universe` object containing a reference structure</span>

<span class="sd">   .. attribute:: ref_select</span>

<span class="sd">      string, selection for</span>
<span class="sd">      :meth:`~MDAnalysis.core.AtomGroup.AtomGroup.selectAtoms` to select frame</span>
<span class="sd">      from :attr:`Path.u_reference`</span>

<span class="sd">   .. attribute:: path_select</span>

<span class="sd">      string, selection for</span>
<span class="sd">      :meth:`~MDAnalysis.core.AtomGroup.AtomGroup.selectAtoms` to select atoms</span>
<span class="sd">      to compose :attr:`Path.path`</span>

<span class="sd">   .. attribute:: ref_frame</span>

<span class="sd">      int, frame index to select frame from :attr:`Path.u_reference`</span>

<span class="sd">   .. attribute:: u_fitted</span>

<span class="sd">      :class:`MDAnalysis.Universe` object with the fitted trajectory</span>

<span class="sd">   .. attribute:: path</span>

<span class="sd">      :class:`numpy.ndarray` object representation of the fitted trajectory</span>


<span class="sd">.. autoclass:: PSA</span>
<span class="sd">   :members:</span>

<span class="sd">   .. attribute:: universes</span>

<span class="sd">      list of :class:`MDAnalysis.Universe` objects containing trajectories</span>

<span class="sd">   .. attribute:: u_reference</span>

<span class="sd">      :class:`MDAnalysis.Universe` object containing a reference structure</span>

<span class="sd">   .. attribute:: ref_select</span>

<span class="sd">      string, selection for</span>
<span class="sd">      :meth:`~MDAnalysis.core.AtomGroup.AtomGroup.selectAtoms` to select frame</span>
<span class="sd">      from :attr:`PSA.u_reference`</span>

<span class="sd">   .. attribute:: path_select</span>

<span class="sd">      string, selection for</span>
<span class="sd">      :meth:`~MDAnalysis.core.AtomGroup.AtomGroup.selectAtoms` to select atoms</span>
<span class="sd">      to compose :attr:`Path.path`</span>

<span class="sd">   .. attribute:: ref_frame</span>

<span class="sd">      int, frame index to select frame from :attr:`Path.u_reference`</span>

<span class="sd">   .. attribute:: filename</span>

<span class="sd">      string, name of file to store calculated distance matrix (:attr:`PSA.D`)</span>

<span class="sd">   .. attribute:: paths</span>

<span class="sd">      list of :class:`numpy.ndarray` objects representing the set/ensemble of</span>
<span class="sd">      fitted trajectories</span>

<span class="sd">   .. attribute:: D</span>

<span class="sd">      string, name of file to store calculated distance matrix (:attr:`PSA.D`)</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">as</span> <span class="nn">sp</span>

<span class="kn">import</span> <span class="nn">MDAnalysis</span>
<span class="kn">import</span> <span class="nn">MDAnalysis.analysis.align</span>
<span class="kn">from</span> <span class="nn">MDAnalysis</span> <span class="kn">import</span> <span class="n">NoDataError</span>

<span class="kn">import</span> <span class="nn">cPickle</span> <span class="kn">as</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s">&#39;MDAnalysis.analysis.psa&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="get_path_metric_func"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.get_path_metric_func">[docs]</a><span class="k">def</span> <span class="nf">get_path_metric_func</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Selects a path metric function by name.</span>

<span class="sd">    :Arguments:</span>
<span class="sd">      *name*</span>
<span class="sd">         string, name of path metric</span>

<span class="sd">    :Returns:</span>
<span class="sd">      The path metric function specified by *name* (if found).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path_metrics</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&#39;hausdorff&#39;</span> <span class="p">:</span> <span class="n">hausdorff</span><span class="p">,</span>
            <span class="s">&#39;discrete_frechet&#39;</span> <span class="p">:</span> <span class="n">discrete_frechet</span>
    <span class="p">}</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">path_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">key</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Path metric {} not found. Valid selections: &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">path_metrics</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> <span class="k">print</span><span class="p">(</span><span class="s">&quot;  </span><span class="se">\&quot;</span><span class="s">{}</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="hausdorff"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.hausdorff">[docs]</a><span class="k">def</span> <span class="nf">hausdorff</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the Hausdorff distance between two paths.</span>

<span class="sd">    .. |3Dp| replace:: :math:`N_p\times N\times 3`</span>
<span class="sd">    .. |2Dp| replace:: :math:`N_p\times(3N)`</span>
<span class="sd">    .. |3Dq| replace:: :math:`N_q\times N\times 3`</span>
<span class="sd">    .. |2Dq| replace:: :math:`N_q\times(3N)`</span>

<span class="sd">    *P* (*Q*) is a :class:`numpy.ndarray` of :math:`N_p` (:math:`N_q`) time</span>
<span class="sd">    steps, :math:`N` atoms, and :math:`3N` coordinates (e.g.,</span>
<span class="sd">    :meth:`MDAnalysis.core.AtomGroup.AtomGroup.coordinates`). *P* (*Q*) has</span>
<span class="sd">    either shape |3Dp| (|3Dq|), or :|2Dp| (|2Dq|) in flattened form.</span>

<span class="sd">    :Arguments:</span>
<span class="sd">      *P*</span>
<span class="sd">         :class:`numpy.ndarray` representing a path</span>
<span class="sd">      *Q*</span>
<span class="sd">         :class:`numpy.ndarray` representing a path</span>
<span class="sd">      *N*</span>
<span class="sd">         int, number of atoms; if ``None`` then *P* and *Q* are each assumed to</span>
<span class="sd">         be a 3D :class:`numpy.ndarray`; else, they are 2D (flattened)</span>

<span class="sd">    :Returns:</span>
<span class="sd">      float, the Hausdorff distance between paths *P* and *Q*</span>

<span class="sd">    Example::</span>
<span class="sd">     &gt;&gt;&gt; u = Universe(PSF,DCD)</span>
<span class="sd">     &gt;&gt;&gt; mid = len(u.trajectory)/2</span>
<span class="sd">     &gt;&gt;&gt; ca = u.selectAtoms(&#39;name CA&#39;)</span>
<span class="sd">     &gt;&gt;&gt; P = numpy.array([</span>
<span class="sd">     ...                ca.positions for _ in u.trajectory[:mid:]</span>
<span class="sd">     ...              ]) # first half of trajectory</span>
<span class="sd">     &gt;&gt;&gt; Q = numpy.array([</span>
<span class="sd">     ...                ca.positions for _ in u.trajectory[mid::]</span>
<span class="sd">     ...              ]) # second half of trajectory</span>
<span class="sd">     &gt;&gt;&gt; hausdorff(P,Q)</span>
<span class="sd">     4.7786639840135905</span>
<span class="sd">     &gt;&gt;&gt; hausdorff(P,Q[::-1]) # hausdorff distance w/ reversed 2nd trajectory</span>
<span class="sd">     4.7786639840135905</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c"># number of atoms from 2nd dim of P</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sqnorm</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">Q</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">P</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">(</span> <span class="nb">max</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>                            \
                  <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="p">)</span> <span class="o">/</span> <span class="n">N</span>  <span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>

</div>
<div class="viewcode-block" id="discrete_frechet"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.discrete_frechet">[docs]</a><span class="k">def</span> <span class="nf">discrete_frechet</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the discrete Frechet distance between two paths.</span>

<span class="sd">    .. |3Dp| replace:: :math:`N_p\times N\times 3`</span>
<span class="sd">    .. |2Dp| replace:: :math:`N_p\times(3N)`</span>
<span class="sd">    .. |3Dq| replace:: :math:`N_q\times N\times 3`</span>
<span class="sd">    .. |2Dq| replace:: :math:`N_q\times(3N)`</span>

<span class="sd">    *P* (*Q*) is a :class:`numpy.ndarray` of :math:`N_p` (:math:`N_q`) time</span>
<span class="sd">    steps, :math:`N` atoms, and :math:`3N` coordinates (e.g.,</span>
<span class="sd">    :meth:`MDAnalysis.core.AtomGroup.AtomGroup.coordinates`). *P* (*Q*) has</span>
<span class="sd">    either shape |3Dp| (|3Dq|), or :|2Dp| (|2Dq|) in flattened form.</span>

<span class="sd">    :Arguments:</span>
<span class="sd">      *P*</span>
<span class="sd">         :class:`numpy.ndarray` representing a path</span>
<span class="sd">      *Q*</span>
<span class="sd">         :class:`numpy.ndarray` representing a path</span>
<span class="sd">      *N*</span>
<span class="sd">         int, number of atoms; if ``None`` then *P* and *Q* are each assumed to</span>
<span class="sd">         be a 3D :class:`numpy.ndarray`; else, they are 2D (flattened)</span>

<span class="sd">    :Returns:</span>
<span class="sd">      float, the discrete Frechet distance between paths *P* and *Q*</span>

<span class="sd">    Example::</span>
<span class="sd">     &gt;&gt;&gt; u = Universe(PSF,DCD)</span>
<span class="sd">     &gt;&gt;&gt; mid = len(u.trajectory)/2</span>
<span class="sd">     &gt;&gt;&gt; ca = u.selectAtoms(&#39;name CA&#39;)</span>
<span class="sd">     &gt;&gt;&gt; P = numpy.array([</span>
<span class="sd">     ...                ca.positions for _ in u.trajectory[:mid:]</span>
<span class="sd">     ...              ]) # first half of trajectory</span>
<span class="sd">     &gt;&gt;&gt; Q = numpy.array([</span>
<span class="sd">     ...                ca.positions for _ in u.trajectory[mid::]</span>
<span class="sd">     ...              ]) # second half of trajectory</span>
<span class="sd">     &gt;&gt;&gt; discrete_frechet(P,Q)</span>
<span class="sd">     4.7786639840135905</span>
<span class="sd">     &gt;&gt;&gt; discrete_frechet(P,Q[::-1]) # frechet distance w/ 2nd trj reversed 2nd</span>
<span class="sd">     6.8429011177113832</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c"># number of atoms from 2nd dim of P</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">Np</span><span class="p">,</span> <span class="n">Nq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sqnorm</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">Q</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">P</span><span class="p">])</span>
    <span class="n">ca</span> <span class="o">=</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">Np</span><span class="p">,</span> <span class="n">Nq</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">c</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the coupling distance for two partial paths formed by *P* and</span>
<span class="sd">        *Q*, where both begin at frame 0 and end (inclusive) at the respective</span>
<span class="sd">        frame indices :math:`i-1` and :math:`j-1`. The partial path of *P* (*Q*)</span>
<span class="sd">        up to frame *i* (*j*) is formed by the slicing ``P[0:i]`` (``Q[0:j]``).</span>

<span class="sd">        :func:`c` is called recursively to compute the coupling distance</span>
<span class="sd">        between the two full paths *P* and *Q*  (i.e., the discrete Frechet</span>
<span class="sd">        distance) in terms of coupling distances between their partial paths.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *i*</span>
<span class="sd">             int, partial path of *P* through final frame *i-1*</span>
<span class="sd">          *j*</span>
<span class="sd">             int, partial path of *Q* through final frame *j-1*</span>

<span class="sd">        :Returns:</span>
<span class="sd">          float, the coupling distance between partial paths ``P[0:i]`` and</span>
<span class="sd">          ``Q[0:j]``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">:</span> <span class="k">return</span> <span class="n">ca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">ca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="nb">min</span><span class="p">(</span><span class="n">c</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="n">c</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">c</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>     <span class="n">ca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">c</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>   <span class="n">ca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">c</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>         <span class="n">ca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span>        <span class="n">ca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">(</span> <span class="n">c</span><span class="p">(</span><span class="n">Np</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nq</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span> <span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>

</div>
<div class="viewcode-block" id="sqnorm"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.sqnorm">[docs]</a><span class="k">def</span> <span class="nf">sqnorm</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the sum of squares of elements along specified axes.</span>

<span class="sd">    :Arguments:</span>
<span class="sd">      *v*</span>
<span class="sd">         :class:`numpy.ndarray` of coordinates</span>
<span class="sd">      *axis*</span>
<span class="sd">         None or int or tuple of ints, optional</span>
<span class="sd">         Axis or axes along which a sum is performed. The default (axis = None)</span>
<span class="sd">         is perform a sum over all the dimensions of the input array. axis may</span>
<span class="sd">         be negative, in which case it counts from the last to the first axis.</span>

<span class="sd">    :Returns:</span>
<span class="sd">      float, the sum of the squares of the elements of *v* along *axis*</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

</div>
<span class="k">class</span> <span class="nc">PDBToBinaryTraj</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">universe</span><span class="p">,</span> <span class="n">output_type</span><span class="o">=</span><span class="s">&#39;.dcd&#39;</span><span class="p">,</span> <span class="n">infix</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span> <span class="o">=</span> <span class="n">universe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;new_top.pdb&#39;</span><span class="p">)</span> <span class="c"># write first frame as topology</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span>
        <span class="n">base</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">path</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">newname</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="n">infix</span> <span class="o">+</span> <span class="n">output_type</span>

    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Writer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">newname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="o">.</span><span class="n">numatoms</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">:</span>
            <span class="n">w</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
        <span class="n">w</span><span class="o">.</span><span class="n">close_trajectory</span><span class="p">()</span>


<div class="viewcode-block" id="Path"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.Path">[docs]</a><span class="k">class</span> <span class="nc">Path</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pre-process a :class:`MDAnalysis.Universe` object: (1) fit the</span>
<span class="sd">    trajectory to a reference structure, (2) convert fitted time series to a</span>
<span class="sd">    :class:`numpy.ndarray` representation of :attr:`Path.path`.</span>

<span class="sd">    The analysis is performed with :meth:`PSA.run` and stores the result</span>
<span class="sd">    in the :class:`numpy.ndarray` distance matrix :attr:`PSA.D`. :meth:`PSA.run`</span>
<span class="sd">    also generates a fitted trajectory and path from alignment of the original</span>
<span class="sd">    trajectories to a reference structure.</span>

<span class="sd">    .. versionadded:: 0.9.1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">universe</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">ref_select</span><span class="o">=</span><span class="s">&#39;name CA&#39;</span><span class="p">,</span>
                 <span class="n">path_select</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">,</span> <span class="n">ref_frame</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Setting up trajectory alignment and fitted path generation.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *universe*</span>
<span class="sd">             :class:`MDAnalysis.Universe` object containing a trajectory</span>
<span class="sd">          *reference*</span>
<span class="sd">             reference structure; :class:`MDAnalysis.Universe` object; if</span>
<span class="sd">             ``None`` then *traj* is used (uses the current time step of the</span>
<span class="sd">             object) [``None``]</span>
<span class="sd">          *ref_select*</span>
<span class="sd">             The selection to operate on for rms fitting; can be one of:</span>

<span class="sd">             1. any valid selection string for</span>
<span class="sd">                :meth:`~MDAnalysis.core.AtomGroup.AtomGroup.selectAtoms` that</span>
<span class="sd">                produces identical selections in *mobile* and *reference*; or</span>
<span class="sd">             2. a dictionary ``{&#39;mobile&#39;:sel1, &#39;reference&#39;:sel2}`` (the</span>
<span class="sd">                :func:`MDAnalysis.analysis.align.fasta2select` function returns</span>
<span class="sd">                such a dictionary based on a ClustalW_ or STAMP_ sequence</span>
<span class="sd">                alignment); or</span>
<span class="sd">             3. a tuple ``(sel1, sel2)``</span>

<span class="sd">             When using 2. or 3. with *sel1* and *sel2* then these selections</span>
<span class="sd">             can also each be a list of selection strings (to generate an</span>
<span class="sd">             AtomGroup with defined atom order as described under</span>
<span class="sd">             :ref:`ordered-selections-label`).</span>
<span class="sd">          *path_select*</span>
<span class="sd">             atom selection composing coordinates of (fitted) path; if ``None``</span>
<span class="sd">             then *path_select* is set to *ref_select* [``None``]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_original</span> <span class="o">=</span> <span class="n">universe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_reference</span> <span class="o">=</span> <span class="n">reference</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_select</span> <span class="o">=</span> <span class="n">ref_select</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_frame</span> <span class="o">=</span> <span class="n">ref_frame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_select</span> <span class="o">=</span> <span class="n">path_select</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">top_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_original</span><span class="o">.</span><span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trj_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_original</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">newtrj_name</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_fitted</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="bp">None</span>


<div class="viewcode-block" id="Path.fit_to_reference"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.Path.fit_to_reference">[docs]</a>    <span class="k">def</span> <span class="nf">fit_to_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">postfix</span><span class="o">=</span><span class="s">&#39;_fit&#39;</span><span class="p">,</span>
                         <span class="n">rmsdfile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">targetdir</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">curdir</span><span class="p">,</span>
                         <span class="n">mass_weighted</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">tol_mass</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Align each trajectory frame to the reference structure with</span>
<span class="sd">        :func:`MDAnalysis.analysis.align.rms_fit_trj`.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *filename*</span>
<span class="sd">             file name for the RMS-fitted trajectory or pdb; defaults to the</span>
<span class="sd">             original trajectory filename (from :attr:`Path.u_original`) with</span>
<span class="sd">             *prefix* prepended</span>
<span class="sd">          *prefix*</span>
<span class="sd">             prefix for auto-generating the new output filename</span>
<span class="sd">          *rmsdfile*</span>
<span class="sd">             file name for writing the RMSD time series [``None``]</span>
<span class="sd">          *mass_weighted*</span>
<span class="sd">             do a mass-weighted RMSD fit</span>
<span class="sd">          *tol_mass*</span>
<span class="sd">             Reject match if the atomic masses for matched atoms differ by more</span>
<span class="sd">             than *tol_mass* [0.1]</span>

<span class="sd">        :Returns:</span>
<span class="sd">          :class:`MDAnalysis.Universe` object containing a fitted trajectory</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">head</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trj_name</span><span class="p">)</span>
        <span class="n">oldname</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span> <span class="ow">or</span> <span class="n">oldname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">newtrj_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">targetdir</span><span class="p">,</span> <span class="n">filename</span> <span class="o">+</span> <span class="n">postfix</span> <span class="o">+</span> <span class="n">ext</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_reference</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_frame</span><span class="p">]</span> <span class="c"># select frame from ref traj</span>
        <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">align</span><span class="o">.</span><span class="n">rms_fit_trj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_original</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_reference</span><span class="p">,</span>
                <span class="n">select</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_select</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">newtrj_name</span><span class="p">,</span>
                <span class="n">rmsdfile</span><span class="o">=</span><span class="n">rmsdfile</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span> <span class="n">mass_weighted</span><span class="o">=</span><span class="n">mass_weighted</span><span class="p">,</span>
                <span class="n">tol_mass</span><span class="o">=</span><span class="n">tol_mass</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">newtrj_name</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Path.to_path"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.Path.to_path">[docs]</a>    <span class="k">def</span> <span class="nf">to_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitted</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generates a coordinate time series from the fitted universe</span>
<span class="sd">        trajectory.</span>

<span class="sd">        .. |Np| replace:: :math:`N_p`</span>
<span class="sd">        .. |3D| replace:: :math:`N_p\times N\times 3`</span>
<span class="sd">        .. |2D| replace:: :math:`N_p\times 3N`</span>

<span class="sd">        Given a selection of *N* atoms from *select*, the atomic positions for</span>
<span class="sd">        each frame in the fitted universe (:attr:`Path.u_fitted`) trajectory</span>
<span class="sd">        (with |Np| total frames) are appended sequentially to form a 3D or 2D</span>
<span class="sd">        (if *flat* is ``True``) :class:`numpy.ndarray` representation of the</span>
<span class="sd">        fitted trajectory (with dimensions |3D| or |2D|, respectively).</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *fitted*</span>
<span class="sd">             construct a :attr:`Path.path` from the :attr:`Path.u_fitted`</span>
<span class="sd">             trajectory; if ``False`` then :attr:`Path.path` is generated with</span>
<span class="sd">             the trajectory from :attr:`Path.u_original` [``False``]</span>
<span class="sd">          *select*</span>
<span class="sd">             the selection for constructing the coordinates of each frame in</span>
<span class="sd">             :attr:`Path.path`; if ``None`` then :attr:`Path.path_select`</span>
<span class="sd">             is used, else it is overridden by *select* [``None``]</span>
<span class="sd">          *flat*</span>
<span class="sd">             represent :attr:`Path.path` as a 2D (|2D|) :class:`numpy.ndarray`; if</span>
<span class="sd">             ``False`` then :attr:`Path.path` is a 3D (|3D|)</span>
<span class="sd">             :class:`numpy.ndarray` [``False``]</span>

<span class="sd">        :Returns:</span>
<span class="sd">          :class:`numpy.ndarray` representing a time series of atomic positions</span>
<span class="sd">          of an :class:`MDAnalysis.core.AtomGroup.AtomGroup` selection from</span>
<span class="sd">          :attr:`Path.u_fitted.trajectory`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">select</span> <span class="o">=</span> <span class="n">select</span> <span class="k">if</span> <span class="n">select</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_select</span>
        <span class="k">if</span> <span class="n">fitted</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_fitted</span><span class="p">,</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Fitted universe not found. Generate a fitted &quot;</span> <span class="o">+</span>
                        <span class="s">&quot;universe with fit_to_reference() first, or explicitly &quot;</span><span class="o">+</span>
                        <span class="s">&quot;set argument </span><span class="se">\&quot;</span><span class="s">fitted</span><span class="se">\&quot;</span><span class="s"> to </span><span class="se">\&quot;</span><span class="s">False</span><span class="se">\&quot;</span><span class="s"> to generate a &quot;</span>   <span class="o">+</span>
                        <span class="s">&quot;path from the original universe.&quot;</span><span class="p">)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_fitted</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_original</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">selectAtoms</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="n">frames</span><span class="o">.</span><span class="n">rewind</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">flat</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">])</span>

</div>
<div class="viewcode-block" id="Path.run"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.Path.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">postfix</span><span class="o">=</span><span class="s">&#39;_fit&#39;</span><span class="p">,</span> <span class="n">rmsdfile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">targetdir</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">curdir</span><span class="p">,</span> <span class="n">mass_weighted</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">tol_mass</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
            <span class="n">flat</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a path from a trajectory and reference structure, aligning</span>
<span class="sd">        to a reference structure if specified.</span>

<span class="sd">        .. |3D| replace:: :math:`N_p\times N\times 3`</span>
<span class="sd">        .. |2D| replace:: :math:`N_p\times 3N`</span>

<span class="sd">        This is a convenience method to generate a fitted trajectory from an</span>
<span class="sd">        inputted universe (:attr:`Path.u_original`) and reference structure</span>
<span class="sd">        (:attr:`Path.u_reference`). :meth:`Path.fit_to_reference` and</span>
<span class="sd">        :meth:`Path.to_path` are used consecutively to generate a new universe</span>
<span class="sd">        (:attr:`Path.u_fitted`) containing the fitted trajectory along with the</span>
<span class="sd">        corresponding :attr:`Path.path` represented as an</span>
<span class="sd">        :class:`numpy.ndarray`. The method returns a tuple of the topology name</span>
<span class="sd">        and new trajectory name, which can be fed directly into an</span>
<span class="sd">        :class:`MDAnalysis.Universe` object after unpacking the tuple using the</span>
<span class="sd">        ``*`` operator, as in</span>
<span class="sd">        ``MDAnalysis.Universe(*(top_name, newtraj_name))``.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *align*</span>
<span class="sd">             Align trajectory to atom selection :attr:`Path.ref_select` of</span>
<span class="sd">             :attr:`Path.u_reference`. If ``True``, a universe containing an</span>
<span class="sd">             aligned trajectory is produced with :meth:`Path.fit_to_reference`</span>
<span class="sd">             [``False``]</span>
<span class="sd">          *filename*</span>
<span class="sd">             filename for the RMS-fitted trajectory or pdb; defaults to the</span>
<span class="sd">             original trajectory filename (from :attr:`Path.u_original`) with</span>
<span class="sd">             *prefix* prepended</span>
<span class="sd">          *prefix*</span>
<span class="sd">             prefix for auto-generating the new output filename</span>
<span class="sd">          *rmsdfile*</span>
<span class="sd">             file name for writing the RMSD time series [``None``]</span>
<span class="sd">          *mass_weighted*</span>
<span class="sd">             do a mass-weighted RMSD fit</span>
<span class="sd">          *tol_mass*</span>
<span class="sd">             Reject match if the atomic masses for matched atoms differ by more</span>
<span class="sd">             than *tol_mass* [0.1]</span>
<span class="sd">          *flat*</span>
<span class="sd">             represent :attr:`Path.path` with a 2D (|2D|) :class:`numpy.ndarray`;</span>
<span class="sd">             if ``False`` then :attr:`Path.path` is a 3D (|3D|)</span>
<span class="sd">             :class:`numpy.ndarray` [``False``]</span>

<span class="sd">        :Returns:</span>
<span class="sd">          A tuple of the topology name and new trajectory name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">align</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u_fitted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_to_reference</span><span class="p">(</span>                              \
                                <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="n">postfix</span><span class="o">=</span><span class="n">postfix</span><span class="p">,</span>             \
                                <span class="n">rmsdfile</span><span class="o">=</span><span class="n">rmsdfile</span><span class="p">,</span> <span class="n">targetdir</span><span class="o">=</span><span class="n">targetdir</span><span class="p">,</span>         \
                                <span class="n">mass_weighted</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">tol_mass</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_path</span><span class="p">(</span><span class="n">fitted</span><span class="o">=</span><span class="n">align</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">newtrj_name</span>

</div></div>
<div class="viewcode-block" id="PSA"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSA">[docs]</a><span class="k">class</span> <span class="nc">PSA</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform Path Similarity Analysis (PSA) on a set of trajectories.</span>

<span class="sd">    The analysis is performed with :meth:`PSA.run` and stores the result</span>
<span class="sd">    in the :class:`numpy.ndarray` distance matrix :attr:`PSA.D`. :meth:`PSA.run`</span>
<span class="sd">    also generates a fitted trajectory and path from alignment of the original</span>
<span class="sd">    trajectories to a reference structure.</span>

<span class="sd">    .. versionadded:: 0.8</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">universes</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ref_select</span><span class="o">=</span><span class="s">&#39;name CA&#39;</span><span class="p">,</span>
                 <span class="n">ref_frame</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">path_select</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">targetdir</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Setting up Path Similarity Analysis.</span>

<span class="sd">        The mutual similarity between all unique pairs of trajectories</span>
<span class="sd">        are computed using a selected path metric.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *universes*</span>
<span class="sd">             a list of universes (:class:`MDAnalysis.Universe` object), each</span>
<span class="sd">             containing a trajectory</span>
<span class="sd">          *reference*</span>
<span class="sd">             reference coordinates; :class:`MDAnalysis.Universe` object; if</span>
<span class="sd">             ``None`` the first time step of the first item in *trajs* is used</span>
<span class="sd">             [``None``]</span>
<span class="sd">          *ref_select*</span>
<span class="sd">             The selection to operate on; can be one of:</span>

<span class="sd">             1. any valid selection string for</span>
<span class="sd">                :meth:`~MDAnalysis.core.AtomGroup.AtomGroup.selectAtoms` that</span>
<span class="sd">                produces identical selections in *mobile* and *reference*; or</span>
<span class="sd">             2. a dictionary ``{&#39;mobile&#39;:sel1, &#39;reference&#39;:sel2}`` (the</span>
<span class="sd">                :func:`MDAnalysis.analysis.align.fasta2select` function returns</span>
<span class="sd">                such a dictionary based on a ClustalW_ or STAMP_ sequence</span>
<span class="sd">                alignment); or</span>
<span class="sd">             3. a tuple ``(sel1, sel2)``</span>

<span class="sd">             When using 2. or 3. with *sel1* and *sel2* then these selections</span>
<span class="sd">             can also each be a list of selection strings (to generate an</span>
<span class="sd">             AtomGroup with defined atom order as described under</span>
<span class="sd">             :ref:`ordered-selections-label`).</span>
<span class="sd">          *mass_weighted*</span>
<span class="sd">             do a mass-weighted RMSD fit [``False``]</span>
<span class="sd">          *tol_mass*</span>
<span class="sd">             Reject match if the atomic masses for matched atoms differ by more</span>
<span class="sd">             than *tol_mass* [0.1]</span>
<span class="sd">          *ref_frame*</span>
<span class="sd">             frame index to select frame from *reference* [0]</span>
<span class="sd">          *path_select*</span>
<span class="sd">             atom selection composing coordinates of (fitted) path; if ``None``</span>
<span class="sd">             then *path_select* is set to *ref_select* [``None``]</span>
<span class="sd">          *targetdir*</span>
<span class="sd">            output files are saved there [.]</span>
<span class="sd">          *labels*</span>
<span class="sd">             list of strings, names of trajectories to be analyzed</span>
<span class="sd">             (:class:`MDAnalysis.Universe`); if ``None``, defaults to trajectory</span>
<span class="sd">             names [``None``]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universes</span> <span class="o">=</span> <span class="n">universes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_reference</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">reference</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_select</span> <span class="o">=</span> <span class="n">ref_select</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_frame</span> <span class="o">=</span> <span class="n">ref_frame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_select</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_select</span> <span class="k">if</span> <span class="n">path_select</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">path_select</span>
        <span class="k">if</span> <span class="n">targetdir</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">targetdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">curdir</span><span class="p">,</span> <span class="s">&#39;psadata&#39;</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">targetdir</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">targetdir</span><span class="p">):</span>
                    <span class="k">raise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">targetdir</span><span class="p">)</span>

        <span class="c"># Set default directory names for storing topology/reference structures,</span>
        <span class="c"># fitted trajectories, paths, distance matrices, and plots</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datadirs</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;fitted_trajs&#39;</span> <span class="p">:</span> <span class="s">&#39;/fitted_trajs&#39;</span><span class="p">,</span>
                         <span class="s">&#39;paths&#39;</span> <span class="p">:</span> <span class="s">&#39;/paths&#39;</span><span class="p">,</span>
                         <span class="s">&#39;distance_matrices&#39;</span> <span class="p">:</span> <span class="s">&#39;/distance_matrices&#39;</span><span class="p">,</span>
                         <span class="s">&#39;plots&#39;</span> <span class="p">:</span> <span class="s">&#39;/plots&#39;</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">dir_name</span><span class="p">,</span> <span class="n">directory</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">datadirs</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">full_dir_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="n">dir_name</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">full_dir_name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">full_dir_name</span><span class="p">):</span>
                    <span class="k">raise</span>

        <span class="c"># Keep track of topology, trajectory, and related files</span>
        <span class="n">trj_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universes</span><span class="p">):</span>
            <span class="n">head</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">filename</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
            <span class="n">trj_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trj_names</span> <span class="o">=</span> <span class="n">trj_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_trj_names</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_names</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">universes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">trj_names</span>

        <span class="c"># Names of persistence (pickle) files where topology and trajectory</span>
        <span class="c"># filenames are stored--should not be modified by user</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_top_pkl</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="s">&quot;psa_top-name.pkl&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trjs_pkl</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="s">&quot;psa_orig-traj-names.pkl&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fit_trjs_pkl</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="s">&quot;psa_fitted-traj-names.pkl&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paths_pkl</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="s">&quot;psa_path-names.pkl&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels_pkl</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="s">&quot;psa_labels.pkl&quot;</span><span class="p">)</span>
        <span class="c"># Pickle topology and trajectory filenames for this analysis to curdir</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_top_pkl</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_name</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trjs_pkl</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trj_names</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels_pkl</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">paths</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="bp">None</span>


<div class="viewcode-block" id="PSA.generate_paths"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSA.generate_paths">[docs]</a>    <span class="k">def</span> <span class="nf">generate_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate paths, aligning each to reference structure if necessary.</span>

<span class="sd">        .. |3D| replace:: :math:`N_p\times N\times 3`</span>
<span class="sd">        .. |2D| replace:: :math:`N_p\times 3N`</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *align*</span>
<span class="sd">             Align trajectories to atom selection :attr:`PSA.ref_select` of</span>
<span class="sd">             :attr:`PSA.u_reference` [``False``]</span>
<span class="sd">          *filename*</span>
<span class="sd">             strings representing base filename for fitted trajectories and</span>
<span class="sd">             paths [``None``]</span>
<span class="sd">          *infix*</span>
<span class="sd">             additional tag string that is inserted into the output filename of</span>
<span class="sd">             the fitted trajectory files [&#39;&#39;]</span>
<span class="sd">          *mass_weighted*</span>
<span class="sd">             do a mass-weighted RMSD fit</span>
<span class="sd">          *tol_mass*</span>
<span class="sd">             Reject match if the atomic masses for matched atoms differ by more</span>
<span class="sd">             than *tol_mass*</span>
<span class="sd">          *ref_frame*</span>
<span class="sd">             frame index to select frame from *reference*</span>
<span class="sd">          *flat*</span>
<span class="sd">             represent :attr:`Path.path` as a 2D (|2D|) :class:`numpy.ndarray`; if</span>
<span class="sd">             ``False`` then :attr:`Path.path` is a 3D (|3D|)</span>
<span class="sd">             :class:`numpy.ndarray` [``False``]</span>
<span class="sd">          *save*</span>
<span class="sd">             boolean; if ``True``, pickle list of names for fitted trajectories</span>
<span class="sd">             [``True``]</span>
<span class="sd">          *store*</span>
<span class="sd">             boolean; if ``True`` then writes each path (:class:`numpy.ndarray`)</span>
<span class="sd">             in :attr:`PSA.paths` to compressed npz (numpy) files [``False``]</span>

<span class="sd">        The fitted trajectories are written to new files in the</span>
<span class="sd">        &quot;/trj_fit&quot; subdirectory in :attr:`PSA.targetdir` named</span>
<span class="sd">        &quot;filename(*trajectory*)XXX*infix*_psa&quot;, where &quot;XXX&quot; is a number between</span>
<span class="sd">        000 and 999; the extension of each file is the same as its original.</span>
<span class="sd">        Optionally, the trajectories can also be saved in numpy compressed npz</span>
<span class="sd">        format in the &quot;/paths&quot; subdirectory in :attr:`PSA.targetdir` for</span>
<span class="sd">        persistence and can be accessed as the attribute :attr:`PSA.paths`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">align</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;align&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;filename&#39;</span><span class="p">,</span> <span class="s">&#39;fitted&#39;</span><span class="p">)</span>
        <span class="n">infix</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;infix&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
        <span class="n">mass_weighted</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;mass_weighted&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="n">tol_mass</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;tol_mass&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="n">ref_frame</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;ref_frame&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_frame</span><span class="p">)</span>
        <span class="n">flat</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;flat&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="n">save</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;save&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">store</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;store&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

        <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fit_trj_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universes</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_reference</span><span class="p">,</span> <span class="n">ref_select</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_select</span><span class="p">,</span>           \
                     <span class="n">path_select</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">path_select</span><span class="p">,</span> <span class="n">ref_frame</span><span class="o">=</span><span class="n">ref_frame</span><span class="p">)</span>
            <span class="n">trj_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">datadirs</span><span class="p">[</span><span class="s">&#39;fitted_trajs&#39;</span><span class="p">]</span>
            <span class="n">postfix</span> <span class="o">=</span> <span class="s">&#39;{}{}{:03n}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">infix</span><span class="p">,</span> <span class="s">&#39;_psa&#39;</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">top_name</span><span class="p">,</span> <span class="n">fit_trj_name</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span>      \
                                           <span class="n">postfix</span><span class="o">=</span><span class="n">postfix</span><span class="p">,</span>                     \
                                           <span class="n">targetdir</span><span class="o">=</span><span class="n">trj_dir</span><span class="p">,</span>                   \
                                           <span class="n">mass_weighted</span><span class="o">=</span><span class="n">mass_weighted</span><span class="p">,</span>         \
                                           <span class="n">tol_mass</span><span class="o">=</span><span class="n">tol_mass</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">)</span>
            <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="n">fit_trj_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_trj_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paths</span> <span class="o">=</span> <span class="n">paths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_trj_names</span> <span class="o">=</span> <span class="n">fit_trj_names</span>
        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fit_trjs_pkl</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_trj_names</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;filename&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_paths</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="PSA.run"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSA.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform path similarity analysis on the trajectories to compute</span>
<span class="sd">        the distance matrix.</span>

<span class="sd">        A number of parameters can be changed from the defaults. The</span>
<span class="sd">        result is stored as the array :attr:`PSA.D`.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *metric*</span>
<span class="sd">             selection string specifying the path metric to measure pairwise</span>
<span class="sd">             distances among :attr:`PSA.paths` [``&#39;hausdorff&#39;``]</span>
<span class="sd">          *start*, *stop*, *step*</span>
<span class="sd">             start and stop frame index with step size: analyze</span>
<span class="sd">             ``trajectory[start:stop:step]`` [``None``]</span>
<span class="sd">          *store*</span>
<span class="sd">             boolean; if ``True`` then writes :attr:`PSA.D` to text and</span>
<span class="sd">             compressed npz (numpy) files [``True``]</span>
<span class="sd">          *filename*</span>
<span class="sd">             string, filename to save :attr:`PSA.D`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">metric</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;metric&#39;</span><span class="p">,</span> <span class="s">&#39;hausdorff&#39;</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;start&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;stop&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;step&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">store</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;store&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

        <span class="n">metric_func</span> <span class="o">=</span> <span class="n">get_path_metric_func</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span>
        <span class="n">npaths</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npaths</span><span class="p">,</span><span class="n">npaths</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">npaths</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">npaths</span><span class="p">):</span>
                <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">]</span>
                <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">]</span>
                <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">metric_func</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">D</span>
        <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;filename&#39;</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_result</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="PSA.save_result"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSA.save_result">[docs]</a>    <span class="k">def</span> <span class="nf">save_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save distance matrix :attr:`PSA.D` to a numpy compressed npz file and</span>
<span class="sd">        text file.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *filename*</span>
<span class="sd">             string, specifies filename [``None``]</span>

<span class="sd">        The data are saved with :func:`numpy.savez_compressed` and</span>
<span class="sd">        :func:`numpy.savetxt` in the directory specified by</span>
<span class="sd">        :attr:`PSA.targetdir`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span> <span class="ow">or</span> <span class="s">&#39;psa_distances&#39;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">datadirs</span><span class="p">[</span><span class="s">&#39;distance_matrices&#39;</span><span class="p">]</span>
        <span class="n">outfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s">&quot;Distance matrix has not been calculated yet&quot;</span><span class="p">)</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">outfile</span> <span class="o">+</span> <span class="s">&#39;.npy&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">)</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">outfile</span> <span class="o">+</span> <span class="s">&#39;.dat&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Wrote distance matrix to file </span><span class="si">%r</span><span class="s">.npz&quot;</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Wrote distance matrix to file </span><span class="si">%r</span><span class="s">.dat&quot;</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">filename</span>

</div>
<div class="viewcode-block" id="PSA.save_paths"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSA.save_paths">[docs]</a>    <span class="k">def</span> <span class="nf">save_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save fitted :attr:`PSA.paths` to numpy compressed npz files.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *filename*</span>
<span class="sd">             string, specifies filename [``None``]</span>

<span class="sd">        The data are saved with :func:`numpy.savez_compressed` in the directory</span>
<span class="sd">        specified by :attr:`PSA.targetdir`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span> <span class="ow">or</span> <span class="s">&#39;path_psa&#39;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">datadirs</span><span class="p">[</span><span class="s">&#39;paths&#39;</span><span class="p">]</span>
        <span class="n">outfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s">&quot;Paths have not been calculated yet&quot;</span><span class="p">)</span>
        <span class="n">path_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">path</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">):</span>
            <span class="n">current_outfile</span> <span class="o">=</span> <span class="s">&quot;{}{:03n}.npy&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">current_outfile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">path_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_outfile</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Wrote path to file </span><span class="si">%r</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current_outfile</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_names</span> <span class="o">=</span> <span class="n">path_names</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_paths_pkl</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_names</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">filename</span>

</div>
<div class="viewcode-block" id="PSA.load"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSA.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load fitted paths specified by &#39;psa_path-names.pkl&#39; in</span>
<span class="sd">        :attr:`PSA.targetdir`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_paths_pkl</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s">&quot;Fitted trajectories cannot be loaded; save file&quot;</span> <span class="o">+</span>
                              <span class="s">&quot;{} does not exist.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_paths_pkl</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_names</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_paths_pkl</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">pname</span><span class="p">)</span> <span class="k">for</span> <span class="n">pname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels_pkl</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels_pkl</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Loaded paths from &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths_pkl</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="PSA.plot"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSA.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">linkage</span><span class="o">=</span><span class="s">&#39;ward&#39;</span><span class="p">,</span> <span class="n">count_sort</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
             <span class="n">distance_sort</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="mf">4.5</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="mi">12</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot a clustered distance matrix using method *linkage* along with</span>
<span class="sd">        the corresponding dendrogram. Rows (and columns) are identified using</span>
<span class="sd">        the list of strings specified by :attr:`PSA.labels`.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *filename*</span>
<span class="sd">             string, save figure to *filename* [``None``]</span>
<span class="sd">          *linkage*</span>
<span class="sd">             string, name of linkage criterion for clustering [``&#39;ward&#39;``]</span>
<span class="sd">          *figsize*</span>
<span class="sd">             set the vertical size of plot in inches [``6``]</span>
<span class="sd">          *labelsize*</span>
<span class="sd">             set the font size for colorbar labels; font size for path labels on</span>
<span class="sd">             dendrogram default to 3 points smaller [``12``]</span>

<span class="sd">        If *filename* is supplied then the figure is also written to file (the</span>
<span class="sd">        suffix determines the file type, e.g. pdf, png, eps, ...). All other</span>
<span class="sd">        keyword arguments are passed on to :func:`pylab.imshow`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="n">cm</span><span class="p">,</span> <span class="n">savefig</span>
        <span class="kn">from</span> <span class="nn">matplotlib.pylab</span> <span class="kn">import</span> <span class="n">figure</span><span class="p">,</span> <span class="n">colorbar</span>
        <span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">squareform</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;No distance data; do &#39;PSA.run(store=True)&#39; first.&quot;</span><span class="p">)</span>
        <span class="n">npaths</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">)</span>
        <span class="n">distMatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span>

        <span class="n">dgram_loc</span><span class="p">,</span> <span class="n">hmap_loc</span><span class="p">,</span> <span class="n">cbar_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_plot_obj_locs</span><span class="p">()</span>
        <span class="n">aspect_ratio</span> <span class="o">=</span> <span class="mf">1.2</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">figsize</span><span class="o">*</span><span class="n">aspect_ratio</span><span class="p">,</span><span class="n">figsize</span><span class="p">))</span>
        <span class="n">ax_hmap</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">(</span><span class="n">hmap_loc</span><span class="p">)</span>
        <span class="n">ax_dgram</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">(</span><span class="n">dgram_loc</span><span class="p">)</span>

        <span class="n">Z</span><span class="p">,</span> <span class="n">dgram</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="p">(</span><span class="n">distMatrix</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">linkage</span><span class="p">,</span>
                            <span class="n">count_sort</span><span class="o">=</span><span class="n">count_sort</span><span class="p">,</span> <span class="n">distance_sort</span><span class="o">=</span><span class="n">distance_sort</span><span class="p">)</span>
        <span class="n">rowidx</span> <span class="o">=</span> <span class="n">colidx</span> <span class="o">=</span> <span class="n">dgram</span><span class="p">[</span><span class="s">&#39;leaves&#39;</span><span class="p">]</span> <span class="c"># get row-wise ordering from clustering</span>
        <span class="n">ax_dgram</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span> <span class="c"># Place origin at up left (from low left)</span>

        <span class="n">minDist</span><span class="p">,</span> <span class="n">maxDist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">distMatrix</span><span class="p">)</span>
        <span class="n">clustMatrix</span> <span class="o">=</span> <span class="n">distMatrix</span><span class="p">[</span><span class="n">rowidx</span><span class="p">,:]</span>
        <span class="n">clustMatrix</span> <span class="o">=</span> <span class="n">clustMatrix</span><span class="p">[:,</span><span class="n">colidx</span><span class="p">]</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">ax_hmap</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><span class="n">clustMatrix</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s">&#39;auto&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s">&#39;lower&#39;</span><span class="p">,</span>        \
                    <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">YlGn</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">minDist</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">maxDist</span><span class="p">)</span>
        <span class="n">ax_hmap</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span> <span class="c"># Place origin at upper left (from lower left)</span>
        <span class="n">ax_hmap</span><span class="o">.</span><span class="n">locator_params</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="n">npaths</span><span class="p">)</span>
        <span class="n">ax_hmap</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npaths</span><span class="p">),</span> <span class="n">minor</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">ax_hmap</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npaths</span><span class="p">),</span> <span class="n">minor</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">ax_hmap</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s">&#39;both&#39;</span><span class="p">,</span> <span class="n">labelleft</span><span class="o">=</span><span class="s">&#39;off&#39;</span><span class="p">,</span>            \
                        <span class="n">labelright</span><span class="o">=</span><span class="s">&#39;off&#39;</span><span class="p">,</span> <span class="n">labeltop</span><span class="o">=</span><span class="s">&#39;on&#39;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ax_hmap</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s">&#39;y&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s">&#39;both&#39;</span><span class="p">,</span> <span class="n">labelleft</span><span class="o">=</span><span class="s">&#39;on&#39;</span><span class="p">,</span>             \
                <span class="n">labelright</span><span class="o">=</span><span class="s">&#39;off&#39;</span><span class="p">,</span> <span class="n">labeltop</span><span class="o">=</span><span class="s">&#39;off&#39;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">rowlabels</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rowidx</span><span class="p">]</span>
        <span class="n">collabels</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">colidx</span><span class="p">]</span>
        <span class="n">ax_hmap</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">collabels</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="s">&#39;vertical&#39;</span><span class="p">,</span>                 \
                <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">labelsize</span><span class="o">-</span><span class="mi">4</span><span class="p">),</span> <span class="n">multialignment</span><span class="o">=</span><span class="s">&#39;center&#39;</span><span class="p">,</span> <span class="n">minor</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">ax_hmap</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">rowlabels</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="s">&#39;horizontal&#39;</span><span class="p">,</span>               \
                <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">labelsize</span><span class="o">-</span><span class="mi">4</span><span class="p">),</span> <span class="n">multialignment</span><span class="o">=</span><span class="s">&#39;left&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s">&#39;right&#39;</span><span class="p">,</span>         \
                <span class="n">minor</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="n">ax_color</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">(</span><span class="n">cbar_loc</span><span class="p">)</span>
        <span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">ax_color</span><span class="p">,</span> <span class="n">ticks</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">minDist</span><span class="p">,</span> <span class="n">maxDist</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>  \
                <span class="n">format</span><span class="o">=</span><span class="s">&quot;</span><span class="si">%0.2f</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="n">ax_color</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="n">labelsize</span><span class="p">)</span>

        <span class="c"># Remove tickmarks from border of heatmap and colorbar</span>
        <span class="k">for</span> <span class="n">tic</span> <span class="ow">in</span> <span class="n">ax_hmap</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">get_major_ticks</span><span class="p">():</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick1On</span> <span class="o">=</span> <span class="n">tic</span><span class="o">.</span><span class="n">tick2On</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">label1On</span> <span class="o">=</span> <span class="n">tic</span><span class="o">.</span><span class="n">label2On</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">tic</span> <span class="ow">in</span> <span class="n">ax_hmap</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">get_minor_ticks</span><span class="p">():</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick1On</span> <span class="o">=</span> <span class="n">tic</span><span class="o">.</span><span class="n">tick2On</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">tic</span> <span class="ow">in</span> <span class="n">ax_hmap</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">get_major_ticks</span><span class="p">():</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick1On</span> <span class="o">=</span> <span class="n">tic</span><span class="o">.</span><span class="n">tick2On</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">label1On</span> <span class="o">=</span> <span class="n">tic</span><span class="o">.</span><span class="n">label2On</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">tic</span> <span class="ow">in</span> <span class="n">ax_hmap</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">get_minor_ticks</span><span class="p">():</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick1On</span> <span class="o">=</span> <span class="n">tic</span><span class="o">.</span><span class="n">tick2On</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">tic</span> <span class="ow">in</span> <span class="n">ax_color</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">get_major_ticks</span><span class="p">():</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick1On</span> <span class="o">=</span> <span class="n">tic</span><span class="o">.</span><span class="n">tick2On</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">datadirs</span><span class="p">[</span><span class="s">&#39;plots&#39;</span><span class="p">]</span>
            <span class="n">outfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
            <span class="n">savefig</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s">&#39;tight&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Z</span><span class="p">,</span> <span class="n">dgram</span>

</div>
<div class="viewcode-block" id="PSA.cluster"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSA.cluster">[docs]</a>    <span class="k">def</span> <span class="nf">cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distArray</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;ward&#39;</span><span class="p">,</span> <span class="n">count_sort</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                <span class="n">distance_sort</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">no_labels</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">color_threshold</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Cluster trajectories.</span>

<span class="sd">            :Arguments:</span>
<span class="sd">              *method*</span>
<span class="sd">                string, name of linkage criterion for clustering [``&#39;ward&#39;``]</span>
<span class="sd">              *no_labels*</span>
<span class="sd">                boolean, if ``True`` then do not label dendrogram [``True``]</span>
<span class="sd">              *color_threshold*</span>
<span class="sd">                For brevity, let t be the color_threshold. Colors all the</span>
<span class="sd">                descendent links below a cluster node k the same color if k is</span>
<span class="sd">                the first node below the cut threshold t. All links connecting</span>
<span class="sd">                nodes with distances greater than or equal to the threshold are</span>
<span class="sd">                colored blue. If t is less than or equal to zero, all nodes are</span>
<span class="sd">                colored blue. If color_threshold is None or ‘default’,</span>
<span class="sd">                corresponding with MATLAB(TM) behavior, the threshold is set to</span>
<span class="sd">                0.7*max(Z[:,2]). [``4``]]</span>
<span class="sd">            :Returns:</span>
<span class="sd">              list of indices representing the row-wise order of the objects</span>
<span class="sd">              after clustering</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib</span>
        <span class="kn">from</span> <span class="nn">scipy.cluster.hierarchy</span> <span class="kn">import</span> <span class="n">linkage</span><span class="p">,</span> <span class="n">dendrogram</span>
        <span class="kn">from</span> <span class="nn">brewer2mpl</span> <span class="kn">import</span> <span class="n">get_map</span>

        <span class="n">color_list</span> <span class="o">=</span> <span class="n">get_map</span><span class="p">(</span><span class="s">&#39;Set1&#39;</span><span class="p">,</span> <span class="s">&#39;qualitative&#39;</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">mpl_colors</span>
        <span class="n">matplotlib</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s">&#39;lines.linewidth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>

        <span class="n">Z</span> <span class="o">=</span> <span class="n">linkage</span><span class="p">(</span><span class="n">distArray</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
        <span class="n">dgram</span> <span class="o">=</span> <span class="n">dendrogram</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">no_labels</span><span class="o">=</span><span class="n">no_labels</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s">&#39;right&#39;</span><span class="p">,</span>
                           <span class="n">count_sort</span><span class="o">=</span><span class="n">count_sort</span><span class="p">,</span> <span class="n">distance_sort</span><span class="o">=</span><span class="n">distance_sort</span><span class="p">,</span>
                           <span class="n">color_threshold</span><span class="o">=</span><span class="n">color_threshold</span><span class="p">,</span>
                           <span class="n">color_list</span><span class="o">=</span><span class="n">color_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Z</span><span class="p">,</span> <span class="n">dgram</span>

</div>
    <span class="k">def</span> <span class="nf">_get_plot_obj_locs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Return the coordinates for dendrogram, heat map, and colorbar.</span>

<span class="sd">            :Returns:</span>
<span class="sd">              tuple of coordinates for placing the dendrogram, heat map, and</span>
<span class="sd">              colorbar in the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plot_xstart</span> <span class="o">=</span> <span class="mf">0.04</span>
        <span class="n">plot_ystart</span> <span class="o">=</span> <span class="mf">0.04</span>
        <span class="n">label_margin</span> <span class="o">=</span> <span class="mf">0.155</span>

        <span class="n">dgram_height</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="c"># dendrogram heights(s)</span>
        <span class="n">hmap_xstart</span> <span class="o">=</span> <span class="n">plot_xstart</span> <span class="o">+</span> <span class="n">dgram_height</span> <span class="o">+</span> <span class="n">label_margin</span>

        <span class="c"># Set locations for dendrogram(s), matrix, and colorbar</span>
        <span class="n">hmap_height</span> <span class="o">=</span> <span class="mf">0.8</span>
        <span class="n">hmap_width</span> <span class="o">=</span> <span class="mf">0.6</span>
        <span class="n">dgram_loc</span> <span class="o">=</span> <span class="p">[</span><span class="n">plot_xstart</span><span class="p">,</span> <span class="n">plot_ystart</span><span class="p">,</span> <span class="n">dgram_height</span><span class="p">,</span> <span class="n">hmap_height</span><span class="p">]</span>
        <span class="n">cbar_width</span> <span class="o">=</span> <span class="mf">0.02</span>
        <span class="n">cbar_xstart</span> <span class="o">=</span> <span class="n">hmap_xstart</span> <span class="o">+</span> <span class="n">hmap_width</span> <span class="o">+</span> <span class="mf">0.01</span>
        <span class="n">cbar_loc</span> <span class="o">=</span> <span class="p">[</span><span class="n">cbar_xstart</span><span class="p">,</span> <span class="n">plot_ystart</span><span class="p">,</span> <span class="n">cbar_width</span><span class="p">,</span> <span class="n">hmap_height</span><span class="p">]</span>
        <span class="n">hmap_loc</span> <span class="o">=</span>  <span class="p">[</span><span class="n">hmap_xstart</span><span class="p">,</span> <span class="n">plot_ystart</span><span class="p">,</span> <span class="n">hmap_width</span><span class="p">,</span> <span class="n">hmap_height</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">dgram_loc</span><span class="p">,</span> <span class="n">hmap_loc</span><span class="p">,</span> <span class="n">cbar_loc</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">MDAnalysis 0.10.0-dev documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../MDAnalysis.html" >MDAnalysis</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Joshua Adelman,
    Christian Beckstein (logo), Alejandro Bernardin, Sébastien Buchoux,
    David Caplan, Matthieu Chavent, Xavier Deupi, Jan Domański, David L. Dotson
    Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar,
    Benjamin Hall, Joe Jordan, Jinju Lu, Robert McGibbon, Alex Nesterenko,
    Manuel Nuno Melo, Caio S. Souza, Danny Parton, Joshua L. Phillips, Tyler Reddy,
    Paul Rigor, Sean L. Seyler, Andy Somogyi, Lukas Stelzl, Zhuyi Xue,
    and Oliver Beckstein.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>